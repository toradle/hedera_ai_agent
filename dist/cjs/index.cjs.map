{"version":3,"file":"index.cjs","sources":["../../src/utils/logger.ts","../../src/utils/key-type-detector.ts","../../src/builders/base-service-builder.ts","../../src/builders/hcs/hcs-builder.ts","../../src/builders/hts/hts-builder.ts","../../src/builders/account/account-builder.ts","../../src/builders/scs/scs-builder.ts","../../src/builders/query/query-builder.ts","../../src/types/model-capability.ts","../../src/services/mirror-node/mirror-node.ts","../../src/agent/agent.ts","../../src/utils/model-capability-detector.ts","../../src/utils/token-usage-tracker.ts","../../src/signer/abstract-signer.ts","../../src/types/index.ts","../../src/utils/key-utils.ts","../../src/langchain/tools/common/base-hedera-transaction-tool.ts","../../src/langchain/tools/account/create-account-tool.ts","../../src/langchain/tools/account/transfer-hbar-tool.ts","../../src/langchain/tools/account/update-account-tool.ts","../../src/langchain/tools/account/delete-account-tool.ts","../../src/langchain/tools/account/approve-hbar-allowance-tool.ts","../../src/langchain/tools/account/approve-fungible-token-allowance-tool.ts","../../src/langchain/tools/account/approve-token-nft-allowance-tool.ts","../../src/langchain/tools/account/revoke-hbar-allowance-tool.ts","../../src/langchain/tools/account/revoke-fungible-token-allowance-tool.ts","../../src/langchain/tools/account/delete-nft-spender-allowance-tool.ts","../../src/langchain/tools/account/delete-nft-allowance-all-serials-tool.ts","../../src/langchain/tools/common/base-hedera-query-tool.ts","../../src/langchain/tools/account/get-outstanding-airdrops-tool.ts","../../src/langchain/tools/account/get-pending-airdrops-tool.ts","../../src/langchain/tools/account/get-account-balance-tool.ts","../../src/langchain/tools/account/get-account-info-tool.ts","../../src/langchain/tools/account/get-account-nfts-tool.ts","../../src/langchain/tools/account/get-account-public-key-tool.ts","../../src/langchain/tools/account/get-account-tokens-tool.ts","../../src/langchain/tools/account/sign-and-execute-scheduled-transaction-tool.ts","../../src/langchain/tools/hcs/create-topic-tool.ts","../../src/langchain/tools/hcs/submit-message-tool.ts","../../src/langchain/tools/hcs/delete-topic-tool.ts","../../src/langchain/tools/hcs/update-topic-tool.ts","../../src/langchain/tools/hcs/get-topic-messages-tool.ts","../../src/langchain/tools/hcs/get-topic-info-tool.ts","../../src/langchain/tools/hcs/get-topic-fees-tool.ts","../../src/langchain/tools/hts/airdrop-token-tool.ts","../../src/langchain/tools/hts/associate-tokens-tool.ts","../../src/langchain/tools/hts/burn-fungible-token-tool.ts","../../src/langchain/tools/hts/burn-nft-tool.ts","../../src/langchain/tools/hts/claim-airdrop-tool.ts","../../src/langchain/tools/hts/hts-tool-utils.ts","../../src/langchain/tools/hts/create-fungible-token-tool.ts","../../src/langchain/tools/hts/create-nft-tool.ts","../../src/langchain/tools/hts/delete-token-tool.ts","../../src/langchain/tools/hts/dissociate-tokens-tool.ts","../../src/langchain/tools/hts/freeze-token-account-tool.ts","../../src/langchain/tools/hts/get-token-info-tool.ts","../../src/langchain/tools/hts/grant-kyc-token-tool.ts","../../src/langchain/tools/hts/mint-fungible-token-tool.ts","../../src/langchain/tools/hts/mint-nft-tool.ts","../../src/langchain/tools/hts/pause-token-tool.ts","../../src/langchain/tools/hts/reject-tokens-tool.ts","../../src/langchain/tools/hts/revoke-kyc-token-tool.ts","../../src/langchain/tools/hts/token-fee-schedule-update-tool.ts","../../src/langchain/tools/hts/transfer-nft-tool.ts","../../src/langchain/tools/hts/transfer-tokens-tool.ts","../../src/langchain/tools/hts/unfreeze-token-account-tool.ts","../../src/langchain/tools/hts/unpause-token-tool.ts","../../src/langchain/tools/hts/update-token-tool.ts","../../src/langchain/tools/hts/validate-nft-ownership-tool.ts","../../src/langchain/tools/hts/wipe-token-account-tool.ts","../../src/langchain/tools/scs/delete-contract-tool.ts","../../src/langchain/tools/scs/get-contract-tool.ts","../../src/langchain/tools/scs/get-contracts-tool.ts","../../src/langchain/tools/scs/update-contract-tool.ts","../../src/langchain/tools/network/get-hbar-price-tool.ts","../../src/langchain/tools/network/get-network-info-tool.ts","../../src/langchain/tools/network/get-network-fees-tool.ts","../../src/langchain/tools/network/get-blocks-tool.ts","../../src/langchain/tools/transaction/get-transaction-tool.ts","../../src/plugins/BasePlugin.ts","../../src/plugins/core/HederaHTSPlugin.ts","../../src/plugins/core/HederaHCSPlugin.ts","../../src/plugins/core/HederaAccountPlugin.ts","../../src/plugins/core/HederaSCSPlugin.ts","../../src/plugins/core/HederaNetworkPlugin.ts","../../src/agent/conversational-agent.ts","../../src/plugins/PluginRegistry.ts","../../src/signer/server-signer.ts","../../src/utils/date-format-utils.ts","../../src/utils/api-utils.ts","../../src/utils/format-units.ts","../../src/plugins/core/index.ts"],"sourcesContent":["import pino from 'pino';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  module?: string;\n  prettyPrint?: boolean;\n  silent?: boolean;\n}\nexport class Logger {\n  private static instances: Map<string, Logger> = new Map();\n  private logger: pino.Logger;\n  private moduleContext: string;\n\n  constructor(options: LoggerOptions = {}) {\n    const globalDisable = process.env.DISABLE_LOGS === 'true';\n\n    const shouldSilence = options.silent || globalDisable;\n    const level = shouldSilence ? 'silent' : options.level || 'info';\n    this.moduleContext = options.module || 'app';\n\n    const shouldEnablePrettyPrint =\n      !shouldSilence && options.prettyPrint !== false;\n    const pinoOptions = {\n      level,\n      enabled: !shouldSilence,\n      transport: shouldEnablePrettyPrint\n        ? {\n            target: 'pino-pretty',\n            options: {\n              colorize: true,\n              translateTime: 'SYS:standard',\n              ignore: 'pid,hostname',\n            },\n          }\n        : undefined,\n    };\n\n    // @ts-ignore\n    this.logger = pino(pinoOptions);\n  }\n\n  static getInstance(options: LoggerOptions = {}): Logger {\n    const moduleKey = options.module || 'default';\n\n    const globalDisable = process.env.DISABLE_LOGS === 'true';\n\n    if (globalDisable && Logger.instances.has(moduleKey)) {\n      const existingLogger = Logger.instances.get(moduleKey)!;\n      if (existingLogger.getLevel() !== 'silent') {\n        Logger.instances.delete(moduleKey);\n      }\n    }\n\n    if (!Logger.instances.has(moduleKey)) {\n      Logger.instances.set(moduleKey, new Logger(options));\n    }\n\n    return Logger.instances.get(moduleKey)!;\n  }\n\n  setLogLevel(level: LogLevel): void {\n    this.logger.level = level;\n  }\n\n  getLevel(): LogLevel {\n    return this.logger.level as LogLevel;\n  }\n\n  setSilent(silent: boolean): void {\n    if (silent) {\n      this.logger.level = 'silent';\n    }\n  }\n\n  setModule(module: string): void {\n    this.moduleContext = module;\n  }\n\n  debug(...args: any[]): void {\n    this.logger.debug({ module: this.moduleContext }, ...args);\n  }\n\n  info(...args: any[]): void {\n    this.logger.info({ module: this.moduleContext }, ...args);\n  }\n\n  warn(...args: any[]): void {\n    this.logger.warn({ module: this.moduleContext }, ...args);\n  }\n\n  error(...args: any[]): void {\n    this.logger.error({ module: this.moduleContext }, ...args);\n  }\n\n  trace(...args: any[]): void {\n    this.logger.trace({ module: this.moduleContext }, ...args);\n  }\n}\n","import { PrivateKey } from '@hashgraph/sdk';\n\nexport type KeyType = 'ed25519' | 'ecdsa';\n\nexport interface KeyDetectionResult {\n  detectedType: KeyType;\n  privateKey: PrivateKey;\n}\n\n/**\n * Detects the key type from a private key string and returns the parsed PrivateKey\n * @param privateKeyString The private key string to detect type from\n * @returns The detected key type and parsed PrivateKey\n * @throws Error if the private key cannot be parsed\n */\nexport function detectKeyTypeFromString(\n  privateKeyString: string\n): KeyDetectionResult {\n  let detectedType: KeyType = 'ed25519';\n\n  if (privateKeyString.startsWith('0x')) {\n    detectedType = 'ecdsa';\n  } else if (privateKeyString.startsWith('302e020100300506032b6570')) {\n    detectedType = 'ed25519';\n  } else if (privateKeyString.startsWith('3030020100300706052b8104000a')) {\n    detectedType = 'ecdsa';\n  } else if (privateKeyString.length === 96) {\n    detectedType = 'ed25519';\n  } else if (privateKeyString.length === 88) {\n    detectedType = 'ecdsa';\n  }\n\n  try {\n    const privateKey =\n      detectedType === 'ecdsa'\n        ? PrivateKey.fromStringECDSA(privateKeyString)\n        : PrivateKey.fromStringED25519(privateKeyString);\n    return { detectedType, privateKey };\n  } catch (parseError) {\n    const alternateType = detectedType === 'ecdsa' ? 'ed25519' : 'ecdsa';\n    try {\n      const privateKey =\n        alternateType === 'ecdsa'\n          ? PrivateKey.fromStringECDSA(privateKeyString)\n          : PrivateKey.fromStringED25519(privateKeyString);\n      return { detectedType: alternateType, privateKey };\n    } catch (secondError) {\n      throw new Error(\n        `Failed to parse private key as either ED25519 or ECDSA: ${parseError}`\n      );\n    }\n  }\n}\n","import {\n  AccountId,\n  Transaction,\n  TransactionId,\n  TransactionReceipt,\n  ScheduleCreateTransaction,\n  ScheduleId,\n  Key,\n  PublicKey,\n  PrivateKey,\n  KeyList,\n  Long,\n} from '@hashgraph/sdk';\nimport { Buffer } from 'buffer';\nimport { AbstractSigner } from '../signer/abstract-signer';\nimport { Logger } from '../utils/logger';\nimport { detectKeyTypeFromString } from '../utils/key-type-detector';\nimport type { HederaAgentKit } from '../agent/agent';\n\n/**\n * Defines the structure for the result of an execute operation.\n */\nexport interface ExecuteResult {\n  success: boolean;\n  receipt?: TransactionReceipt;\n  scheduleId?: ScheduleId | string | undefined;\n  error?: string;\n  transactionId?: string | undefined;\n}\n\n/**\n * BaseServiceBuilder provides common functionality for service-specific builders.\n * It manages the current transaction being built and offers common execution and byte generation methods.\n */\nexport abstract class BaseServiceBuilder {\n  protected currentTransaction: Transaction | null = null;\n  protected logger: Logger;\n  protected kit: HederaAgentKit;\n  protected notes: string[] = [];\n\n  /**\n   * @param {HederaAgentKit} kit - The HederaAgentKit instance\n   */\n  constructor(protected readonly hederaKit: HederaAgentKit) {\n    this.kit = hederaKit;\n\n    const shouldDisableLogs = process.env.DISABLE_LOGS === 'true';\n\n    this.logger = new Logger({\n      module: 'ServiceBuilder',\n      level: shouldDisableLogs ? 'silent' : 'info',\n      silent: shouldDisableLogs,\n    });\n  }\n\n  /**\n   * Helper method to get the effective sender account to use for transactions.\n   * In user-centric contexts, this will be the user's account. Otherwise, it falls back to the signer's account.\n   * @returns {AccountId} The account ID to use as sender\n   */\n  protected getEffectiveSenderAccountId(): AccountId {\n    if (this.kit.userAccountId) {\n      return AccountId.fromString(this.kit.userAccountId);\n    }\n    return this.kit.signer.getAccountId();\n  }\n\n  /**\n   * Helper method to determine if a transaction is a user-initiated transfer.\n   * Used for properly constructing transfer arrays.\n   * @param {boolean} isUserInitiated Whether this is a user-initiated transfer\n   * @returns {AccountId} The account that should be used as the sender\n   */\n  protected getTransferSourceAccount(\n    isUserInitiated: boolean = true\n  ): AccountId {\n    if (isUserInitiated && this.kit.userAccountId) {\n      return AccountId.fromString(this.kit.userAccountId);\n    }\n    return this.kit.signer.getAccountId();\n  }\n\n  /**\n   * @param {string} memo\n   * @returns {this}\n   * @throws {Error}\n   */\n  public setTransactionMemo(memo: string): this {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction is currently being built. Call a specific transaction method first (e.g., createTopic).'\n      );\n    }\n    this.currentTransaction.setTransactionMemo(memo);\n    return this;\n  }\n\n  /**\n   * @param {TransactionId} transactionId\n   * @returns {this}\n   * @throws {Error}\n   */\n  public setTransactionId(transactionId: TransactionId): this {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction is currently being built. Call a specific transaction method first.'\n      );\n    }\n    this.currentTransaction.setTransactionId(transactionId);\n    return this;\n  }\n\n  /**\n   * @param {AccountId[]} nodeAccountIds\n   * @returns {this}\n   * @throws {Error}\n   */\n  public setNodeAccountIds(nodeAccountIds: AccountId[]): this {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction is currently being built. Call a specific transaction method first.'\n      );\n    }\n    this.currentTransaction.setNodeAccountIds(nodeAccountIds);\n    return this;\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {boolean} [options.schedule]\n   * @param {string} [options.scheduleMemo]\n   * @param {string | AccountId} [options.schedulePayerAccountId]\n   * @returns {Promise<ExecuteResult>}\n   * @throws {Error}\n   */\n  public async execute(options?: {\n    schedule?: boolean;\n    scheduleMemo?: string;\n    schedulePayerAccountId?: string | AccountId;\n  }): Promise<ExecuteResult> {\n    const innerTx = this.currentTransaction;\n\n    if (!innerTx) {\n      return { success: false, error: 'No transaction to execute.' };\n    }\n\n    let transactionToExecute: Transaction = innerTx;\n    let originalTransactionIdForReporting = innerTx.transactionId?.toString();\n\n    if (options?.schedule) {\n      if (!innerTx.isFrozen() && this.kit.userAccountId) {\n        innerTx.setTransactionId(\n          TransactionId.generate(this.kit.userAccountId)\n        );\n      }\n\n      const scheduleCreateTx =\n        new ScheduleCreateTransaction().setScheduledTransaction(innerTx);\n\n      if (options.scheduleMemo) {\n        scheduleCreateTx.setScheduleMemo(options.scheduleMemo);\n      }\n\n      if (this.kit.userAccountId) {\n        scheduleCreateTx.setPayerAccountId(\n          AccountId.fromString(this.kit.userAccountId)\n        );\n      } else if (options.schedulePayerAccountId) {\n        const payerForScheduleCreate =\n          typeof options.schedulePayerAccountId === 'string'\n            ? AccountId.fromString(options.schedulePayerAccountId)\n            : options.schedulePayerAccountId;\n        scheduleCreateTx.setPayerAccountId(payerForScheduleCreate);\n      } else {\n        scheduleCreateTx.setPayerAccountId(this.kit.signer.getAccountId());\n        this.addNote(\n          `Your agent account (${this.kit.signer\n            .getAccountId()\n            .toString()}) will pay the fee to create this schedule.`\n        );\n      }\n\n      const agentOperator = await this.kit.getOperator();\n      const adminKeyList = new KeyList().setThreshold(1);\n      if (agentOperator.publicKey) {\n        adminKeyList.push(agentOperator.publicKey);\n        this.addNote(\n          `The schedule admin key allows both your agent and user (${this.kit.userAccountId}) to manage the schedule.`\n        );\n      }\n\n      if (this.kit.userAccountId) {\n        try {\n          const mirrorNode = this.kit.mirrorNode;\n          const userAccountInfo = await mirrorNode.requestAccount(\n            this.kit.userAccountId\n          );\n          if (userAccountInfo?.key?.key) {\n            adminKeyList.push(PublicKey.fromString(userAccountInfo.key.key));\n            this.addNote(\n              `The schedule admin key allows both your agent and user (${this.kit.userAccountId}) to manage the schedule.`\n            );\n          } else {\n            this.addNote(\n              `The schedule admin key is set to your agent. User (${this.kit.userAccountId}) key not found or not a single key.`\n            );\n          }\n        } catch (e) {\n          this.logger.warn(\n            `Failed to get user key for schedule admin key for ${\n              this.kit.userAccountId\n            }: ${(e as Error).message}`\n          );\n          this.addNote(\n            `The schedule admin key is set to your agent. Could not retrieve user (${this.kit.userAccountId}) key.`\n          );\n        }\n      }\n      if (Array.from(adminKeyList).length > 0) {\n        scheduleCreateTx.setAdminKey(adminKeyList);\n      } else {\n        this.addNote(\n          'No admin key could be set for the schedule (agent key missing and user key not found/retrieved).'\n        );\n      }\n\n      transactionToExecute = scheduleCreateTx;\n    }\n\n    try {\n      if (\n        !transactionToExecute.isFrozen() &&\n        !transactionToExecute.transactionId\n      ) {\n        await transactionToExecute.freezeWith(this.kit.client);\n      }\n      if (options?.schedule && transactionToExecute.transactionId) {\n        originalTransactionIdForReporting =\n          transactionToExecute.transactionId.toString();\n      }\n\n      const receipt = await this.kit.signer.signAndExecuteTransaction(\n        transactionToExecute\n      );\n      const finalTransactionId =\n        transactionToExecute.transactionId?.toString() ||\n        originalTransactionIdForReporting;\n\n      const result: ExecuteResult = {\n        success: true,\n        receipt: receipt,\n        transactionId: finalTransactionId,\n      };\n\n      if (options?.schedule && receipt.scheduleId) {\n        result.scheduleId = receipt.scheduleId.toString();\n      }\n      return result;\n    } catch (e: unknown) {\n      console.log('error is:', e);\n      const error = e as Error;\n      this.logger.error(\n        `Transaction execution failed: ${error.message}`,\n        error\n      );\n      const errorResult: ExecuteResult = {\n        success: false,\n        error:\n          error.message ||\n          'An unknown error occurred during transaction execution.',\n        transactionId: originalTransactionIdForReporting,\n      };\n      return errorResult;\n    }\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {boolean} [options.schedule]\n   * @param {string} [options.scheduleMemo]\n   * @param {string | AccountId} [options.schedulePayerAccountId]\n   * @param {Key} [options.scheduleAdminKey]\n   * @returns {Promise<string>}\n   * @throws {Error}\n   */\n  public async getTransactionBytes(options?: {\n    schedule?: boolean;\n    scheduleMemo?: string;\n    schedulePayerAccountId?: string | AccountId;\n    scheduleAdminKey?: Key;\n  }): Promise<string> {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction to get bytes for. Call a specific transaction method first.'\n      );\n    }\n\n    let transactionForBytes: Transaction = this.currentTransaction;\n\n    if (options?.schedule) {\n      const scheduleCreateTx =\n        new ScheduleCreateTransaction().setScheduledTransaction(\n          this.currentTransaction\n        );\n\n      if (options.scheduleMemo) {\n        scheduleCreateTx.setScheduleMemo(options.scheduleMemo);\n      }\n      if (options.schedulePayerAccountId) {\n        const payerAccountId =\n          typeof options.schedulePayerAccountId === 'string'\n            ? AccountId.fromString(options.schedulePayerAccountId)\n            : options.schedulePayerAccountId;\n        scheduleCreateTx.setPayerAccountId(payerAccountId);\n      }\n      if (options.scheduleAdminKey) {\n        scheduleCreateTx.setAdminKey(options.scheduleAdminKey);\n      }\n      transactionForBytes = scheduleCreateTx;\n    }\n\n    return Buffer.from(transactionForBytes.toBytes()).toString('base64');\n  }\n\n  /**\n   * Executes the current transaction using a provided signer.\n   * This is useful if the transaction needs to be signed and paid for by a different account\n   * than the one initially configured with the HederaAgentKit/builder instance.\n   * Note: The transaction should ideally not be frozen, or if frozen, its transactionId\n   * should be compatible with the newSigner's accountId as the payer.\n   * @param {AbstractSigner} newSigner - The signer to use for this specific execution.\n   * @returns {Promise<ExecuteResult>}\n   * @throws {Error}\n   */\n  public async executeWithSigner(\n    newSigner: AbstractSigner\n  ): Promise<ExecuteResult> {\n    if (!this.currentTransaction) {\n      return {\n        success: false,\n        error:\n          'No transaction to execute. Call a specific transaction method first.',\n      };\n    }\n\n    let transactionToExecute = this.currentTransaction;\n\n    if (transactionToExecute.isFrozen()) {\n      throw new Error(\n        'Transaction is frozen, try to call the builder method again and then executeWithSigner.'\n      );\n    }\n\n    try {\n      const receipt = await newSigner.signAndExecuteTransaction(\n        transactionToExecute\n      );\n      const transactionId = transactionToExecute.transactionId?.toString();\n      return {\n        success: true,\n        receipt: receipt,\n        transactionId: transactionId,\n      };\n    } catch (e: unknown) {\n      const error = e as Error;\n      this.logger.error(\n        `Transaction execution with new signer failed: ${error.message}`\n      );\n      return {\n        success: false,\n        error:\n          error.message ||\n          'An unknown error occurred during transaction execution with new signer.',\n      };\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  protected setCurrentTransaction(transaction: Transaction): void {\n    this.currentTransaction = transaction;\n  }\n\n  /**\n   * Retrieves the current transaction object being built.\n   * @returns {Transaction | null} The current transaction or null.\n   */\n  public getCurrentTransaction(): Transaction | null {\n    return this.currentTransaction;\n  }\n\n  public addNote(note: string): void {\n    this.notes.push(note);\n  }\n\n  public getNotes(): string[] {\n    return this.notes;\n  }\n\n  public clearNotes(): void {\n    this.notes = [];\n  }\n\n  protected async parseKey(\n    keyInput?: string | PublicKey | Key | null\n  ): Promise<Key | undefined> {\n    if (keyInput === undefined || keyInput === null) {\n      return undefined;\n    }\n    if (\n      typeof keyInput === 'object' &&\n      ('_key' in keyInput ||\n        keyInput instanceof PublicKey ||\n        keyInput instanceof PrivateKey ||\n        keyInput instanceof KeyList)\n    ) {\n      return keyInput as Key;\n    }\n    if (typeof keyInput === 'string') {\n      if (keyInput.toLowerCase() === 'current_signer') {\n        if (this.kit.signer) {\n          this.logger.info(\n            `[BaseServiceBuilder.parseKey] Substituting \"current_signer\" with signer's public key.`\n          );\n          return await this.kit.signer.getPublicKey();\n        } else {\n          throw new Error(\n            '[BaseServiceBuilder.parseKey] Signer is not available to resolve \"current_signer\".'\n          );\n        }\n      }\n      try {\n        return PublicKey.fromString(keyInput);\n      } catch (e: unknown) {\n        const error = e as Error;\n        try {\n          this.logger.warn(\n            '[BaseServiceBuilder.parseKey] Attempting to parse key string as PrivateKey to derive PublicKey. This is generally not recommended for public-facing keys.',\n            { error: error.message }\n          );\n          const keyDetection = detectKeyTypeFromString(keyInput);\n          return keyDetection.privateKey;\n        } catch (e2: unknown) {\n          const error2 = e2 as Error;\n          this.logger.error(\n            `[BaseServiceBuilder.parseKey] Failed to parse key string as PublicKey or PrivateKey: ${keyInput.substring(\n              0,\n              30\n            )}...`,\n            { error: error2.message }\n          );\n          throw new Error(\n            `[BaseServiceBuilder.parseKey] Invalid key string format: ${keyInput.substring(\n              0,\n              30\n            )}...`\n          );\n        }\n      }\n    }\n    this.logger.warn(\n      `[BaseServiceBuilder.parseKey] Received an object that is not an SDK Key instance or a recognized string format: ${JSON.stringify(\n        keyInput\n      )}`\n    );\n    return undefined;\n  }\n\n  protected parseAmount(amount?: number | string | Long | BigNumber): Long {\n    if (amount === undefined) {\n      return Long.fromNumber(0);\n    }\n    if (typeof amount === 'number') {\n      return Long.fromNumber(amount);\n    }\n    if (typeof amount === 'string') {\n      return Long.fromString(amount);\n    }\n    if (amount instanceof BigNumber) {\n      return Long.fromString(amount.toString());\n    }\n    return amount;\n  }\n}\n","import {\n  TopicCreateTransaction,\n  TopicMessageSubmitTransaction,\n  TopicDeleteTransaction,\n  TopicUpdateTransaction,\n  TopicId,\n  PublicKey,\n  AccountId,\n  KeyList,\n} from '@hashgraph/sdk';\nimport { Buffer } from 'buffer';\nimport {\n  CreateTopicParams,\n  SubmitMessageParams,\n  DeleteTopicParams,\n  UpdateTopicParams,\n} from '../../types';\nimport { BaseServiceBuilder } from '../base-service-builder';\nimport { HederaAgentKit } from '../../agent/agent';\n\nconst DEFAULT_AUTORENEW_PERIOD_SECONDS = 7776000;\nconst MAX_SINGLE_MESSAGE_BYTES = 1000;\n\n/**\n * HcsBuilder facilitates the construction and execution of Hedera Consensus Service (HCS) transactions.\n * It extends BaseServiceBuilder to provide common transaction execution and byte generation methods.\n */\nexport class HcsBuilder extends BaseServiceBuilder {\n  constructor(hederaKit: HederaAgentKit) {\n    super(hederaKit);\n  }\n\n  /**\n   * @param {CreateTopicParams} params\n   * @returns {Promise<this>}\n   */\n  public async createTopic(params: CreateTopicParams): Promise<this> {\n    this.clearNotes();\n    const transaction = new TopicCreateTransaction();\n\n    if (params.memo) {\n      transaction.setTopicMemo(params.memo);\n    }\n\n    if (params.adminKey) {\n      const parsedAdminKey = await this.parseKey(params.adminKey);\n      if (parsedAdminKey) {\n        transaction.setAdminKey(parsedAdminKey);\n      }\n    }\n\n    if (params.feeScheduleKey) {\n      const parsedFeeScheduleKey = await this.parseKey(params.feeScheduleKey);\n      if (parsedFeeScheduleKey) {\n        transaction.setFeeScheduleKey(parsedFeeScheduleKey);\n      }\n    }\n\n    if (params.submitKey) {\n      const parsedSubmitKey = await this.parseKey(params.submitKey);\n      if (parsedSubmitKey) {\n        transaction.setSubmitKey(parsedSubmitKey);\n      }\n    }\n\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    } else {\n      transaction.setAutoRenewPeriod(DEFAULT_AUTORENEW_PERIOD_SECONDS);\n      this.addNote(`Default auto-renew period of ${DEFAULT_AUTORENEW_PERIOD_SECONDS} seconds applied for topic.`);\n    }\n\n    if (params.autoRenewAccountId) {\n      transaction.setAutoRenewAccountId(params.autoRenewAccountId);\n    } else {\n      this.logger.warn(\n        'MirrorNode client is not available on the signer, cannot set fee exempt keys by account ID for createTopic.'\n      );\n      this.addNote('Could not set fee exempt accounts for topic creation: MirrorNode client not available on signer.');\n    }\n\n    if (params.customFees && params.customFees.length > 0) {\n      transaction.setCustomFees(params.customFees);\n    }\n\n    if (params.exemptAccountIds && params.exemptAccountIds.length > 0) {\n      if (!this.kit.signer.mirrorNode) {\n        this.logger.warn(\n          'MirrorNode client is not available on the signer, cannot set fee exempt keys by account ID for createTopic.'\n        );\n        this.addNote('Could not attempt to set fee exempt accounts for topic creation: MirrorNode client not available on signer.');\n      } else {\n        try {\n          const publicKeys: PublicKey[] = [];\n          for (const accountIdStr of params.exemptAccountIds) {\n            const publicKey = await this.kit.signer.mirrorNode.getPublicKey(\n              accountIdStr\n            );\n            publicKeys.push(publicKey);\n          }\n          if (publicKeys.length > 0) {\n            this.logger.warn(\n              'TopicCreateTransaction does not support setFeeExemptKeys. This parameter will be ignored for topic creation.'\n            );\n          }\n        } catch (e: unknown) {\n          const error = e as Error;\n          this.logger.error(\n            `Failed to process exemptAccountIds for createTopic: ${error.message}`\n          );\n          this.addNote(`Error processing fee exempt accounts for topic creation: ${error.message}. They may not be set.`);\n        }\n      }\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Configures the builder to submit a message to an HCS topic.\n   * The transaction will be signed by the primary signer (operator).\n   * If the target topic has a specific submit key and it is different from the operator's key,\n   * the transaction may fail at the network level unless the transaction bytes are retrieved\n   * using `getTransactionBytes()` and signed externally by the required submit key(s) before submission.\n   * The `params.submitKey` (if provided in `SubmitMessageParams`) is not directly used to sign\n   * within this builder method for `TopicMessageSubmitTransaction` as the transaction type itself\n   * does not have a field for an overriding submitter's public key; authorization is based on the topic's configuration.\n   * @param {SubmitMessageParams} params - Parameters for submitting the message.\n   * @returns {this} The HcsBuilder instance for fluent chaining.\n   */\n  public submitMessageToTopic(params: SubmitMessageParams): this {\n    const topicId =\n      typeof params.topicId === 'string'\n        ? TopicId.fromString(params.topicId)\n        : params.topicId;\n    const messageContents = params.message;\n    const messageBytesLength =\n      typeof messageContents === 'string'\n        ? Buffer.from(messageContents, 'utf8').length\n        : messageContents.length;\n\n    if (messageBytesLength > MAX_SINGLE_MESSAGE_BYTES) {\n      this.logger.warn(\n        `HcsBuilder: Message size (${messageBytesLength} bytes) exceeds recommended single transaction limit (${MAX_SINGLE_MESSAGE_BYTES} bytes). The transaction will likely fail if not accepted by the network.`\n      );\n    }\n\n    let transaction = new TopicMessageSubmitTransaction()\n      .setTopicId(topicId)\n      .setMessage(messageContents);\n\n    if (params.maxChunks) {\n      transaction.setMaxChunks(params.maxChunks);\n    }\n\n    if (params.chunkSize) {\n      transaction.setChunkSize(params.chunkSize);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {DeleteTopicParams} params\n   * @returns {this}\n   * @throws {Error}\n   */\n  public deleteTopic(params: DeleteTopicParams): this {\n    if (params.topicId === undefined) {\n      throw new Error('Topic ID is required to delete a topic.');\n    }\n    const transaction = new TopicDeleteTransaction().setTopicId(params.topicId);\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Configures the builder to update an HCS topic.\n   * @param {UpdateTopicParams} params - Parameters for updating the topic.\n   * @returns {Promise<this>} The HcsBuilder instance for fluent chaining.\n   * @throws {Error} If topicId is not provided.\n   */\n  public async updateTopic(params: UpdateTopicParams): Promise<this> {\n    this.clearNotes();\n    if (!params.topicId) {\n      throw new Error('Topic ID is required to update a topic.');\n    }\n    const transaction = new TopicUpdateTransaction().setTopicId(params.topicId);\n\n    if (Object.prototype.hasOwnProperty.call(params, 'memo')) {\n      transaction.setTopicMemo(params.memo === null ? '' : params.memo!);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'adminKey')) {\n      if (params.adminKey === null) {\n        transaction.setAdminKey(new KeyList());\n      } else if (params.adminKey) {\n        const parsedAdminKey = await this.parseKey(params.adminKey);\n        if (parsedAdminKey) transaction.setAdminKey(parsedAdminKey);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'submitKey')) {\n      if (params.submitKey === null) {\n        transaction.setSubmitKey(new KeyList());\n      } else if (params.submitKey) {\n        const parsedSubmitKey = await this.parseKey(params.submitKey);\n        if (parsedSubmitKey) transaction.setSubmitKey(parsedSubmitKey);\n      }\n    }\n\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'autoRenewAccountId')) {\n      if (params.autoRenewAccountId === null) {\n        transaction.setAutoRenewAccountId(AccountId.fromString('0.0.0'));\n      } else if (params.autoRenewAccountId) {\n        transaction.setAutoRenewAccountId(\n          params.autoRenewAccountId as string | AccountId\n        );\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'exemptAccountIds')) {\n      if (\n        params.exemptAccountIds &&\n        params.exemptAccountIds.length > 0 &&\n        !this.kit.signer.mirrorNode \n      ) {\n        this.logger.warn(\n          'MirrorNode client is not available on the signer, cannot set fee exempt keys by account ID for updateTopic if account IDs are provided and not empty.'\n        );\n        this.addNote('Could not set fee exempt accounts for topic update: MirrorNode client not available on signer.');\n      } else if (params.exemptAccountIds) {\n        if (params.exemptAccountIds.length === 0) {\n          transaction.setFeeExemptKeys([]);\n        } else {\n          try {\n            const publicKeys: PublicKey[] = [];\n            for (const accountIdStr of params.exemptAccountIds) {\n              const publicKey = await this.kit.signer.mirrorNode.getPublicKey(\n                accountIdStr\n              );\n              publicKeys.push(publicKey);\n            }\n            if (publicKeys.length > 0) {\n              transaction.setFeeExemptKeys(publicKeys);\n            } else {\n              this.addNote('Fee exempt accounts were provided, but no valid public keys could be resolved for them.');\n            }\n          } catch (e: unknown) {\n            const error = e as Error;\n            this.logger.error(\n              `Failed to process exemptAccountIds for updateTopic: ${error.message}`\n            );\n            this.addNote(`Error processing fee exempt accounts for topic update: ${error.message}. They may not be set.`);\n          }\n        }\n      }\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n}\n","import {\n  AccountId,\n  CustomFee,\n  TokenCreateTransaction,\n  TokenSupplyType,\n  TokenType,\n  TokenId,\n  Long,\n  TokenMintTransaction,\n  TokenBurnTransaction,\n  TransferTransaction,\n  TokenAssociateTransaction,\n  TokenDissociateTransaction,\n  Hbar,\n  TokenWipeTransaction,\n  TokenFreezeTransaction,\n  TokenUnfreezeTransaction,\n  TokenGrantKycTransaction,\n  TokenRevokeKycTransaction,\n  TokenPauseTransaction,\n  TokenUnpauseTransaction,\n  TokenUpdateTransaction,\n  TokenDeleteTransaction,\n  TokenFeeScheduleUpdateTransaction,\n  NftId,\n  TokenAirdropTransaction,\n  TokenClaimAirdropTransaction,\n  TokenCancelAirdropTransaction,\n  TokenRejectTransaction,\n  CustomFixedFee,\n  CustomFractionalFee,\n  CustomRoyaltyFee,\n  KeyList,\n  PublicKey,\n  FeeAssessmentMethod,\n} from '@hashgraph/sdk';\n\nimport {\n  FTCreateParams,\n  NFTCreateParams,\n  MintFTParams,\n  BurnFTParams,\n  MintNFTParams,\n  BurnNFTParams,\n  TransferNFTParams,\n  AssociateTokensParams,\n  DissociateTokensParams,\n  TransferTokensParams,\n  FungibleTokenTransferSpec,\n  WipeTokenAccountParams,\n  FreezeTokenAccountParams,\n  UnfreezeTokenAccountParams,\n  GrantKycTokenParams,\n  RevokeKycTokenParams,\n  PauseTokenParams,\n  UnpauseTokenParams,\n  UpdateTokenParams,\n  DeleteTokenParams,\n  TokenFeeScheduleUpdateParams,\n  AirdropTokenParams,\n  ClaimAirdropParams,\n  CancelAirdropParams,\n  RejectAirdropParams,\n} from '../../types';\nimport { BaseServiceBuilder } from '../base-service-builder';\nimport { Buffer } from 'buffer';\nimport { HederaAgentKit } from '../../agent/agent';\nimport { CustomFeeInputData } from '../../langchain/tools/hts/create-fungible-token-tool';\nimport { AgentOperationalMode } from '../../types';\nimport { Logger } from '../../utils/logger';\n\nconst DEFAULT_AUTORENEW_PERIOD_SECONDS = 7776000;\n\nfunction generateDefaultSymbol(tokenName: string): string {\n  if (!tokenName) {\n    return 'TOKEN';\n  }\n  const symbol = tokenName\n    .replace(/[^a-zA-Z0-9]/g, '')\n    .substring(0, 5)\n    .toUpperCase();\n  if (symbol) {\n    return symbol;\n  }\n  return 'TOKEN';\n}\n\nfunction mapToSdkCustomFees(\n  fees: CustomFeeInputData[],\n  parseAmountFn: (amount?: number | string | Long | BigNumber) => Long,\n  logger: Logger,\n  kitUserAccountId?: string,\n  kitOperationalMode?: AgentOperationalMode,\n  addNoteFn?: (note: string) => void\n): CustomFee[] {\n  if (!fees || fees.length === 0) {\n    return [];\n  }\n\n  return fees.map((feeData: CustomFeeInputData) => {\n    let feeCollectorStringToParse = feeData.feeCollectorAccountId;\n\n    if (\n      !feeCollectorStringToParse &&\n      kitUserAccountId &&\n      kitOperationalMode === 'returnBytes'\n    ) {\n      feeCollectorStringToParse = kitUserAccountId;\n      if (addNoteFn) {\n        let feeTypeForNote = 'custom';\n        if (feeData.type === 'FIXED' || feeData.type === 'FIXED_FEE') {\n          feeTypeForNote = 'fixed';\n        } else if (\n          feeData.type === 'FRACTIONAL' ||\n          feeData.type === 'FRACTIONAL_FEE'\n        ) {\n          feeTypeForNote = 'fractional';\n        } else if (\n          feeData.type === 'ROYALTY' ||\n          feeData.type === 'ROYALTY_FEE'\n        ) {\n          feeTypeForNote = 'royalty';\n        }\n        addNoteFn(\n          `Fee collector for a ${feeTypeForNote} fee was defaulted to your account (${kitUserAccountId}).`\n        );\n      }\n    }\n\n    if (!feeCollectorStringToParse) {\n      throw new Error(\n        `Fee collector account ID is required for custom fee type ${feeData.type} but was not provided or defaulted.`\n      );\n    }\n\n    let feeCollectorSdkAccountId: AccountId;\n    try {\n      feeCollectorSdkAccountId = AccountId.fromString(\n        feeCollectorStringToParse\n      );\n    } catch (e) {\n      logger.error(\n        `Invalid feeCollectorAccountId: ${feeCollectorStringToParse}`,\n        e\n      );\n      throw new Error(\n        `Invalid feeCollectorAccountId: ${feeCollectorStringToParse}`\n      );\n    }\n\n    switch (feeData.type) {\n      case 'FIXED':\n      case 'FIXED_FEE': {\n        const fixedFee = new CustomFixedFee()\n          .setFeeCollectorAccountId(feeCollectorSdkAccountId)\n          .setAmount(parseAmountFn(feeData.amount));\n        if (feeData.denominatingTokenId) {\n          try {\n            fixedFee.setDenominatingTokenId(\n              TokenId.fromString(feeData.denominatingTokenId)\n            );\n          } catch (e) {\n            logger.error(\n              `Invalid denominatingTokenId for fixed fee: ${feeData.denominatingTokenId}`,\n              e\n            );\n            throw new Error(\n              `Invalid denominatingTokenId for fixed fee: ${feeData.denominatingTokenId}`\n            );\n          }\n        }\n        return fixedFee;\n      }\n      case 'FRACTIONAL':\n      case 'FRACTIONAL_FEE': {\n        const fractionalFee = new CustomFractionalFee()\n          .setFeeCollectorAccountId(feeCollectorSdkAccountId)\n          .setNumerator(parseAmountFn(feeData.numerator).toNumber())\n          .setDenominator(parseAmountFn(feeData.denominator).toNumber());\n        if (feeData.minAmount !== undefined) {\n          fractionalFee.setMin(parseAmountFn(feeData.minAmount));\n        }\n        if (feeData.maxAmount !== undefined) {\n          fractionalFee.setMax(parseAmountFn(feeData.maxAmount));\n        }\n        const fractionalFeeData = feeData as Extract<\n          CustomFeeInputData,\n          { type: 'FRACTIONAL' | 'FRACTIONAL_FEE' }\n        >;\n        if (fractionalFeeData.assessmentMethodInclusive !== undefined) {\n          if (fractionalFeeData.assessmentMethodInclusive) {\n            fractionalFee.setAssessmentMethod(FeeAssessmentMethod.Inclusive);\n          } else {\n            fractionalFee.setAssessmentMethod(FeeAssessmentMethod.Exclusive);\n          }\n        }\n        return fractionalFee;\n      }\n      case 'ROYALTY':\n      case 'ROYALTY_FEE': {\n        const royaltyFee = new CustomRoyaltyFee()\n          .setFeeCollectorAccountId(feeCollectorSdkAccountId)\n          .setNumerator(parseAmountFn(feeData.numerator).toNumber())\n          .setDenominator(parseAmountFn(feeData.denominator).toNumber());\n        const royaltyFeeData = feeData as Extract<\n          CustomFeeInputData,\n          { type: 'ROYALTY' | 'ROYALTY_FEE' }\n        >;\n        if (royaltyFeeData.fallbackFee) {\n          let fallbackFeeCollectorStringToParse =\n            royaltyFeeData.fallbackFee.feeCollectorAccountId;\n          if (\n            !fallbackFeeCollectorStringToParse &&\n            kitUserAccountId &&\n            kitOperationalMode === 'returnBytes'\n          ) {\n            fallbackFeeCollectorStringToParse = kitUserAccountId;\n            if (addNoteFn) {\n              addNoteFn(\n                `Fallback fee collector for a royalty fee was also defaulted to your account (${kitUserAccountId}).`\n              );\n            }\n          }\n          if (!fallbackFeeCollectorStringToParse) {\n            throw new Error(\n              `Fallback fee collector account ID is required for royalty fee but was not provided or defaulted.`\n            );\n          }\n          let fallbackFeeCollectorSdkAccountId: AccountId;\n          try {\n            fallbackFeeCollectorSdkAccountId = AccountId.fromString(\n              fallbackFeeCollectorStringToParse\n            );\n          } catch (e) {\n            logger.error(\n              `Invalid feeCollectorAccountId in fallbackFee: ${fallbackFeeCollectorStringToParse}`,\n              e\n            );\n            throw new Error(\n              `Invalid feeCollectorAccountId in fallbackFee: ${fallbackFeeCollectorStringToParse}`\n            );\n          }\n          const fallback = new CustomFixedFee()\n            .setFeeCollectorAccountId(fallbackFeeCollectorSdkAccountId)\n            .setAmount(parseAmountFn(royaltyFeeData.fallbackFee.amount));\n          if (royaltyFeeData.fallbackFee.denominatingTokenId) {\n            try {\n              fallback.setDenominatingTokenId(\n                TokenId.fromString(\n                  royaltyFeeData.fallbackFee.denominatingTokenId\n                )\n              );\n            } catch (e) {\n              logger.error(\n                `Invalid denominatingTokenId in fallbackFee: ${royaltyFeeData.fallbackFee.denominatingTokenId}`,\n                e\n              );\n              throw new Error(\n                `Invalid denominatingTokenId in fallbackFee: ${royaltyFeeData.fallbackFee.denominatingTokenId}`\n              );\n            }\n          }\n          royaltyFee.setFallbackFee(fallback);\n        }\n        return royaltyFee;\n      }\n      default: {\n        const exhaustiveCheck: never = feeData;\n        logger.warn(\n          `Unsupported custom fee type encountered: ${\n            (exhaustiveCheck as unknown as { type?: string }).type\n          }`\n        );\n        throw new Error(\n          `Unsupported custom fee type: ${\n            (exhaustiveCheck as unknown as { type?: string }).type\n          }`\n        );\n      }\n    }\n  });\n}\n\n/**\n * HtsBuilder facilitates the construction and execution of Hedera Token Service (HTS) transactions.\n */\nexport class HtsBuilder extends BaseServiceBuilder {\n  constructor(hederaKit: HederaAgentKit) {\n    super(hederaKit);\n  }\n\n  /**\n   * @param {FTCreateParams} params\n   * @returns {Promise<this>}\n   * @throws {Error}\n   */\n  public async createFungibleToken(params: FTCreateParams): Promise<this> {\n    this.clearNotes();\n    let treasuryAccId = params.treasuryAccountId;\n    if (\n      !treasuryAccId &&\n      this.kit.userAccountId &&\n      this.kit.operationalMode === 'returnBytes'\n    ) {\n      this.logger.info(\n        `[HtsBuilder.createFungibleToken] Using userAccountId ${this.kit.userAccountId} as treasury for FT creation in returnBytes mode.`\n      );\n      treasuryAccId = AccountId.fromString(this.kit.userAccountId);\n      this.addNote(\n        `Since no treasury was specified, your account (${this.kit.userAccountId}) has been set as the token's treasury.`\n      );\n    }\n    if (!treasuryAccId) {\n      throw new Error(\n        '[HtsBuilder.createFungibleToken] Treasury Account ID is required (e.g., explicitly, via userAccountId for returnBytes mode, or via agent operator for autonomous if applicable).'\n      );\n    }\n\n    let tokenSymbolToUse = params.tokenSymbol;\n    if (!tokenSymbolToUse) {\n      tokenSymbolToUse = generateDefaultSymbol(params.tokenName);\n      this.addNote(\n        `We've generated a token symbol '${tokenSymbolToUse}' for you, based on the token name '${params.tokenName}'.`\n      );\n    }\n\n    let sdkSupplyType: TokenSupplyType;\n    if (typeof params.supplyType === 'string') {\n      const supplyTypeString: string = params.supplyType;\n      if (\n        supplyTypeString.toUpperCase() ===\n        TokenSupplyType.Finite.toString().toUpperCase()\n      ) {\n        sdkSupplyType = TokenSupplyType.Finite;\n      } else if (\n        supplyTypeString.toUpperCase() ===\n        TokenSupplyType.Infinite.toString().toUpperCase()\n      ) {\n        sdkSupplyType = TokenSupplyType.Infinite;\n      } else {\n        this.logger.warn(\n          `Invalid string for supplyType: ${supplyTypeString}. Defaulting to INFINITE.`\n        );\n        this.addNote(\n          `Invalid supplyType string '${supplyTypeString}' received, defaulted to INFINITE.`\n        );\n        sdkSupplyType = TokenSupplyType.Infinite;\n      }\n    } else {\n      sdkSupplyType = params.supplyType;\n    }\n\n    const transaction = new TokenCreateTransaction()\n      .setTokenName(params.tokenName)\n      .setTokenSymbol(tokenSymbolToUse)\n      .setTreasuryAccountId(treasuryAccId)\n      .setTokenType(TokenType.FungibleCommon)\n      .setSupplyType(sdkSupplyType)\n      .setInitialSupply(this.parseAmount(params.initialSupply))\n      .setDecimals(params.decimals);\n\n    if (sdkSupplyType === TokenSupplyType.Finite && params.maxSupply) {\n      transaction.setMaxSupply(this.parseAmount(params.maxSupply));\n    }\n    if (params.adminKey) {\n      const parsedKey = await this.parseKey(params.adminKey);\n      if (parsedKey) transaction.setAdminKey(parsedKey);\n    }\n    if (params.kycKey) {\n      const parsedKey = await this.parseKey(params.kycKey);\n      if (parsedKey) transaction.setKycKey(parsedKey);\n    }\n    if (params.freezeKey) {\n      const parsedKey = await this.parseKey(params.freezeKey);\n      if (parsedKey) transaction.setFreezeKey(parsedKey);\n    }\n    if (params.wipeKey) {\n      const parsedKey = await this.parseKey(params.wipeKey);\n      if (parsedKey) transaction.setWipeKey(parsedKey);\n    }\n    if (params.supplyKey) {\n      const parsedKey = await this.parseKey(params.supplyKey);\n      if (parsedKey) transaction.setSupplyKey(parsedKey);\n    }\n    if (params.feeScheduleKey) {\n      const parsedKey = await this.parseKey(params.feeScheduleKey);\n      if (parsedKey) transaction.setFeeScheduleKey(parsedKey);\n    }\n    if (params.pauseKey) {\n      const parsedKey = await this.parseKey(params.pauseKey);\n      if (parsedKey) transaction.setPauseKey(parsedKey);\n    }\n    if (params.memo) {\n      transaction.setTokenMemo(params.memo);\n    }\n    if (params.customFees && params.customFees.length > 0) {\n      const sdkCustomFees = mapToSdkCustomFees(\n        params.customFees as unknown as CustomFeeInputData[],\n        this.parseAmount.bind(this),\n        this.logger,\n        this.kit.userAccountId,\n        this.kit.operationalMode,\n        this.addNote.bind(this)\n      );\n      transaction.setCustomFees(sdkCustomFees);\n    }\n    if (params.autoRenewAccountId) {\n      transaction.setAutoRenewAccountId(params.autoRenewAccountId);\n    }\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    } else if (params.autoRenewAccountId) {\n      transaction.setAutoRenewPeriod(DEFAULT_AUTORENEW_PERIOD_SECONDS);\n      this.addNote(\n        `A standard auto-renew period of ${\n          DEFAULT_AUTORENEW_PERIOD_SECONDS / (24 * 60 * 60)\n        } days has been set for this token.`\n      );\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Creates a non-fungible token. If the supply key is not provided, the operator's public key will be used.\n   * @param {NFTCreateParams} params\n   * @returns {Promise<this>}\n   * @throws {Error}\n   */\n  public async createNonFungibleToken(params: NFTCreateParams): Promise<this> {\n    this.clearNotes();\n    let treasuryAccId = params.treasuryAccountId;\n    if (\n      !treasuryAccId &&\n      this.kit.userAccountId &&\n      this.kit.operationalMode === 'returnBytes'\n    ) {\n      this.logger.info(\n        `[HtsBuilder.createNonFungibleToken] Using userAccountId ${this.kit.userAccountId} as treasury for NFT creation in returnBytes mode.`\n      );\n      treasuryAccId = AccountId.fromString(this.kit.userAccountId);\n      this.addNote(\n        `Since no treasury was specified, your account (${this.kit.userAccountId}) has been set as the NFT collection's treasury.`\n      );\n    }\n    if (!treasuryAccId) {\n      throw new Error(\n        '[HtsBuilder.createNonFungibleToken] Treasury Account ID is required (e.g., explicitly, via userAccountId for returnBytes mode, or via agent operator for autonomous if applicable).'\n      );\n    }\n\n    let tokenSymbolToUse = params.tokenSymbol;\n    if (!tokenSymbolToUse) {\n      tokenSymbolToUse = generateDefaultSymbol(params.tokenName);\n      this.addNote(\n        `We've generated an NFT collection symbol '${tokenSymbolToUse}' for you, based on the collection name '${params.tokenName}'.`\n      );\n    }\n\n    let sdkSupplyType: TokenSupplyType;\n    if (typeof params.supplyType === 'string') {\n      const supplyTypeString: string = params.supplyType;\n      if (\n        supplyTypeString.toUpperCase() ===\n        TokenSupplyType.Finite.toString().toUpperCase()\n      ) {\n        sdkSupplyType = TokenSupplyType.Finite;\n      } else if (\n        supplyTypeString.toUpperCase() ===\n        TokenSupplyType.Infinite.toString().toUpperCase()\n      ) {\n        sdkSupplyType = TokenSupplyType.Infinite;\n      } else {\n        this.logger.warn(\n          `Invalid string for NFT supplyType: ${supplyTypeString}. Defaulting to FINITE as per NFT common practice.`\n        );\n        this.addNote(\n          `Invalid supplyType string '${supplyTypeString}' received for NFT, defaulted to FINITE.`\n        );\n        sdkSupplyType = TokenSupplyType.Finite;\n      }\n    } else {\n      sdkSupplyType = params.supplyType;\n    }\n\n    const transaction = new TokenCreateTransaction()\n      .setTokenName(params.tokenName)\n      .setTokenSymbol(tokenSymbolToUse)\n      .setTreasuryAccountId(treasuryAccId)\n      .setTokenType(TokenType.NonFungibleUnique)\n      .setSupplyType(sdkSupplyType)\n      .setInitialSupply(0)\n      .setDecimals(0);\n\n    if (sdkSupplyType === TokenSupplyType.Finite && params.maxSupply) {\n      transaction.setMaxSupply(this.parseAmount(params.maxSupply));\n    } else if (sdkSupplyType === TokenSupplyType.Finite && !params.maxSupply) {\n      this.logger.warn(\n        'NFT supplyType is FINITE but no maxSupply was provided. This might lead to an unmintable token or undesired SDK default. Consider prompting user for maxSupply or setting a builder default.'\n      );\n      this.addNote(\n        'For this FINITE NFT collection, a specific maximum supply was not provided. The Hedera network might apply its own default or limit minting.'\n      );\n    }\n    if (params.adminKey) {\n      const parsedKey = await this.parseKey(params.adminKey);\n      if (parsedKey) transaction.setAdminKey(parsedKey);\n    }\n    if (params.kycKey) {\n      const parsedKey = await this.parseKey(params.kycKey);\n      if (parsedKey) transaction.setKycKey(parsedKey);\n    }\n    if (params.freezeKey) {\n      const parsedKey = await this.parseKey(params.freezeKey);\n      if (parsedKey) transaction.setFreezeKey(parsedKey);\n    }\n    if (params.wipeKey) {\n      const parsedKey = await this.parseKey(params.wipeKey);\n      if (parsedKey) {\n        transaction.setWipeKey(parsedKey);\n      }\n    }\n\n    if (params.supplyKey) {\n      const parsedKey = await this.parseKey(params.supplyKey);\n      if (parsedKey) {\n        transaction.setSupplyKey(parsedKey);\n      }\n    } else {\n      const operator = await this.kit.query().getAccountInfo(treasuryAccId);\n      const key = operator?.key?.key;\n      if (key) {\n        transaction.setSupplyKey(PublicKey.fromString(key));\n      }\n    }\n\n    if (params.feeScheduleKey) {\n      const parsedKey = await this.parseKey(params.feeScheduleKey);\n      if (parsedKey) {\n        transaction.setFeeScheduleKey(parsedKey);\n      }\n    }\n    if (params.pauseKey) {\n      const parsedKey = await this.parseKey(params.pauseKey);\n      if (parsedKey) {\n        transaction.setPauseKey(parsedKey);\n      }\n    }\n    if (params.memo) {\n      transaction.setTokenMemo(params.memo);\n    }\n    if (params.customFees && params.customFees.length > 0) {\n      const sdkCustomFees = mapToSdkCustomFees(\n        params.customFees as unknown as CustomFeeInputData[],\n        this.parseAmount.bind(this),\n        this.logger,\n        this.kit.userAccountId,\n        this.kit.operationalMode,\n        this.addNote.bind(this)\n      );\n      transaction.setCustomFees(sdkCustomFees);\n    }\n    if (params.autoRenewAccountId) {\n      transaction.setAutoRenewAccountId(params.autoRenewAccountId);\n    }\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    } else if (params.autoRenewAccountId) {\n      transaction.setAutoRenewPeriod(DEFAULT_AUTORENEW_PERIOD_SECONDS);\n      this.addNote(\n        `A standard auto-renew period of ${\n          DEFAULT_AUTORENEW_PERIOD_SECONDS / (24 * 60 * 60)\n        } days has been set for this NFT collection.`\n      );\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {MintFTParams} params\n   * @returns {this}\n   */\n  public mintFungibleToken(params: MintFTParams): this {\n    const transaction = new TokenMintTransaction()\n      .setTokenId(params.tokenId)\n      .setAmount(this.parseAmount(params.amount));\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {BurnFTParams} params\n   * @returns {this}\n   */\n  public burnFungibleToken(params: BurnFTParams): this {\n    const transaction = new TokenBurnTransaction()\n      .setTokenId(params.tokenId)\n      .setAmount(this.parseAmount(params.amount));\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {MintNFTParams} params\n   * @returns {this}\n   * @throws {Error}\n   */\n  public mintNonFungibleToken(params: MintNFTParams): this {\n    const metadata = params.metadata.map((m) => {\n      return Buffer.from(m, 'utf8');\n    })\n\n    const transaction = new TokenMintTransaction()\n      .setTokenId(params.tokenId)\n      .setMetadata(metadata);\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {BurnNFTParams} params\n   * @returns {this}\n   */\n  public burnNonFungibleToken(params: BurnNFTParams): this {\n    if (!params.serials || params.serials.length === 0) {\n      throw new Error('Serial numbers are required to burn NFTs.');\n    }\n    const serialsAsLong = params.serials.map((s) => this.parseAmount(s));\n    const transaction = new TokenBurnTransaction()\n      .setTokenId(params.tokenId)\n      .setSerials(serialsAsLong);\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {TransferNFTParams} params - Parameters for transferring a single NFT.\n   * @returns {this}\n   */\n  public transferNft(params: TransferNFTParams): this {\n\n    const serialNum =\n      typeof params.serial === 'string'\n        ? Long.fromString(params.serial)\n        : params.serial;\n\n    const nftId = new NftId(TokenId.fromString(params.tokenId), serialNum);\n\n    let transaction: TransferTransaction = new TransferTransaction();\n\n    if (!params.isApproved) {\n      transaction = transaction.addNftTransfer(\n        nftId,\n        params.senderAccountId,\n        params.receiverAccountId\n      );\n    } else {\n      transaction = transaction.addApprovedNftTransfer(\n        nftId,\n        params.senderAccountId,\n        params.receiverAccountId\n      );\n    }\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {AssociateTokensParams} params\n   * @returns {this}\n   */\n  public associateTokens(params: AssociateTokensParams): this {\n    const transaction = new TokenAssociateTransaction()\n      .setAccountId(params.accountId)\n      .setTokenIds(\n        params.tokenIds.map((id) =>\n          typeof id === 'string' ? TokenId.fromString(id) : id\n        )\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {DissociateTokensParams} params\n   * @returns {this}\n   */\n  public dissociateTokens(params: DissociateTokensParams): this {\n    const transaction = new TokenDissociateTransaction()\n      .setAccountId(params.accountId)\n      .setTokenIds(\n        params.tokenIds.map((id) =>\n          typeof id === 'string' ? TokenId.fromString(id) : id\n        )\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {TransferTokensParams} params - Parameters for transferring fungible tokens, NFTs, and/or HBAR.\n   * @returns {this}\n   */\n  public transferTokens(params: TransferTokensParams): this {\n    const transaction = new TransferTransaction();\n\n    if (params.tokenTransfers && params.tokenTransfers.length > 0) {\n      for (const transferInput of params.tokenTransfers) {\n        if (transferInput.type === 'fungible') {\n          const fungibleTransfer = transferInput as FungibleTokenTransferSpec;\n          transaction.addTokenTransfer(\n            typeof fungibleTransfer.tokenId === 'string'\n              ? TokenId.fromString(fungibleTransfer.tokenId)\n              : fungibleTransfer.tokenId,\n            typeof fungibleTransfer.accountId === 'string'\n              ? AccountId.fromString(fungibleTransfer.accountId)\n              : fungibleTransfer.accountId,\n            this.parseAmount(fungibleTransfer.amount)\n          );\n        } else if (transferInput.type === 'nft') {\n          const toolNftInput = transferInput as unknown as {\n            tokenId: string;\n            serial: string | number | Long;\n            senderAccountId: string;\n            receiverAccountId: string;\n            isApproved?: boolean;\n          };\n\n          const sdkTokenId = TokenId.fromString(toolNftInput.tokenId);\n\n          let serialValueForLong: number | Long;\n          if (typeof toolNftInput.serial === 'string') {\n            serialValueForLong = parseInt(toolNftInput.serial, 10);\n          } else {\n            serialValueForLong = toolNftInput.serial;\n          }\n          const sdkSerial = Long.fromValue(serialValueForLong);\n          const sdkNftId = new NftId(sdkTokenId, sdkSerial);\n\n          const senderAccountId = AccountId.fromString(\n            toolNftInput.senderAccountId\n          );\n          const receiverAccountId = AccountId.fromString(\n            toolNftInput.receiverAccountId\n          );\n\n          if (toolNftInput.isApproved) {\n            transaction.addApprovedNftTransfer(\n              sdkNftId,\n              senderAccountId,\n              receiverAccountId\n            );\n          } else {\n            transaction.addNftTransfer(\n              sdkNftId,\n              senderAccountId,\n              receiverAccountId\n            );\n          }\n        }\n      }\n    }\n\n    if (params.hbarTransfers && params.hbarTransfers.length > 0) {\n      for (const hbarInput of params.hbarTransfers) {\n        const sdkHbarAmount = Hbar.fromString(hbarInput.amount.toString());\n        transaction.addHbarTransfer(\n          typeof hbarInput.accountId === 'string'\n            ? AccountId.fromString(hbarInput.accountId)\n            : hbarInput.accountId,\n          sdkHbarAmount\n        );\n      }\n    }\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {WipeTokenAccountParams} params\n   * @returns {this}\n   * @throws {Error}\n   */\n  public wipeTokenAccount(params: WipeTokenAccountParams): this {\n    const transaction = new TokenWipeTransaction()\n      .setAccountId(params.accountId)\n      .setTokenId(\n        typeof params.tokenId === 'string'\n          ? TokenId.fromString(params.tokenId)\n          : params.tokenId\n      );\n    if (params.amount) {\n      transaction.setAmount(this.parseAmount(params.amount));\n    }\n    if (params.serials && params.serials.length > 0) {\n      transaction.setSerials(params.serials.map((s) => this.parseAmount(s)));\n    }\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {FreezeTokenAccountParams} params\n   * @returns {this}\n   */\n  public freezeTokenAccount(params: FreezeTokenAccountParams): this {\n    const transaction = new TokenFreezeTransaction()\n      .setAccountId(params.accountId)\n      .setTokenId(\n        typeof params.tokenId === 'string'\n          ? TokenId.fromString(params.tokenId)\n          : params.tokenId\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {UnfreezeTokenAccountParams} params\n   * @returns {this}\n   */\n  public unfreezeTokenAccount(params: UnfreezeTokenAccountParams): this {\n    const transaction = new TokenUnfreezeTransaction()\n      .setAccountId(params.accountId)\n      .setTokenId(\n        typeof params.tokenId === 'string'\n          ? TokenId.fromString(params.tokenId)\n          : params.tokenId\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {GrantKycTokenParams} params\n   * @returns {this}\n   */\n  public grantKycToken(params: GrantKycTokenParams): this {\n    const transaction = new TokenGrantKycTransaction()\n      .setAccountId(params.accountId)\n      .setTokenId(\n        typeof params.tokenId === 'string'\n          ? TokenId.fromString(params.tokenId)\n          : params.tokenId\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {RevokeKycTokenParams} params\n   * @returns {this}\n   */\n  public revokeKycToken(params: RevokeKycTokenParams): this {\n    const transaction = new TokenRevokeKycTransaction()\n      .setAccountId(params.accountId)\n      .setTokenId(\n        typeof params.tokenId === 'string'\n          ? TokenId.fromString(params.tokenId)\n          : params.tokenId\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {PauseTokenParams} params\n   * @returns {this}\n   */\n  public pauseToken(params: PauseTokenParams): this {\n    const transaction = new TokenPauseTransaction().setTokenId(\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId\n    );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {UnpauseTokenParams} params\n   * @returns {this}\n   */\n  public unpauseToken(params: UnpauseTokenParams): this {\n    const transaction = new TokenUnpauseTransaction().setTokenId(\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId\n    );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {UpdateTokenParams} params\n   * @returns {Promise<this>}\n   * @throws {Error}\n   */\n  public async updateToken(params: UpdateTokenParams): Promise<this> {\n    if (!params.tokenId) {\n      throw new Error('Token ID is required to update a token.');\n    }\n    this.logger.info(\n      `[HtsBuilder.updateToken] Starting update for token ID: ${params.tokenId.toString()}`\n    );\n    const transaction = new TokenUpdateTransaction().setTokenId(\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId\n    );\n\n    if (Object.prototype.hasOwnProperty.call(params, 'tokenName')) {\n      transaction.setTokenName(\n        params.tokenName === null ? '' : params.tokenName!\n      );\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'tokenSymbol')) {\n      transaction.setTokenSymbol(\n        params.tokenSymbol === null ? '' : params.tokenSymbol!\n      );\n    }\n    if (params.treasuryAccountId) {\n      transaction.setTreasuryAccountId(params.treasuryAccountId);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'adminKey')) {\n      if (params.adminKey === null) transaction.setAdminKey(new KeyList());\n      else if (params.adminKey) {\n        const pk = await this.parseKey(params.adminKey);\n        if (pk) transaction.setAdminKey(pk);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'kycKey')) {\n      if (params.kycKey === null) transaction.setKycKey(new KeyList());\n      else if (params.kycKey) {\n        const pk = await this.parseKey(params.kycKey);\n        if (pk) transaction.setKycKey(pk);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'freezeKey')) {\n      if (params.freezeKey === null) transaction.setFreezeKey(new KeyList());\n      else if (params.freezeKey) {\n        const pk = await this.parseKey(params.freezeKey);\n        if (pk) transaction.setFreezeKey(pk);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'wipeKey')) {\n      if (params.wipeKey === null) transaction.setWipeKey(new KeyList());\n      else if (params.wipeKey) {\n        const pk = await this.parseKey(params.wipeKey);\n        if (pk) transaction.setWipeKey(pk);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'supplyKey')) {\n      if (params.supplyKey === null) transaction.setSupplyKey(new KeyList());\n      else if (params.supplyKey) {\n        const pk = await this.parseKey(params.supplyKey);\n        if (pk) transaction.setSupplyKey(pk);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'feeScheduleKey')) {\n      if (params.feeScheduleKey === null)\n        transaction.setFeeScheduleKey(new KeyList());\n      else if (params.feeScheduleKey) {\n        const pk = await this.parseKey(params.feeScheduleKey);\n        if (pk) transaction.setFeeScheduleKey(pk);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(params, 'pauseKey')) {\n      if (params.pauseKey === null) transaction.setPauseKey(new KeyList());\n      else if (params.pauseKey) {\n        const pk = await this.parseKey(params.pauseKey);\n        if (pk) transaction.setPauseKey(pk);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'memo')) {\n      transaction.setTokenMemo(params.memo === null ? '' : params.memo!);\n    }\n\n    if (Object.prototype.hasOwnProperty.call(params, 'autoRenewAccountId')) {\n      const autoRenewId = params.autoRenewAccountId;\n      if (autoRenewId === null) {\n        transaction.setAutoRenewAccountId(AccountId.fromString('0.0.0'));\n      } else if (autoRenewId) {\n        transaction.setAutoRenewAccountId(autoRenewId);\n      }\n    }\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    }\n\n    this.logger.info(\n      '[HtsBuilder.updateToken] Transaction object populated. Setting current transaction.',\n      transaction\n    );\n    this.setCurrentTransaction(transaction);\n    this.logger.info(\n      '[HtsBuilder.updateToken] Current transaction set. Value:',\n      this.currentTransaction\n    );\n    return this;\n  }\n\n  /**\n   * @param {DeleteTokenParams} params\n   * @returns {this}\n   */\n  public deleteToken(params: DeleteTokenParams): this {\n    if (!params.tokenId) {\n      throw new Error('Token ID is required to delete a token.');\n    }\n    const transaction = new TokenDeleteTransaction().setTokenId(\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId\n    );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {TokenFeeScheduleUpdateParams} params\n   * @returns {this}\n   */\n  public async feeScheduleUpdate(\n    params: TokenFeeScheduleUpdateParams\n  ): Promise<this> {\n    this.clearNotes();\n    if (!params.tokenId) {\n      throw new Error('Token ID is required to update fee schedule.');\n    }\n    const sdkCustomFees = mapToSdkCustomFees(\n      params.customFees as unknown as CustomFeeInputData[],\n      this.parseAmount.bind(this),\n      this.logger,\n      this.kit.userAccountId,\n      this.kit.operationalMode,\n      this.addNote.bind(this)\n    );\n    const transaction = new TokenFeeScheduleUpdateTransaction()\n      .setTokenId(\n        typeof params.tokenId === 'string'\n          ? TokenId.fromString(params.tokenId)\n          : params.tokenId\n      )\n      .setCustomFees(sdkCustomFees);\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Configures a transaction to airdrop fungible tokens from the operator's account to multiple recipients.\n   * This method uses the `TokenAirdropTransaction`.\n   * @param {AirdropTokenParams} params - Parameters for the airdrop.\n   * @returns {this} The HtsBuilder instance for fluent chaining.\n   * @throws {Error} If no recipients are provided or if amounts are invalid.\n   */\n  public airdropToken(params: AirdropTokenParams): this {\n    if (!params.recipients || params.recipients.length === 0) {\n      throw new Error('Recipients are required for an airdrop.');\n    }\n\n    const transaction = new TokenAirdropTransaction();\n    const operatorAccountId = this.kit.signer.getAccountId();\n    const tokenId =\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId;\n    let validTransfersMade = false;\n\n    for (const recipient of params.recipients) {\n      const transferAmount = this.parseAmount(recipient.amount);\n\n      if (transferAmount.isZero() || transferAmount.isNegative()) {\n        this.logger.warn(\n          `Skipping airdrop to ${recipient.accountId.toString()} with zero or negative amount.`\n        );\n        continue;\n      }\n\n      transaction.addTokenTransfer(\n        tokenId,\n        operatorAccountId,\n        transferAmount.negate()\n      );\n      transaction.addTokenTransfer(\n        tokenId,\n        recipient.accountId,\n        transferAmount\n      );\n      validTransfersMade = true;\n    }\n\n    if (!validTransfersMade) {\n      throw new Error(\n        'No valid transfers generated for the airdrop. Check recipient amounts.'\n      );\n    }\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Configures a transaction to claim pending airdrops.\n   * The operator (signer) is the recipient of the claim.\n   * @param {ClaimAirdropParams} params - Parameters specifying which pending airdrops to claim.\n   *                                      The `pendingAirdropIds` should be valid `PendingAirdropId` instances from the SDK.\n   * @returns {this} The HtsBuilder instance for fluent chaining.\n   * @throws {Error} If no `pendingAirdropIds` are provided.\n   */\n  public claimAirdrop(params: ClaimAirdropParams): this {\n    if (!params.pendingAirdropIds || params.pendingAirdropIds.length === 0) {\n      throw new Error(\n        'pendingAirdropIds must be provided and non-empty for claimAirdrop.'\n      );\n    }\n\n    const transaction = new TokenClaimAirdropTransaction();\n\n    for (const pendingId of params.pendingAirdropIds) {\n      transaction.addPendingAirdropId(pendingId);\n    }\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Configures a transaction to cancel pending airdrops sent by the operator.\n   * @param {CancelAirdropParams} params - Parameters specifying which pending airdrops to cancel.\n   *                                       The `pendingAirdropIds` should be valid `PendingAirdropId` instances from the SDK.\n   * @returns {this} The HtsBuilder instance for fluent chaining.\n   * @throws {Error} If no `pendingAirdropIds` are provided.\n   */\n  public cancelAirdrop(params: CancelAirdropParams): this {\n    if (!params.pendingAirdropIds || params.pendingAirdropIds.length === 0) {\n      throw new Error(\n        'pendingAirdropIds must be provided and non-empty for cancelAirdrop.'\n      );\n    }\n    const transaction = new TokenCancelAirdropTransaction();\n\n    transaction.setPendingAirdropIds(params.pendingAirdropIds);\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Configures a transaction for the operator to reject future auto-associations with specified token types.\n   * @param {RejectAirdropParams} params - Parameters specifying which tokens to reject.\n   *        Note: `senderAccountId` and `serials` from `RejectAirdropParams` are currently ignored by this method\n   *        as `TokenRejectTransaction` operates on token types for the owner.\n   * @returns {this} The HtsBuilder instance for fluent chaining.\n   */\n  public rejectTokens(params: RejectAirdropParams): this {\n    const transaction = new TokenRejectTransaction().setOwnerId(\n      this.kit.signer.getAccountId()\n    );\n\n    const tokenToReject =\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId;\n    transaction.addTokenId(tokenToReject);\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n}\n","import {\n  AccountCreateTransaction,\n  AccountUpdateTransaction,\n  AccountDeleteTransaction,\n  Hbar,\n  TransferTransaction,\n  Long,\n  AccountAllowanceApproveTransaction,\n  AccountAllowanceDeleteTransaction,\n  TokenId,\n  NftId,\n  Key,\n  AccountId,\n  ScheduleId,\n  ScheduleSignTransaction,\n} from '@hashgraph/sdk';\nimport BigNumber from 'bignumber.js';\nimport {\n  CreateAccountParams,\n  HbarTransferParams,\n  UpdateAccountParams,\n  DeleteAccountParams,\n  ApproveHbarAllowanceParams,\n  ApproveTokenNftAllowanceParams,\n  ApproveFungibleTokenAllowanceParams,\n  RevokeHbarAllowanceParams,\n  RevokeFungibleTokenAllowanceParams,\n  DeleteNftSpenderAllowanceParams,\n  DeleteNftSpenderAllowanceToolParams,\n  DeleteNftSerialAllowancesParams,\n  SignScheduledTransactionParams,\n} from '../../types';\nimport { BaseServiceBuilder } from '../base-service-builder';\nimport { HederaAgentKit } from '../../agent/agent';\nimport { detectKeyTypeFromString } from '../../utils/key-type-detector';\n\nconst DEFAULT_ACCOUNT_AUTORENEW_PERIOD_SECONDS = 7776000;\n\n/**\n * AccountBuilder facilitates the construction and execution of Hedera account-related transactions.\n */\nexport class AccountBuilder extends BaseServiceBuilder {\n  constructor(hederaKit: HederaAgentKit) {\n    super(hederaKit);\n  }\n\n  /**\n   * Creates a new Hedera account.\n   * @param {CreateAccountParams} params Parameters for creating an account.\n   * @returns {this} The builder instance for chaining.\n   * @throws {Error} If required parameters are missing.\n   */\n  public createAccount(params: CreateAccountParams): this {\n    this.clearNotes();\n    const transaction = new AccountCreateTransaction();\n    let autoRenewPeriodSetByUser = false;\n\n    if (typeof params.key !== 'undefined') {\n      if (params.key === null) {\n        this.logger.warn(\n          'Received null for key in createAccount. A key or alias is typically required.'\n        );\n      } else if (typeof params.key === 'string') {\n        const keyDetection = detectKeyTypeFromString(params.key);\n        transaction.setKeyWithoutAlias(keyDetection.privateKey);\n      } else {\n        transaction.setKeyWithoutAlias(params.key as Key);\n      }\n    }\n\n    if (typeof params.initialBalance !== 'undefined') {\n      if (params.initialBalance === null) {\n        this.logger.warn('Received null for initialBalance in createAccount.');\n      } else if (typeof params.initialBalance === 'string') {\n        transaction.setInitialBalance(Hbar.fromString(params.initialBalance));\n      } else if (typeof params.initialBalance === 'number') {\n        transaction.setInitialBalance(new Hbar(params.initialBalance));\n      } else {\n        transaction.setInitialBalance(params.initialBalance);\n      }\n    }\n\n    if (typeof params.receiverSignatureRequired !== 'undefined') {\n      if (params.receiverSignatureRequired === null) {\n        this.logger.warn(\n          'Received null for receiverSignatureRequired in createAccount.'\n        );\n      } else {\n        transaction.setReceiverSignatureRequired(\n          params.receiverSignatureRequired\n        );\n      }\n    }\n\n    if (typeof params.autoRenewPeriod !== 'undefined') {\n      if (params.autoRenewPeriod === null) {\n        this.logger.warn('Received null for autoRenewPeriod in createAccount.');\n      } else if (\n        typeof params.autoRenewPeriod === 'number' ||\n        (params.autoRenewPeriod as unknown) instanceof Long\n      ) {\n        transaction.setAutoRenewPeriod(params.autoRenewPeriod as number | Long);\n        autoRenewPeriodSetByUser = true;\n      } else if (\n        typeof params.autoRenewPeriod === 'object' &&\n        typeof (params.autoRenewPeriod as unknown as { seconds?: number }).seconds === 'number'\n      ) {\n        transaction.setAutoRenewPeriod(\n          (params.autoRenewPeriod as { seconds: number }).seconds\n        );\n        autoRenewPeriodSetByUser = true;\n      } else {\n        this.logger.warn(\n          'Invalid autoRenewPeriod in createAccount, using default.'\n        );\n        transaction.setAutoRenewPeriod(\n          DEFAULT_ACCOUNT_AUTORENEW_PERIOD_SECONDS\n        );\n      }\n    } else {\n      transaction.setAutoRenewPeriod(DEFAULT_ACCOUNT_AUTORENEW_PERIOD_SECONDS);\n    }\n\n    if (!autoRenewPeriodSetByUser) {\n      this.addNote(\n        `Default auto-renew period of ${DEFAULT_ACCOUNT_AUTORENEW_PERIOD_SECONDS} seconds applied.`\n      );\n    }\n\n    if (typeof params.memo !== 'undefined') {\n      if (params.memo === null) {\n        this.logger.warn('Received null for memo in createAccount.');\n      } else {\n        transaction.setAccountMemo(params.memo);\n      }\n    }\n\n    if (typeof params.maxAutomaticTokenAssociations !== 'undefined') {\n      if (params.maxAutomaticTokenAssociations === null) {\n        this.logger.warn(\n          'Received null for maxAutomaticTokenAssociations in createAccount.'\n        );\n      } else {\n        transaction.setMaxAutomaticTokenAssociations(\n          params.maxAutomaticTokenAssociations\n        );\n      }\n    }\n\n    if (typeof params.stakedAccountId !== 'undefined') {\n      if (params.stakedAccountId === null) {\n        this.logger.warn('Received null for stakedAccountId in createAccount.');\n      } else {\n        transaction.setStakedAccountId(params.stakedAccountId);\n      }\n    }\n\n    if (typeof params.stakedNodeId !== 'undefined') {\n      if (params.stakedNodeId === null) {\n        this.logger.warn('Received null for stakedNodeId in createAccount.');\n      } else {\n        transaction.setStakedNodeId(params.stakedNodeId);\n      }\n    }\n\n    if (typeof params.declineStakingReward !== 'undefined') {\n      if (params.declineStakingReward === null) {\n        this.logger.warn(\n          'Received null for declineStakingReward in createAccount.'\n        );\n      } else {\n        transaction.setDeclineStakingReward(params.declineStakingReward);\n      }\n    }\n\n    if (typeof params.alias !== 'undefined') {\n      if (params.alias === null) {\n        this.logger.warn('Received null for alias in createAccount.');\n      } else {\n        transaction.setAlias(params.alias);\n      }\n    }\n\n    if (!params.key && !params.alias) {\n      this.logger.warn(\n        'AccountCreateTransaction: Neither key nor a usable alias (PublicKey/EvmAddress) was provided. Transaction might fail.'\n      );\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Transfers HBAR between accounts.\n   * @param {HbarTransferParams} params Parameters for the HBAR transfer.\n   * @param {boolean} [isUserInitiated=true] Whether this transfer was initiated by the user (vs. system/agent)\n   * @returns {this} The builder instance for chaining.\n   * @throws {Error} If transfers are missing or do not sum to zero.\n   */\n  public transferHbar(\n    params: HbarTransferParams,\n    isUserInitiated: boolean = true\n  ): this {\n    this.clearNotes();\n    const transaction = new TransferTransaction();\n    if (!params.transfers || params.transfers.length === 0) {\n      throw new Error('HbarTransferParams must include at least one transfer.');\n    }\n\n    let netZeroInTinybars = new BigNumber(0);\n    let userTransferProcessedForScheduling = false;\n\n    if (\n      isUserInitiated &&\n      this.kit.userAccountId &&\n      this.kit.operationalMode === 'returnBytes' &&\n      params.transfers.length === 1\n    ) {\n      const receiverTransfer = params.transfers[0];\n      const amountValue =\n        typeof receiverTransfer.amount === 'string' ||\n        typeof receiverTransfer.amount === 'number'\n          ? receiverTransfer.amount\n          : receiverTransfer.amount.toString();\n\n      const amountBigNum = new BigNumber(amountValue);\n\n      if (amountBigNum.isPositive()) {\n        const recipientAccountId =\n          typeof receiverTransfer.accountId === 'string'\n            ? AccountId.fromString(receiverTransfer.accountId)\n            : receiverTransfer.accountId;\n\n        const sdkHbarAmount = Hbar.fromString(amountValue.toString());\n\n        this.logger.info(\n          `[AccountBuilder.transferHbar] Configuring user-initiated scheduled transfer: ${sdkHbarAmount.toString()} from ${\n            this.kit.userAccountId\n          } to ${recipientAccountId.toString()}`\n        );\n        this.addNote(\n          `Configured HBAR transfer from your account (${\n            this.kit.userAccountId\n          }) to ${recipientAccountId.toString()} for ${sdkHbarAmount.toString()}.`\n        );\n\n        transaction.addHbarTransfer(recipientAccountId, sdkHbarAmount);\n        transaction.addHbarTransfer(\n          AccountId.fromString(this.kit.userAccountId),\n          sdkHbarAmount.negated()\n        );\n\n        userTransferProcessedForScheduling = true;\n      }\n    }\n\n    if (!userTransferProcessedForScheduling) {\n      for (const transferInput of params.transfers) {\n        const accountId =\n          typeof transferInput.accountId === 'string'\n            ? AccountId.fromString(transferInput.accountId)\n            : transferInput.accountId;\n\n        const amountValue =\n          typeof transferInput.amount === 'string' ||\n          typeof transferInput.amount === 'number'\n            ? transferInput.amount\n            : transferInput.amount.toString();\n\n        const sdkHbarAmount = Hbar.fromString(amountValue.toString());\n\n        transaction.addHbarTransfer(accountId, sdkHbarAmount);\n\n        const tinybarsContribution = sdkHbarAmount.toTinybars();\n        netZeroInTinybars = netZeroInTinybars.plus(\n          tinybarsContribution.toString()\n        );\n      }\n\n      if (!netZeroInTinybars.isZero()) {\n        throw new Error('The sum of all HBAR transfers must be zero.');\n      }\n    }\n\n    if (typeof params.memo !== 'undefined') {\n      if (params.memo === null) {\n        this.logger.warn('Received null for memo in transferHbar.');\n      } else {\n        transaction.setTransactionMemo(params.memo);\n      }\n    }\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Updates an existing Hedera account.\n   * If an optional field in `params` is `undefined`, that aspect of the account is not changed.\n   * Specific string or number values (e.g., memo: \"\", stakedAccountId: \"0.0.0\", stakedNodeId: -1)\n   * provided by the LLM (and allowed by the Zod schema in the tool) will be applied directly.\n   * @param {UpdateAccountParams} params Parameters for updating an account.\n   * @returns {this} The builder instance for chaining.\n   * @throws {Error} If accountIdToUpdate is missing or key parsing fails.\n   */\n  public updateAccount(params: UpdateAccountParams): this {\n    if (!params.accountIdToUpdate) {\n      throw new Error('accountIdToUpdate is required for updating an account.');\n    }\n    const transaction = new AccountUpdateTransaction().setAccountId(\n      params.accountIdToUpdate\n    );\n\n    if (typeof params.key !== 'undefined') {\n      if (params.key === null) {\n        this.logger.warn('Received null for key, skipping update for key.');\n      } else if (typeof params.key === 'string') {\n        try {\n          const keyDetection = detectKeyTypeFromString(params.key);\n          transaction.setKey(keyDetection.privateKey);\n        } catch (e) {\n          this.logger.error(`Failed to parse key string: ${params.key}`, e);\n          throw new Error(`Invalid key string provided: ${params.key}`);\n        }\n      } else {\n        transaction.setKey(params.key as Key);\n      }\n    }\n\n    if (typeof params.autoRenewPeriod !== 'undefined') {\n      if (params.autoRenewPeriod === null) {\n        this.logger.warn('Received null for autoRenewPeriod, skipping update.');\n      } else if (typeof params.autoRenewPeriod === 'number') {\n        transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n      } else {\n        this.logger.warn(\n          `Invalid autoRenewPeriod format: ${JSON.stringify(\n            params.autoRenewPeriod\n          )}. Skipping.`\n        );\n      }\n    }\n\n    if (typeof params.receiverSignatureRequired !== 'undefined') {\n      if (params.receiverSignatureRequired === null) {\n        this.logger.warn(\n          'Received null for receiverSignatureRequired, skipping update.'\n        );\n      } else {\n        transaction.setReceiverSignatureRequired(\n          params.receiverSignatureRequired\n        );\n      }\n    }\n\n    if (typeof params.stakedAccountId !== 'undefined') {\n      if (params.stakedAccountId === null) {\n        this.logger.warn('Received null for stakedAccountId, skipping update.');\n      } else {\n        const saId = String(params.stakedAccountId);\n        if (saId === '0.0.0' || /^\\d+\\.\\d+\\.\\d+$/.test(saId)) {\n          transaction.setStakedAccountId(saId);\n        } else {\n          this.logger.warn(\n            `Invalid stakedAccountId format: ${saId}. Skipping.`\n          );\n        }\n      }\n    }\n\n    if (typeof params.stakedNodeId !== 'undefined') {\n      if (params.stakedNodeId === null) {\n        this.logger.warn('Received null for stakedNodeId, skipping update.');\n      } else {\n        transaction.setStakedNodeId(params.stakedNodeId);\n      }\n    }\n\n    if (typeof params.declineStakingReward !== 'undefined') {\n      if (params.declineStakingReward === null) {\n        this.logger.warn(\n          'Received null for declineStakingReward, skipping update.'\n        );\n      } else {\n        transaction.setDeclineStakingReward(params.declineStakingReward);\n      }\n    }\n\n    if (typeof params.memo !== 'undefined') {\n      if (params.memo === null) {\n        this.logger.warn('Received null for memo, skipping update.');\n      } else {\n        transaction.setAccountMemo(params.memo);\n      }\n    }\n\n    if (typeof params.maxAutomaticTokenAssociations !== 'undefined') {\n      if (params.maxAutomaticTokenAssociations === null) {\n        this.logger.warn(\n          'Received null for maxAutomaticTokenAssociations, skipping update.'\n        );\n      } else if (typeof params.maxAutomaticTokenAssociations === 'number') {\n        transaction.setMaxAutomaticTokenAssociations(\n          params.maxAutomaticTokenAssociations\n        );\n      } else {\n        this.logger.warn(\n          `Invalid type for maxAutomaticTokenAssociations: ${typeof params.maxAutomaticTokenAssociations}. Skipping.`\n        );\n      }\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Deletes an existing Hedera account.\n   * @param {DeleteAccountParams} params Parameters for deleting an account.\n   * @returns {this} The builder instance for chaining.\n   * @throws {Error} If required parameters are missing.\n   */\n  public deleteAccount(params: DeleteAccountParams): this {\n    if (!params.deleteAccountId) {\n      throw new Error('deleteAccountId is required for deleting an account.');\n    }\n    if (!params.transferAccountId) {\n      throw new Error('transferAccountId is required for deleting an account.');\n    }\n\n    const transaction = new AccountDeleteTransaction()\n      .setAccountId(params.deleteAccountId)\n      .setTransferAccountId(params.transferAccountId);\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Approves an HBAR allowance for a spender.\n   * @param {ApproveHbarAllowanceParams} params Parameters for approving HBAR allowance.\n   * @returns {this} The builder instance for chaining.\n   */\n  public approveHbarAllowance(params: ApproveHbarAllowanceParams): this {\n    const transaction =\n      new AccountAllowanceApproveTransaction().approveHbarAllowance(\n        params.ownerAccountId || this.kit.signer.getAccountId(),\n        params.spenderAccountId,\n        params.amount\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Approves an NFT allowance for a spender.\n   * @param {ApproveTokenNftAllowanceParams} params Parameters for approving NFT allowance.\n   * @returns {this} The builder instance for chaining.\n   * @throws {Error} If NFT allowance parameters are invalid.\n   */\n  public approveTokenNftAllowance(\n    params: ApproveTokenNftAllowanceParams\n  ): this {\n    const transaction = new AccountAllowanceApproveTransaction();\n    const owner = params.ownerAccountId || this.kit.signer.getAccountId();\n    const tokenId =\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId;\n\n    if (params.allSerials) {\n      transaction.approveTokenNftAllowanceAllSerials(\n        tokenId,\n        owner,\n        params.spenderAccountId\n      );\n    } else if (params.serials && params.serials.length > 0) {\n      for (const serial of params.serials) {\n        let serialLong: Long;\n        if (typeof serial === 'number') {\n          serialLong = Long.fromNumber(serial);\n        } else if (serial instanceof BigNumber) {\n          serialLong = Long.fromString(serial.toString());\n        } else {\n          serialLong = serial as Long;\n        }\n        transaction.approveTokenNftAllowance(\n          new NftId(tokenId, serialLong),\n          owner,\n          params.spenderAccountId\n        );\n      }\n    } else {\n      throw new Error(\n        \"Either allSerials must be true or 'serials' (with serial numbers) must be provided for NFT allowance.\"\n      );\n    }\n\n    if (typeof params.memo !== 'undefined') {\n      if (params.memo === null) {\n        this.logger.warn('Received null for memo in approveTokenNftAllowance.');\n      } else {\n        transaction.setTransactionMemo(params.memo);\n      }\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Approves a fungible token allowance for a spender.\n   * @param {ApproveFungibleTokenAllowanceParams} params Parameters for approving fungible token allowance.\n   * @returns {this} The builder instance for chaining.\n   */\n  public approveFungibleTokenAllowance(\n    params: ApproveFungibleTokenAllowanceParams\n  ): this {\n    const tokenId =\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId;\n    let amountLong: Long;\n\n    if (typeof params.amount === 'string') {\n      amountLong = Long.fromString(params.amount);\n    } else if (typeof params.amount === 'number') {\n      amountLong = Long.fromNumber(params.amount);\n    } else if (params.amount instanceof BigNumber) {\n      amountLong = Long.fromString(params.amount.toString());\n    } else {\n      amountLong = params.amount as Long;\n    }\n\n    const transaction =\n      new AccountAllowanceApproveTransaction().approveTokenAllowance(\n        tokenId,\n        params.ownerAccountId || this.kit.signer.getAccountId(),\n        params.spenderAccountId,\n        amountLong\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Deletes NFT allowances.\n   * Note: This method is currently stubbed and non-functional due to SDK considerations.\n   * @returns {this} The builder instance.\n   * @throws {Error} Method is temporarily disabled.\n   */\n  public deleteNftSpenderAllowance(\n    params: DeleteNftSpenderAllowanceParams\n  ): this {\n    const nftId =\n      typeof params.nftId === 'string'\n        ? NftId.fromString(params.nftId)\n        : params.nftId;\n    const owner = params.ownerAccountId || this.kit.signer.getAccountId();\n\n    const transaction =\n      new AccountAllowanceDeleteTransaction().deleteAllTokenNftAllowances(\n        nftId,\n        owner\n      );\n\n    if (typeof params.memo !== 'undefined') {\n      if (params.memo === null) {\n        this.logger.warn(\n          'Received null for memo in deleteNftSpenderAllowance.'\n        );\n      } else {\n        transaction.setTransactionMemo(params.memo);\n      }\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Revokes an HBAR allowance.\n   * @param {RevokeHbarAllowanceParams} params Parameters for revoking HBAR allowance.\n   * @returns {this} The builder instance for chaining.\n   */\n  public revokeHbarAllowance(params: RevokeHbarAllowanceParams): this {\n    const transaction =\n      new AccountAllowanceApproveTransaction().approveHbarAllowance(\n        params.ownerAccountId || this.kit.signer.getAccountId(),\n        params.spenderAccountId,\n        new Hbar(0)\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Revokes a fungible token allowance.\n   * @param {RevokeFungibleTokenAllowanceParams} params Parameters for revoking fungible token allowance.\n   * @returns {this} The builder instance for chaining.\n   */\n  public revokeFungibleTokenAllowance(\n    params: RevokeFungibleTokenAllowanceParams\n  ): this {\n    const tokenId =\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId;\n    const transaction =\n      new AccountAllowanceApproveTransaction().approveTokenAllowance(\n        tokenId,\n        params.ownerAccountId || this.kit.signer.getAccountId(),\n        params.spenderAccountId,\n        0\n      );\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Deletes all allowances for a specific NFT serial (for all spenders), granted by an owner.\n   * The transaction must be signed by the owner of the NFTs.\n   * @param {DeleteNftSerialAllowancesParams} params - Parameters for the operation.\n   * @returns {this} The builder instance for chaining.\n   */\n  public deleteNftSerialAllowancesForAllSpenders(\n    params: DeleteNftSerialAllowancesParams\n  ): this {\n    let ownerAccId: AccountId;\n    if (params.ownerAccountId) {\n      if (typeof params.ownerAccountId === 'string') {\n        ownerAccId = AccountId.fromString(params.ownerAccountId);\n      } else {\n        ownerAccId = params.ownerAccountId;\n      }\n    } else {\n      ownerAccId = this.kit.signer.getAccountId();\n    }\n\n    const parts = params.nftIdString.split('.');\n    if (parts.length !== 4) {\n      throw new Error(\n        `Invalid nftIdString format: ${params.nftIdString}. Expected format like \"0.0.token.serial\".`\n      );\n    }\n    const sdkTokenId = TokenId.fromString(\n      `${parts[0]}.${parts[1]}.${parts[2]}`\n    );\n    const sdkSerial = Long.fromString(parts[3]);\n    const sdkNftId = new NftId(sdkTokenId, sdkSerial);\n\n    const transaction =\n      new AccountAllowanceDeleteTransaction().deleteAllTokenNftAllowances(\n        sdkNftId,\n        ownerAccId\n      );\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Deletes/revokes NFT allowances for specific serial numbers of a token for a specific spender.\n   * The transaction must be signed by the owner of the NFTs.\n   * @param {DeleteNftSpenderAllowanceToolParams} params - Parameters for the operation.\n   * @returns {this} The builder instance for chaining.\n   */\n  public deleteTokenNftAllowanceForSpender(\n    params: DeleteNftSpenderAllowanceToolParams\n  ): this {\n    let ownerAccIdToUse: AccountId;\n    if (params.ownerAccountId) {\n      ownerAccIdToUse =\n        typeof params.ownerAccountId === 'string'\n          ? AccountId.fromString(params.ownerAccountId)\n          : params.ownerAccountId;\n    } else {\n      ownerAccIdToUse = this.kit.signer.getAccountId();\n    }\n\n    const sdkTokenId =\n      typeof params.tokenId === 'string'\n        ? TokenId.fromString(params.tokenId)\n        : params.tokenId;\n\n    const sdkSerials: Long[] = params.serials.map(\n      (s: string | number | Long) => {\n        if (typeof s === 'string') return Long.fromString(s);\n        if (typeof s === 'number') return Long.fromNumber(s);\n        return s;\n      }\n    );\n\n    const transaction =\n      new AccountAllowanceDeleteTransaction().deleteAllTokenNftAllowances(\n        new NftId(sdkTokenId, sdkSerials[0]),\n        ownerAccIdToUse\n      );\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Prepares a ScheduleSignTransaction for a previously scheduled transaction.\n   * @param {SignScheduledTransactionParams} params Parameters for the ScheduleSign transaction.\n   * @returns {this} The builder instance for chaining.\n   */\n  public prepareSignScheduledTransaction(\n    params: SignScheduledTransactionParams\n  ): this {\n    if (!params.scheduleId) {\n      throw new Error(\n        'scheduleId is required to prepare a ScheduleSignTransaction.'\n      );\n    }\n\n    const scheduleId =\n      typeof params.scheduleId === 'string'\n        ? ScheduleId.fromString(params.scheduleId)\n        : params.scheduleId;\n\n    const transaction = new ScheduleSignTransaction().setScheduleId(scheduleId);\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n}\n","import {\n  ContractCreateTransaction,\n  ContractExecuteTransaction,\n  ContractUpdateTransaction,\n  ContractDeleteTransaction,\n  Hbar,\n  Long,\n  TransactionId,\n  ContractCallQuery,\n  ContractFunctionResult,\n} from '@hashgraph/sdk';\nimport { Buffer } from 'buffer';\nimport {\n  CreateContractParams,\n  ExecuteContractParams,\n  UpdateContractParams,\n  DeleteContractParams,\n  ContractCallQueryParams,\n} from '../../types';\nimport { BaseServiceBuilder } from '../base-service-builder';\nimport { HederaAgentKit } from '../../agent/agent';\nimport { detectKeyTypeFromString } from '../../utils/key-type-detector';\n\nconst DEFAULT_CONTRACT_AUTORENEW_PERIOD_SECONDS = 7776000;\n\n/**\n * ScsBuilder facilitates Hedera Smart Contract Service (SCS) transactions.\n */\nexport class ScsBuilder extends BaseServiceBuilder {\n  constructor(hederaKit: HederaAgentKit) {\n    super(hederaKit);\n  }\n\n  /**\n   * @param {CreateContractParams} params\n   * @returns {this}\n   * @throws {Error}\n   */\n  public createContract(params: CreateContractParams): this {\n    this.clearNotes();\n    const transaction = new ContractCreateTransaction();\n\n    if (params.bytecodeFileId) {\n      transaction.setBytecodeFileId(params.bytecodeFileId);\n    } else if (params.bytecode) {\n      if (typeof params.bytecode === 'string') {\n        transaction.setBytecode(Buffer.from(params.bytecode, 'hex'));\n      } else {\n        transaction.setBytecode(params.bytecode);\n      }\n    } else {\n      throw new Error(\n        'Either bytecodeFileId or bytecode must be provided to create a contract.'\n      );\n    }\n\n    if (params.adminKey) {\n      if (typeof params.adminKey === 'string') {\n        const keyDetection = detectKeyTypeFromString(params.adminKey);\n        transaction.setAdminKey(keyDetection.privateKey);\n      } else {\n        transaction.setAdminKey(params.adminKey);\n      }\n    }\n\n    if (typeof params.gas === 'number') {\n      transaction.setGas(params.gas);\n    } else {\n      transaction.setGas(Long.fromValue(params.gas));\n    }\n\n    if (params.initialBalance) {\n      let balance: Hbar;\n      if (typeof params.initialBalance === 'number') {\n        balance = new Hbar(params.initialBalance);\n      } else {\n        balance = Hbar.fromTinybars(\n          Long.fromString(params.initialBalance.toString())\n        );\n      }\n      transaction.setInitialBalance(balance);\n    }\n\n    if (params.constructorParameters) {\n      transaction.setConstructorParameters(params.constructorParameters);\n    }\n\n    if (params.memo) {\n      transaction.setContractMemo(params.memo);\n    }\n\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    } else {\n      transaction.setAutoRenewPeriod(DEFAULT_CONTRACT_AUTORENEW_PERIOD_SECONDS);\n      this.addNote(`Default auto-renew period of ${DEFAULT_CONTRACT_AUTORENEW_PERIOD_SECONDS} seconds applied for contract.`);\n    }\n\n    if (params.stakedAccountId) {\n      transaction.setStakedAccountId(params.stakedAccountId);\n    }\n    if (params.stakedNodeId) {\n      transaction.setStakedNodeId(params.stakedNodeId);\n    }\n    if (params.declineStakingReward) {\n      transaction.setDeclineStakingReward(params.declineStakingReward);\n    }\n    if (params.maxAutomaticTokenAssociations) {\n      transaction.setMaxAutomaticTokenAssociations(\n        params.maxAutomaticTokenAssociations\n      );\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {ExecuteContractParams} params\n   * @returns {this}\n   */\n  public executeContract(params: ExecuteContractParams): this {\n    this.clearNotes();\n    let gasValue: Long | number;\n    if (typeof params.gas === 'number') {\n      gasValue = params.gas;\n    } else {\n      gasValue = Long.fromValue(params.gas);\n    }\n\n    const transaction = new ContractExecuteTransaction()\n      .setContractId(params.contractId)\n      .setGas(gasValue)\n      .setFunction(params.functionName, params.functionParameters);\n\n    if (params.payableAmount) {\n      let hbarAmount: Hbar;\n      if (params.payableAmount instanceof Hbar) {\n        hbarAmount = params.payableAmount;\n      } else if (typeof params.payableAmount === 'number') {\n        hbarAmount = new Hbar(params.payableAmount);\n      } else {\n        hbarAmount = Hbar.fromTinybars(\n          Long.fromString(params.payableAmount.toString())\n        );\n      }\n      transaction.setPayableAmount(hbarAmount);\n    }\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {UpdateContractParams} params\n   * @returns {this}\n   * @throws {Error}\n   */\n  public updateContract(params: UpdateContractParams): this {\n    this.clearNotes();\n    if (params.contractId === undefined) {\n      throw new Error('Contract ID is required to update a contract.');\n    }\n    const transaction = new ContractUpdateTransaction().setContractId(\n      params.contractId\n    );\n\n    if (params.adminKey) {\n      if (typeof params.adminKey === 'string') {\n        const keyDetection = detectKeyTypeFromString(params.adminKey);\n        transaction.setAdminKey(keyDetection.privateKey);\n      } else {\n        transaction.setAdminKey(params.adminKey);\n      }\n    }\n    if (params.autoRenewPeriod) {\n      transaction.setAutoRenewPeriod(params.autoRenewPeriod);\n    }\n\n    if (params.memo) {\n      transaction.setContractMemo(params.memo);\n    }\n\n    if (params.stakedAccountId) {\n      transaction.setStakedAccountId(params.stakedAccountId);\n    }\n    if (params.stakedNodeId) {\n      transaction.setStakedNodeId(params.stakedNodeId);\n    }\n\n    if (params.declineStakingReward) {\n      transaction.setDeclineStakingReward(params.declineStakingReward);\n    }\n    if (params.maxAutomaticTokenAssociations) {\n      transaction.setMaxAutomaticTokenAssociations(\n        params.maxAutomaticTokenAssociations\n      );\n    }\n\n    if (params.proxyAccountId) {\n      transaction.setProxyAccountId(params.proxyAccountId);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * @param {DeleteContractParams} params\n   * @returns {this}\n   * @throws {Error}\n   */\n  public deleteContract(params: DeleteContractParams): this {\n    this.clearNotes();\n    if (params.contractId === undefined) {\n      throw new Error('Contract ID is required to delete a contract.');\n    }\n    const transaction = new ContractDeleteTransaction().setContractId(\n      params.contractId\n    );\n\n    if (params.transferAccountId) {\n      transaction.setTransferAccountId(params.transferAccountId);\n    } else if (params.transferContractId) {\n      transaction.setTransferContractId(params.transferContractId);\n    }\n\n    this.setCurrentTransaction(transaction);\n    return this;\n  }\n\n  /**\n   * Executes a local smart contract query (does not modify state, no consensus needed).\n   * @param {ContractCallQueryParams} params - Parameters for the contract query.\n   * @returns {Promise<ContractFunctionResult>} A promise that resolves to the result of the contract call.\n   * @throws {Error} If query execution fails.\n   */\n  public async callContract(\n    params: ContractCallQueryParams\n  ): Promise<ContractFunctionResult> {\n    const query = new ContractCallQuery().setContractId(params.contractId);\n\n    if (params.gas) {\n      if (typeof params.gas === 'number') {\n        query.setGas(params.gas);\n      } else {\n        query.setGas(Long.fromValue(params.gas));\n      }\n    }\n\n    if (params.functionName) {\n      if (params.functionParameters) {\n        query.setFunction(params.functionName, params.functionParameters);\n      } else {\n        query.setFunction(params.functionName);\n      }\n    }\n\n    if (params.maxQueryPayment) {\n      query.setQueryPayment(params.maxQueryPayment);\n    }\n\n    if (params.paymentTransactionId) {\n      if (typeof params.paymentTransactionId === 'string') {\n        query.setPaymentTransactionId(\n          TransactionId.fromString(params.paymentTransactionId)\n        );\n      } else {\n        query.setPaymentTransactionId(params.paymentTransactionId);\n      }\n    }\n\n    try {\n      this.logger.info(\n        `Executing ContractCallQuery for contract ${params.contractId.toString()}`\n      );\n      return await query.execute(this.kit.client);\n    } catch (error: unknown) {\n      this.logger.error(\n        `ContractCallQuery failed for contract ${params.contractId.toString()}: ${\n          error instanceof Error ? error.message : JSON.stringify(error)\n        }`\n      );\n      throw error;\n    }\n  }\n}\n","import {\n  HederaMirrorNode,\n  TopicResponse,\n  CustomFees,\n  TokenInfoResponse,\n  HCSMessage,\n  AccountResponse,\n  ScheduleInfo,\n  Transaction as HederaTransaction,\n  AccountTokenBalance,\n  NftDetail,\n  NftInfo,\n  ContractCallQueryResponse,\n  TokenAirdrop,\n  Block,\n  ContractResult,\n  ContractLog,\n  ContractAction,\n  NetworkStake,\n  NetworkSupply,\n  ContractEntity,\n  ContractState,\n  NetworkInfo,\n  NetworkFees,\n  OpcodesResponse,\n} from '../../services/mirror-node';\nimport { HederaAgentKit } from '../../agent';\nimport { TopicId, AccountId, PublicKey } from '@hashgraph/sdk';\n\n/**\n * Utility function to filter out undefined values from an object\n */\nfunction filterUndefined<T extends Record<string, unknown>>(\n  obj: T\n): Partial<T> {\n  const filtered: Partial<T> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== undefined) {\n      (filtered as Record<string, unknown>)[key] = value;\n    }\n  }\n  return filtered;\n}\n\n/**\n * Builder class for Hedera query operations.\n * Provides a fluent interface for querying the Hedera network via Mirror Node.\n */\nexport class QueryBuilder {\n  private hederaKit: HederaAgentKit;\n  private mirrorNode: HederaMirrorNode;\n\n  constructor(hederaKit: HederaAgentKit) {\n    this.hederaKit = hederaKit;\n    this.mirrorNode = hederaKit.mirrorNode;\n  }\n\n  /**\n   * Get topic information for a given topic ID\n   */\n  async getTopicInfo(topicId: string | TopicId): Promise<TopicResponse> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicInfo(topicIdString);\n  }\n\n  /**\n   * Get messages for a given topic ID\n   */\n  async getTopicMessages(topicId: string | TopicId): Promise<HCSMessage[]> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicMessages(topicIdString);\n  }\n\n  /**\n   * Get filtered topic messages with optional parameters\n   */\n  async getTopicMessagesByFilter(\n    topicId: string | TopicId,\n    options?: {\n      sequenceNumber?: string;\n      startTime?: string;\n      endTime?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<HCSMessage[] | null> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicMessagesByFilter(\n      topicIdString,\n      options\n    );\n  }\n\n  /**\n   * Get account information for a given account ID\n   */\n  async getAccountInfo(\n    accountId: string | AccountId\n  ): Promise<AccountResponse> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.requestAccount(accountIdString);\n  }\n\n  /**\n   * Get account balance in HBAR for a given account ID\n   */\n  async getAccountBalance(\n    accountId: string | AccountId\n  ): Promise<number | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountBalance(accountIdString);\n  }\n\n  /**\n   * Get account memo for a given account ID\n   */\n  async getAccountMemo(accountId: string | AccountId): Promise<string | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountMemo(accountIdString);\n  }\n\n  /**\n   * Get token information for a given token ID\n   */\n  async getTokenInfo(tokenId: string): Promise<TokenInfoResponse | null> {\n    return await this.mirrorNode.getTokenInfo(tokenId);\n  }\n\n  /**\n   * Get token balances for a given account ID\n   */\n  async getAccountTokens(\n    accountId: string | AccountId,\n    limit: number = 100\n  ): Promise<AccountTokenBalance[] | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountTokens(accountIdString, limit);\n  }\n\n  /**\n   * Get NFTs for a given account ID\n   */\n  async getAccountNfts(\n    accountId: string | AccountId,\n    tokenId?: string,\n    limit: number = 100\n  ): Promise<NftDetail[] | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountNfts(\n      accountIdString,\n      tokenId,\n      limit\n    );\n  }\n\n  /**\n   * Validate NFT ownership\n   */\n  async validateNftOwnership(\n    accountId: string | AccountId,\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftDetail | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.validateNFTOwnership(\n      accountIdString,\n      tokenId,\n      serialNumber\n    );\n  }\n\n  /**\n   * Get transaction details by ID or hash\n   */\n  async getTransaction(\n    transactionIdOrHash: string\n  ): Promise<HederaTransaction | null> {\n    return await this.mirrorNode.getTransaction(transactionIdOrHash);\n  }\n\n  /**\n   * Get transaction details by consensus timestamp\n   */\n  async getTransactionByTimestamp(\n    timestamp: string\n  ): Promise<HederaTransaction[]> {\n    return await this.mirrorNode.getTransactionByTimestamp(timestamp);\n  }\n\n  /**\n   * Get schedule information for a given schedule ID\n   */\n  async getScheduleInfo(scheduleId: string): Promise<ScheduleInfo | null> {\n    return await this.mirrorNode.getScheduleInfo(scheduleId);\n  }\n\n  /**\n   * Get scheduled transaction status\n   */\n  async getScheduledTransactionStatus(scheduleId: string): Promise<{\n    executed: boolean;\n    executedDate?: Date | undefined;\n    deleted: boolean;\n  }> {\n    return await this.mirrorNode.getScheduledTransactionStatus(scheduleId);\n  }\n\n  /**\n   * Get HBAR price for a given date\n   */\n  async getHbarPrice(date: Date): Promise<number | null> {\n    return await this.mirrorNode.getHBARPrice(date);\n  }\n\n  /**\n   * Read smart contract query (view/pure functions)\n   */\n  async readSmartContract(\n    contractIdOrAddress: string,\n    functionSelector: string,\n    payerAccountId: string | AccountId,\n    options?: {\n      estimate?: boolean;\n      block?: string;\n      value?: number;\n      gas?: number;\n      gasPrice?: number;\n    }\n  ): Promise<ContractCallQueryResponse | null> {\n    const payerIdString =\n      typeof payerAccountId === 'string'\n        ? payerAccountId\n        : payerAccountId.toString();\n    return await this.mirrorNode.readSmartContractQuery(\n      contractIdOrAddress,\n      functionSelector,\n      payerIdString,\n      options\n    );\n  }\n\n  /**\n   * Get public key for a given account ID\n   */\n  async getPublicKey(accountId: string | AccountId): Promise<PublicKey> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getPublicKey(accountIdString);\n  }\n\n  /**\n   * Get custom fees for a given topic ID\n   */\n  async getTopicFees(topicId: string | TopicId): Promise<CustomFees | null> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicFees(topicIdString);\n  }\n\n  /**\n   * Check if a user has access to a given key list\n   */\n  async checkKeyListAccess(\n    keyBytes: Buffer,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    return await this.mirrorNode.checkKeyListAccess(keyBytes, userPublicKey);\n  }\n\n  /**\n   * Get outstanding token airdrops sent by an account\n   */\n  async getOutstandingTokenAirdrops(\n    accountIdOrArgs:\n      | string\n      | AccountId\n      | {\n          accountId: string;\n          limit?: number | undefined;\n          order?: 'asc' | 'desc' | undefined;\n          receiverId?: string | undefined;\n          serialNumber?: string | undefined;\n          tokenId?: string | undefined;\n        },\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      receiverId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    let accountIdString: string;\n    let finalOptions: typeof options;\n\n    if (typeof accountIdOrArgs === 'object' && 'accountId' in accountIdOrArgs) {\n      accountIdString = accountIdOrArgs.accountId;\n      finalOptions = filterUndefined({\n        limit: accountIdOrArgs.limit,\n        order: accountIdOrArgs.order,\n        receiverId: accountIdOrArgs.receiverId,\n        serialNumber: accountIdOrArgs.serialNumber,\n        tokenId: accountIdOrArgs.tokenId,\n      }) as typeof options;\n    } else {\n      accountIdString =\n        typeof accountIdOrArgs === 'string'\n          ? accountIdOrArgs\n          : accountIdOrArgs.toString();\n      finalOptions = options;\n    }\n\n    if (!finalOptions) {\n      return await this.mirrorNode.getOutstandingTokenAirdrops(accountIdString);\n    }\n\n    const filteredOptions = filterUndefined(finalOptions);\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getOutstandingTokenAirdrops(\n      accountIdString,\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get pending token airdrops received by an account\n   */\n  async getPendingTokenAirdrops(\n    accountIdOrArgs:\n      | string\n      | AccountId\n      | {\n          accountId: string;\n          limit?: number | undefined;\n          order?: 'asc' | 'desc' | undefined;\n          senderId?: string | undefined;\n          serialNumber?: string | undefined;\n          tokenId?: string | undefined;\n        },\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      senderId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    let accountIdString: string;\n    let finalOptions: typeof options;\n\n    if (typeof accountIdOrArgs === 'object' && 'accountId' in accountIdOrArgs) {\n      accountIdString = accountIdOrArgs.accountId;\n      finalOptions = filterUndefined({\n        limit: accountIdOrArgs.limit,\n        order: accountIdOrArgs.order,\n        senderId: accountIdOrArgs.senderId,\n        serialNumber: accountIdOrArgs.serialNumber,\n        tokenId: accountIdOrArgs.tokenId,\n      }) as typeof options;\n    } else {\n      accountIdString =\n        typeof accountIdOrArgs === 'string'\n          ? accountIdOrArgs\n          : accountIdOrArgs.toString();\n      finalOptions = options;\n    }\n\n    if (!finalOptions) {\n      return await this.mirrorNode.getPendingTokenAirdrops(accountIdString);\n    }\n\n    const filteredOptions = filterUndefined(finalOptions);\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getPendingTokenAirdrops(\n      accountIdString,\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get blocks with optional filtering\n   */\n  async getBlocks(options?: {\n    blockNumber?: string | undefined;\n    timestamp?: string | undefined;\n    limit?: number | undefined;\n    order?: 'asc' | 'desc' | undefined;\n  }): Promise<Block[] | null> {\n    if (!options) {\n      return await this.mirrorNode.getBlocks();\n    }\n\n    const filteredOptions = filterUndefined(options) as {\n      blockNumber?: string;\n      timestamp?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    };\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getBlocks(\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get a specific block by number or hash\n   */\n  async getBlock(blockNumberOrHash: string): Promise<Block | null> {\n    return await this.mirrorNode.getBlock(blockNumberOrHash);\n  }\n\n  /**\n   * Get contract results with optional filtering\n   */\n  async getContractResults(options?: {\n    from?: string;\n    blockHash?: string;\n    blockNumber?: string;\n    internal?: boolean;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    transactionIndex?: number;\n  }): Promise<ContractResult[] | null> {\n    return await this.mirrorNode.getContractResults(options);\n  }\n\n  /**\n   * Get contract result by transaction ID\n   */\n  async getContractResult(\n    transactionIdOrHash: string,\n    nonce?: number\n  ): Promise<ContractResult | null> {\n    return await this.mirrorNode.getContractResult(transactionIdOrHash, nonce);\n  }\n\n  /**\n   * Get contract logs with optional filtering\n   */\n  async getContractLogs(options?: {\n    index?: string;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    topic0?: string;\n    topic1?: string;\n    topic2?: string;\n    topic3?: string;\n    transactionHash?: string;\n  }): Promise<ContractLog[] | null> {\n    return await this.mirrorNode.getContractLogs(options);\n  }\n\n  /**\n   * Get contract actions for a transaction\n   */\n  async getContractActions(\n    transactionIdOrHash: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<ContractAction[] | null> {\n    return await this.mirrorNode.getContractActions(\n      transactionIdOrHash,\n      options\n    );\n  }\n\n  /**\n   * Get NFT information by token ID and serial number\n   */\n  async getNftInfo(\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftInfo | null> {\n    return await this.mirrorNode.getNftInfo(tokenId, serialNumber);\n  }\n\n  /**\n   * Get all NFTs for a token ID\n   */\n  async getNftsByToken(\n    tokenId: string,\n    options?: {\n      accountId?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      serialNumber?: string;\n    }\n  ): Promise<NftInfo[] | null> {\n    return await this.mirrorNode.getNftsByToken(tokenId, options);\n  }\n\n  /**\n   * Get network stake information\n   */\n  async getNetworkStake(timestamp?: string): Promise<NetworkStake | null> {\n    return await this.mirrorNode.getNetworkStake(timestamp);\n  }\n\n  /**\n   * Get network supply information\n   */\n  async getNetworkSupply(timestamp?: string): Promise<NetworkSupply | null> {\n    return await this.mirrorNode.getNetworkSupply(timestamp);\n  }\n\n  /**\n   * Get contract entities from the network\n   */\n  async getContracts(options?: {\n    contractId?: string | undefined;\n    limit?: number | undefined;\n    order?: 'asc' | 'desc' | undefined;\n  }): Promise<ContractEntity[] | null> {\n    if (!options) {\n      return await this.mirrorNode.getContracts();\n    }\n\n    const filteredOptions = filterUndefined(options) as {\n      contractId?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    };\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getContracts(\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get a specific contract by ID or address\n   */\n  async getContract(\n    contractIdOrAddress: string,\n    timestamp?: string,\n    includeBytecode?: boolean\n  ): Promise<ContractEntity | null> {\n    const response = await this.mirrorNode.getContract(\n      contractIdOrAddress,\n      timestamp\n    );\n    if (!includeBytecode) {\n      delete response?.bytecode;\n    }\n    return response;\n  }\n\n  /**\n   * Get contract results by contract\n   */\n  async getContractResultsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      blockHash?: string;\n      blockNumber?: string;\n      from?: string;\n      internal?: boolean;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      transactionIndex?: number;\n    }\n  ): Promise<ContractResult[] | null> {\n    return await this.mirrorNode.getContractResultsByContract(\n      contractIdOrAddress,\n      options\n    );\n  }\n\n  /**\n   * Get contract state for a specific contract\n   */\n  async getContractState(\n    contractIdOrAddress: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      slot?: string;\n      timestamp?: string;\n    }\n  ): Promise<ContractState[] | null> {\n    return await this.mirrorNode.getContractState(contractIdOrAddress, options);\n  }\n\n  /**\n   * Get contract logs by contract\n   */\n  async getContractLogsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      topic0?: string;\n      topic1?: string;\n      topic2?: string;\n      topic3?: string;\n    }\n  ): Promise<ContractLog[] | null> {\n    return await this.mirrorNode.getContractLogsByContract(\n      contractIdOrAddress,\n      options\n    );\n  }\n\n  /**\n   * Get network information\n   */\n  async getNetworkInfo(): Promise<NetworkInfo | null> {\n    return await this.mirrorNode.getNetworkInfo();\n  }\n\n  /**\n   * Get network fees\n   */\n  async getNetworkFees(timestamp?: string): Promise<NetworkFees | null> {\n    return await this.mirrorNode.getNetworkFees(timestamp);\n  }\n\n  /**\n   * Get opcode traces for a specific transaction\n   */\n  async getOpcodeTraces(\n    transactionIdOrHash: string,\n    options?: {\n      stack?: boolean;\n      memory?: boolean;\n      storage?: boolean;\n    }\n  ): Promise<OpcodesResponse | null> {\n    return await this.mirrorNode.getOpcodeTraces(transactionIdOrHash, options);\n  }\n}\n","/**\n * Model capability profiles for response size handling\n */\nexport enum ModelCapability {\n  SMALL = 'SMALL',\n  MEDIUM = 'MEDIUM',\n  LARGE = 'LARGE',\n  UNLIMITED = 'UNLIMITED',\n}\n","import { PublicKey, Timestamp, AccountId } from '@hashgraph/sdk';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport { Logger } from '../../utils/logger';\nimport { proto } from '@hashgraph/proto';\nimport {\n  AccountResponse,\n  CustomFees,\n  HBARPrice,\n  ScheduleInfo,\n  TokenInfoResponse,\n  TopicMessagesResponse,\n  TopicResponse,\n  Transaction as HederaTransaction,\n  AccountTokenBalance,\n  AccountTokensResponse,\n  NftDetail,\n  AccountNftsResponse,\n  ContractCallQueryResponse,\n  TokenAirdrop,\n  TokenAirdropsResponse,\n  Block,\n  BlocksResponse,\n  ContractResult,\n  ContractResultsResponse,\n  ContractLog,\n  ContractLogsResponse,\n  ContractAction,\n  ContractActionsResponse,\n  ContractEntity,\n  ContractsResponse,\n  ContractState,\n  ContractStateResponse,\n  NftInfo,\n  NftsResponse,\n  NetworkInfo,\n  NetworkFees,\n  NetworkSupply,\n  NetworkStake,\n  OpcodesResponse,\n  HCSMessage,\n} from './types';\nimport { HederaNetworkType } from '../../types';\n\n/**\n * Configuration for retry attempts.\n */\nexport interface RetryConfig {\n  maxRetries?: number;\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  backoffFactor?: number;\n}\n\n/**\n * Configuration for custom mirror node providers.\n *\n * @example\n * // Using HGraph with API key in URL\n * const config = {\n *   customUrl: 'https://mainnet.hedera.api.hgraph.dev/v1/<API-KEY>',\n *   apiKey: 'your-api-key-here'\n * };\n *\n * @example\n * // Using custom provider with API key in headers\n * const config = {\n *   customUrl: 'https://custom-mirror-node.com',\n *   apiKey: 'your-api-key',\n *   headers: {\n *     'X-Custom-Header': 'value'\n *   }\n * };\n */\nexport interface MirrorNodeConfig {\n  /** Custom mirror node URL. Can include <API-KEY> placeholder for URL-based API keys. */\n  customUrl?: string;\n  /** API key for authentication. Will be used in both Authorization header and URL replacement. */\n  apiKey?: string;\n  /** Additional custom headers to include with requests. */\n  headers?: Record<string, string>;\n}\n\nexport class HederaMirrorNode {\n  private network: HederaNetworkType;\n  private baseUrl: string;\n  private logger: Logger;\n  private isServerEnvironment: boolean;\n  private apiKey?: string;\n  private customHeaders: Record<string, string>;\n\n  private maxRetries: number = 5;\n  private initialDelayMs: number = 2000;\n  private maxDelayMs: number = 30000;\n  private backoffFactor: number = 2;\n\n  constructor(\n    network: HederaNetworkType,\n    logger?: Logger,\n    config?: MirrorNodeConfig\n  ) {\n    this.network = network;\n    if (config?.apiKey) {\n      this.apiKey = config.apiKey;\n    }\n    this.customHeaders = config?.headers || {};\n    this.baseUrl = config?.customUrl || this.getMirrorNodeUrl();\n    this.logger =\n      logger ||\n      new Logger({\n        level: 'debug',\n        module: 'MirrorNode',\n      });\n    this.isServerEnvironment = typeof window === 'undefined';\n\n    if (config?.customUrl) {\n      this.logger.info(`Using custom mirror node URL: ${config.customUrl}`);\n    }\n    if (config?.apiKey) {\n      this.logger.info('Using API key for mirror node requests');\n    }\n  }\n\n  /**\n   * Configures the retry mechanism for API requests.\n   * @param config The retry configuration.\n   */\n  public configureRetry(config: RetryConfig): void {\n    this.maxRetries = config.maxRetries ?? this.maxRetries;\n    this.initialDelayMs = config.initialDelayMs ?? this.initialDelayMs;\n    this.maxDelayMs = config.maxDelayMs ?? this.maxDelayMs;\n    this.backoffFactor = config.backoffFactor ?? this.backoffFactor;\n    this.logger.info(\n      `Retry configuration updated: maxRetries=${this.maxRetries}, initialDelayMs=${this.initialDelayMs}, maxDelayMs=${this.maxDelayMs}, backoffFactor=${this.backoffFactor}`\n    );\n  }\n\n  /**\n   * Updates the mirror node configuration.\n   * @param config The new mirror node configuration.\n   */\n  public configureMirrorNode(config: MirrorNodeConfig): void {\n    if (config.customUrl) {\n      this.baseUrl = config.customUrl;\n      this.logger.info(`Updated mirror node URL: ${config.customUrl}`);\n    }\n    if (config.apiKey) {\n      this.apiKey = config.apiKey;\n      this.logger.info('Updated API key for mirror node requests');\n    }\n    if (config.headers) {\n      this.customHeaders = { ...this.customHeaders, ...config.headers };\n      this.logger.info('Updated custom headers for mirror node requests');\n    }\n  }\n\n  /**\n   * Constructs a full URL for API requests, handling custom providers with API keys in the path.\n   * @param endpoint The API endpoint (e.g., '/api/v1/accounts/0.0.123')\n   * @returns The full URL for the request\n   */\n  private constructUrl(endpoint: string): string {\n    if (this.baseUrl.includes('<API-KEY>') && this.apiKey) {\n      const baseUrlWithKey = this.baseUrl.replace('<API-KEY>', this.apiKey);\n      return endpoint.startsWith('/')\n        ? `${baseUrlWithKey}${endpoint}`\n        : `${baseUrlWithKey}/${endpoint}`;\n    }\n    return endpoint.startsWith('/')\n      ? `${this.baseUrl}${endpoint}`\n      : `${this.baseUrl}/${endpoint}`;\n  }\n\n  /**\n   * Returns the base URL for the Hedera mirror node based on the network type\n   * @returns The mirror node base URL\n   * @private\n   */\n  private getMirrorNodeUrl(): string {\n    return this.network === 'mainnet'\n      ? 'https://mainnet-public.mirrornode.hedera.com'\n      : 'https://testnet.mirrornode.hedera.com';\n  }\n\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  /**\n   * Retrieves the public key for a given account ID from the mirror node.\n   * @param accountId The ID of the account to retrieve the public key for.\n   * @returns A promise that resolves to the public key for the given account.\n   * @throws An error if the account ID is invalid or the public key cannot be retrieved.\n   */\n  async getPublicKey(accountId: string): Promise<PublicKey> {\n    this.logger.info(`Getting public key for account ${accountId}`);\n\n    const accountInfo = await this.requestAccount(accountId);\n\n    try {\n      if (!accountInfo || !accountInfo.key) {\n        throw new Error(\n          `Failed to retrieve public key for account ID: ${accountId}`\n        );\n      }\n\n      return PublicKey.fromString(accountInfo.key.key);\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error fetching public key from Mirror Node: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Retrieves the memo for a given account ID from the mirror node.\n   * @param accountId The ID of the account to retrieve the memo for.\n   * @returns A promise that resolves to the memo for the given account.\n   * @throws An error if the account ID is invalid or the memo cannot be retrieved.\n   */\n  async getAccountMemo(accountId: string): Promise<string | null> {\n    this.logger.info(`Getting account memo for account ID: ${accountId}`);\n\n    try {\n      const accountInfo = await this._requestWithRetry<AccountResponse>(\n        `/api/v1/accounts/${accountId}`\n      );\n\n      if (accountInfo?.memo) {\n        return accountInfo.memo;\n      }\n      this.logger.warn(`No memo found for account ${accountId}`);\n      return null;\n    } catch (e: any) {\n      const error = e as Error;\n      this.logger.error(\n        `Failed to get account memo for ${accountId} after retries: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves topic information for a given topic ID from the mirror node.\n   * @param topicId The ID of the topic to retrieve information for.\n   * @returns A promise that resolves to the topic information.\n   * @throws An error if the topic ID is invalid or the information cannot be retrieved.\n   */\n  async getTopicInfo(topicId: string): Promise<TopicResponse> {\n    try {\n      this.logger.debug(`Fetching topic info for ${topicId}`);\n      const data = await this._requestWithRetry<TopicResponse>(\n        `/api/v1/topics/${topicId}`\n      );\n      return data;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error retrieving topic information for ${topicId} after retries: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Retrieves custom fees for a given topic ID from the mirror node.\n   * @param topicId The ID of the topic to retrieve custom fees for.\n   * @returns A promise that resolves to the custom fees for the given topic.\n   * @throws An error if the topic ID is invalid or the custom fees cannot be retrieved.\n   */\n  async getTopicFees(topicId: string): Promise<CustomFees | null> {\n    try {\n      const topicInfo = await this.getTopicInfo(topicId);\n      return topicInfo.custom_fees;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error retrieving topic fees: ${error.message}`;\n      this.logger.error(logMessage);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves the current HBAR price from the mirror node.\n   * @param date The date to retrieve the HBAR price for.\n   * @returns A promise that resolves to the HBAR price for the given date.\n   * @throws An error if the date is invalid or the price cannot be retrieved.\n   */\n  async getHBARPrice(date: Date): Promise<number | null> {\n    try {\n      const timestamp = Timestamp.fromDate(date).toString();\n      this.logger.debug(`Fetching HBAR price for timestamp ${timestamp}`);\n\n      const response = await this._requestWithRetry<HBARPrice>(\n        `/api/v1/network/exchangerate?timestamp=${timestamp}`\n      );\n\n      const usdPrice =\n        Number(response?.current_rate?.cent_equivalent) /\n        Number(response?.current_rate?.hbar_equivalent) /\n        100;\n\n      return usdPrice;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error retrieving HBAR price: ${error.message}`;\n      this.logger.error(logMessage);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves token information for a given token ID from the mirror node.\n   * @param tokenId The ID of the token to retrieve information for.\n   * @returns A promise that resolves to the token information.\n   * @throws An error if the token ID is invalid or the information cannot be retrieved.\n   */\n  async getTokenInfo(tokenId: string): Promise<TokenInfoResponse | null> {\n    this.logger.debug(`Fetching token info for ${tokenId}`);\n    try {\n      const data = await this._requestWithRetry<TokenInfoResponse>(\n        `/api/v1/tokens/${tokenId}`\n      );\n      if (data) {\n        this.logger.trace(`Token info found for ${tokenId}:`, data);\n        return data;\n      }\n      this.logger.warn(`No token info found for ${tokenId}`);\n      return null;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error fetching token info for ${tokenId}: ${error.message}`;\n      this.logger.error(logMessage);\n\n      return null;\n    }\n  }\n  /**\n   * Retrieves messages for a given topic ID from the mirror node. Supports filtering by sequence number\n   * based on the OpenAPI specification.\n   * @param topicId The ID of the topic to retrieve messages for.\n   * @param options Optional filtering parameters.\n   * @returns A promise that resolves to the messages for the given topic.\n   */\n  async getTopicMessages(\n    topicId: string,\n    options?: {\n      sequenceNumber?: string | number;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<HCSMessage[]> {\n    this.logger.trace(\n      `Querying messages for topic ${topicId}${options ? ' with filters' : ''}`\n    );\n\n    let endpoint = `/api/v1/topics/${topicId}/messages`;\n    const params = new URLSearchParams();\n\n    if (options) {\n      if (options.sequenceNumber !== undefined) {\n        const seqNum =\n          typeof options.sequenceNumber === 'number'\n            ? options.sequenceNumber.toString()\n            : options.sequenceNumber;\n\n        if (!seqNum.match(/^(gt|gte|lt|lte|eq|ne):/)) {\n          params.append('sequencenumber', `gt:${seqNum}`);\n        } else {\n          params.append('sequencenumber', seqNum);\n        }\n      }\n\n      if (options.limit) {\n        params.append('limit', options.limit.toString());\n      }\n\n      if (options.order) {\n        params.append('order', options.order);\n      }\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    const messages: HCSMessage[] = [];\n    let nextEndpoint = endpoint;\n\n    while (nextEndpoint) {\n      try {\n        const data = await this._requestWithRetry<TopicMessagesResponse>(\n          nextEndpoint\n        );\n\n        if (data.messages && data.messages.length > 0) {\n          for (const message of data.messages) {\n            try {\n              if (!message.message) {\n                continue;\n              }\n\n              let messageContent: string;\n              try {\n                if (this.isServerEnvironment) {\n                  messageContent = Buffer.from(\n                    message.message,\n                    'base64'\n                  ).toString('utf-8');\n                } else {\n                  messageContent = new TextDecoder().decode(\n                    Uint8Array.from(atob(message.message), (c) =>\n                      c.charCodeAt(0)\n                    )\n                  );\n                }\n              } catch (error) {\n                const logMessage = `Error decoding message: ${error}`;\n                this.logger.error(logMessage);\n                continue;\n              }\n\n              let messageJson;\n              try {\n                messageJson = JSON.parse(messageContent);\n              } catch {\n                const logMessage = `Invalid JSON message content: ${messageContent}`;\n                this.logger.error(logMessage);\n                continue;\n              }\n\n              messageJson.sequence_number = message.sequence_number;\n              messages.push({\n                ...messageJson,\n                consensus_timestamp: message.consensus_timestamp,\n                sequence_number: message.sequence_number,\n                created: new Date(Number(message.consensus_timestamp) * 1000),\n              });\n            } catch (error: any) {\n              const logMessage = `Error processing message: ${error.message}`;\n              this.logger.error(logMessage);\n            }\n          }\n        }\n\n        nextEndpoint = data.links?.next || '';\n      } catch (e: any) {\n        const error = e as Error;\n        const logMessage = `Error querying topic messages for topic ${topicId} (endpoint: ${nextEndpoint}) after retries: ${error.message}`;\n        this.logger.error(logMessage);\n        throw new Error(logMessage);\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Requests account information for a given account ID from the mirror node.\n   * @param accountId The ID of the account to retrieve information for.\n   * @returns A promise that resolves to the account information.\n   * @throws An error if the account ID is invalid or the information cannot be retrieved.\n   */\n  async requestAccount(accountId: string): Promise<AccountResponse> {\n    try {\n      this.logger.debug(`Requesting account info for ${accountId}`);\n      const data = await this._requestWithRetry<AccountResponse>(\n        `/api/v1/accounts/${accountId}`\n      );\n      if (!data) {\n        throw new Error(\n          `No data received from mirror node for account: ${accountId}`\n        );\n      }\n      return data;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Failed to fetch account ${accountId} after retries: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Checks if a user has access to a given key list.\n   * @param keyBytes The key list to check access for.\n   * @param userPublicKey The public key of the user to check access for.\n   * @returns A promise that resolves to true if the user has access, false otherwise.\n   */\n  async checkKeyListAccess(\n    keyBytes: Buffer,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    try {\n      const key = proto.Key.decode(keyBytes);\n      return this.evaluateKeyAccess(key, userPublicKey);\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error decoding protobuf key: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Evaluates the access of a given key to a user's public key.\n   * @param key The key to evaluate access for.\n   * @param userPublicKey The public key of the user to evaluate access for.\n   * @returns A promise that resolves to true if the key has access, false otherwise.\n   */\n  private async evaluateKeyAccess(\n    key: proto.IKey,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    if (key.ed25519) {\n      return this.compareEd25519Key(key.ed25519, userPublicKey);\n    }\n\n    if (key.keyList) {\n      return this.evaluateKeyList(key.keyList, userPublicKey);\n    }\n\n    if (key.thresholdKey && key.thresholdKey.keys) {\n      return this.evaluateKeyList(key.thresholdKey.keys, userPublicKey);\n    }\n\n    return false;\n  }\n\n  /**\n   * Evaluates the access of a given key list to a user's public key.\n   * @param keyList The key list to evaluate access for.\n   * @param userPublicKey The public key of the user to evaluate access for.\n   * @returns A promise that resolves to true if the key list has access, false otherwise.\n   */\n  private async evaluateKeyList(\n    keyList: proto.IKeyList,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    const keys = keyList.keys || [];\n\n    for (const listKey of keys) {\n      if (!listKey) continue;\n\n      if (listKey.ed25519) {\n        if (this.compareEd25519Key(listKey.ed25519, userPublicKey)) {\n          return true;\n        }\n      } else if (listKey.keyList || listKey.thresholdKey) {\n        try {\n          const nestedKeyBytes = proto.Key.encode({\n            ...(listKey.keyList ? { keyList: listKey.keyList } : {}),\n            ...(listKey.thresholdKey\n              ? { thresholdKey: listKey.thresholdKey }\n              : {}),\n          }).finish();\n\n          const hasNestedAccess = await this.checkKeyListAccess(\n            Buffer.from(nestedKeyBytes),\n            userPublicKey\n          );\n\n          if (hasNestedAccess) {\n            return true;\n          }\n        } catch (e: any) {\n          const error = e as Error;\n          const logMessage = `Error in nested key: ${error.message}`;\n          this.logger.debug(logMessage);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Compares an Ed25519 key with a user's public key.\n   * @param keyData The Ed25519 key data to compare.\n   * @param userPublicKey The public key of the user to compare with.\n   * @returns A boolean indicating whether the key matches the user's public key.\n   */\n  private compareEd25519Key(\n    keyData: Uint8Array,\n    userPublicKey: PublicKey\n  ): boolean {\n    try {\n      const decodedKey = PublicKey.fromBytes(Buffer.from(keyData));\n      return decodedKey.toString() === userPublicKey.toString();\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error comparing Ed25519 key: ${error.message}`;\n      this.logger.debug(logMessage);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves information about a scheduled transaction\n   * @param scheduleId The ID of the scheduled transaction\n   * @returns A promise that resolves to the scheduled transaction information\n   */\n  async getScheduleInfo(scheduleId: string): Promise<ScheduleInfo | null> {\n    try {\n      this.logger.info(\n        `Getting information for scheduled transaction ${scheduleId}`\n      );\n\n      const data = await this._requestWithRetry<ScheduleInfo>(\n        `/api/v1/schedules/${scheduleId}`\n      );\n\n      if (data) {\n        return data;\n      }\n\n      this.logger.warn(\n        `No schedule info found for ${scheduleId} after retries.`\n      );\n      return null;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching schedule info for ${scheduleId} after retries: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Checks the status of a scheduled transaction\n   * @param scheduleId The schedule ID to check\n   * @returns Status of the scheduled transaction\n   */\n  public async getScheduledTransactionStatus(scheduleId: string): Promise<{\n    executed: boolean;\n    executedDate: Date | undefined;\n    deleted: boolean;\n  }> {\n    try {\n      this.logger.info(\n        `Checking status of scheduled transaction ${scheduleId}`\n      );\n\n      const scheduleInfo = await this.getScheduleInfo(scheduleId);\n\n      if (!scheduleInfo) {\n        throw new Error(`Schedule ${scheduleId} not found`);\n      }\n\n      return {\n        executed: Boolean(scheduleInfo.executed_timestamp),\n        executedDate: scheduleInfo.executed_timestamp\n          ? new Date(Number(scheduleInfo.executed_timestamp) * 1000)\n          : undefined,\n        deleted: scheduleInfo.deleted || false,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Error checking scheduled transaction status: ${error}`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves details for a given transaction ID or hash from the mirror node.\n   * @param transactionIdOrHash The ID or hash of the transaction.\n   * @returns A promise that resolves to the transaction details.\n   * @throws An error if the transaction ID/hash is invalid or details cannot be retrieved.\n   */\n  async getTransaction(\n    transactionIdOrHash: string\n  ): Promise<HederaTransaction | null> {\n    this.logger.info(\n      `Getting transaction details for ID/hash: ${transactionIdOrHash}`\n    );\n\n    try {\n      const response = await this._requestWithRetry<{\n        transactions: HederaTransaction[];\n      }>(`/api/v1/transactions/${transactionIdOrHash}`);\n\n      if (response?.transactions?.length > 0) {\n        this.logger.trace(\n          `Transaction details found for ${transactionIdOrHash}:`,\n          response.transactions[0]\n        );\n        return response.transactions[0];\n      }\n\n      this.logger.warn(\n        `No transaction details found for ${transactionIdOrHash} or unexpected response structure.`\n      );\n      return null;\n    } catch (e: any) {\n      const error = e as Error;\n      this.logger.error(\n        `Failed to get transaction details for ${transactionIdOrHash} after retries: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Private helper to make GET requests with retry logic using Axios.\n   */\n  private async _requestWithRetry<T>(\n    endpoint: string,\n    axiosConfig?: AxiosRequestConfig\n  ): Promise<T> {\n    let attempt = 0;\n    let delay = this.initialDelayMs;\n    const url = this.constructUrl(endpoint);\n\n    const config: AxiosRequestConfig = {\n      ...axiosConfig,\n      headers: {\n        ...this.customHeaders,\n        ...axiosConfig?.headers,\n      },\n    };\n\n    if (this.apiKey) {\n      config.headers = {\n        ...config.headers,\n        Authorization: `Bearer ${this.apiKey}`,\n        'X-API-Key': this.apiKey,\n      };\n    }\n\n    while (attempt < this.maxRetries) {\n      try {\n        const response = await axios.get<T>(url, config);\n        return response.data;\n      } catch (error: any) {\n        attempt++;\n        const isLastAttempt = attempt >= this.maxRetries;\n        const statusCode = error.response?.status;\n\n        if (\n          statusCode &&\n          statusCode > 404 &&\n          statusCode < 500 &&\n          statusCode !== 429\n        ) {\n          this.logger.error(\n            `Client error for ${url} (status ${statusCode}): ${error.message}. Not retrying.`\n          );\n          throw error;\n        }\n\n        if (isLastAttempt) {\n          this.logger.error(\n            `Max retries (${this.maxRetries}) reached for ${url}. Last error: ${error.message}`\n          );\n          throw error;\n        }\n\n        this.logger.warn(\n          `Attempt ${attempt}/${this.maxRetries} failed for ${url}: ${error.message}. Retrying in ${delay}ms...`\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        delay = Math.min(delay * this.backoffFactor, this.maxDelayMs);\n      }\n    }\n\n    throw new Error(\n      `Failed to fetch data from ${url} after ${this.maxRetries} attempts.`\n    );\n  }\n\n  /**\n   * Private helper to make fetch requests with retry logic.\n   */\n  private async _fetchWithRetry<T>(\n    url: string,\n    fetchOptions?: RequestInit\n  ): Promise<T> {\n    let attempt = 0;\n    let delay = this.initialDelayMs;\n\n    const headers: Record<string, string> = {\n      ...this.customHeaders,\n    };\n\n    if (fetchOptions?.headers) {\n      if (fetchOptions.headers instanceof Headers) {\n        fetchOptions.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(fetchOptions.headers)) {\n        fetchOptions.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, fetchOptions.headers);\n      }\n    }\n\n    if (this.apiKey) {\n      headers['Authorization'] = `Bearer ${this.apiKey}`;\n      headers['X-API-Key'] = this.apiKey;\n    }\n\n    const options: RequestInit = {\n      ...fetchOptions,\n      headers,\n    };\n\n    while (attempt < this.maxRetries) {\n      try {\n        const request = await fetch(url, options);\n        if (!request.ok) {\n          if (\n            request.status >= 400 &&\n            request.status < 500 &&\n            request.status !== 429\n          ) {\n            this.logger.error(\n              `Client error for ${url} (status ${request.status}): ${request.statusText}. Not retrying.`\n            );\n            throw new Error(\n              `Fetch failed with status ${request.status}: ${request.statusText} for URL: ${url}`\n            );\n          }\n          throw new Error(\n            `Fetch failed with status ${request.status}: ${request.statusText} for URL: ${url}`\n          );\n        }\n        const response = (await request.json()) as T;\n        return response;\n      } catch (error: any) {\n        attempt++;\n        if (attempt >= this.maxRetries) {\n          this.logger.error(\n            `Max retries (${this.maxRetries}) reached for ${url}. Last error: ${error.message}`\n          );\n          throw error;\n        }\n        this.logger.warn(\n          `Attempt ${attempt}/${this.maxRetries} failed for ${url}: ${error.message}. Retrying in ${delay}ms...`\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        delay = Math.min(delay * this.backoffFactor, this.maxDelayMs);\n      }\n    }\n    throw new Error(\n      `Failed to fetch data from ${url} after ${this.maxRetries} attempts.`\n    );\n  }\n\n  /**\n   * Retrieves the numerical balance (in HBAR) for a given account ID.\n   * @param accountId The ID of the account.\n   * @returns A promise that resolves to the HBAR balance or null if an error occurs.\n   */\n  async getAccountBalance(accountId: string): Promise<number | null> {\n    this.logger.info(`Getting balance for account ${accountId}`);\n    try {\n      const accountInfo = await this.requestAccount(accountId);\n      if (accountInfo && accountInfo.balance) {\n        const hbarBalance = accountInfo.balance.balance / 100_000_000;\n        return hbarBalance;\n      }\n      this.logger.warn(\n        `Could not retrieve balance for account ${accountId} from account info.`\n      );\n      return null;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching numerical balance for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves messages for a given topic ID with optional filters.\n   * @param topicId The ID of the topic.\n   * @param sequenceNumber Filter by sequence number (e.g., \"gt:10\", \"lte:20\").\n   * @param startTime Filter by consensus timestamp (e.g., \"gt:1629400000.000000000\").\n   * @param endTime Filter by consensus timestamp (e.g., \"lt:1629500000.000000000\").\n   * @param limit The maximum number of messages to return.\n   * @returns A promise that resolves to an array of HCSMessages or null.\n   */\n  async getTopicMessagesByFilter(\n    topicId: string,\n    options?: {\n      sequenceNumber?: string;\n      startTime?: string;\n      endTime?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<HCSMessage[] | null> {\n    this.logger.trace(\n      `Querying messages for topic ${topicId} with filters: ${JSON.stringify(\n        options\n      )}`\n    );\n\n    let nextUrl = `/api/v1/topics/${topicId}/messages`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.sequenceNumber) {\n      params.append('sequencenumber', options.sequenceNumber);\n    }\n    if (options?.startTime) {\n      params.append('timestamp', `gte:${options.startTime}`);\n    }\n    if (options?.endTime) {\n      params.append('timestamp', `lt:${options.endTime}`);\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      nextUrl += `?${queryString}`;\n    }\n\n    const messages: HCSMessage[] = [];\n    let pagesFetched = 0;\n    const maxPages = 10;\n\n    try {\n      while (nextUrl && pagesFetched < maxPages) {\n        pagesFetched++;\n        const data = await this._requestWithRetry<TopicMessagesResponse>(\n          nextUrl\n        );\n\n        if (data.messages && data.messages.length > 0) {\n          for (const message of data.messages) {\n            try {\n              if (!message.message) {\n                continue;\n              }\n              let messageContent: string;\n              if (this.isServerEnvironment) {\n                messageContent = Buffer.from(\n                  message.message,\n                  'base64'\n                ).toString('utf-8');\n              } else {\n                messageContent = new TextDecoder().decode(\n                  Uint8Array.from(atob(message.message), (c) => c.charCodeAt(0))\n                );\n              }\n              let messageJson = {};\n              try {\n                messageJson = JSON.parse(messageContent);\n              } catch {\n                this.logger.debug(\n                  `Message content is not valid JSON, using raw: ${messageContent}`\n                );\n                messageJson = { raw_content: messageContent };\n              }\n\n              const parsedContent = messageJson as HCSMessage;\n\n              const hcsMsg: HCSMessage = {\n                ...parsedContent,\n                consensus_timestamp: message.consensus_timestamp,\n                sequence_number: message.sequence_number,\n                payer_account_id: message.payer_account_id,\n                topic_id: message.topic_id,\n                running_hash: message.running_hash,\n                running_hash_version: message.running_hash_version,\n                chunk_info: message.chunk_info ?? {},\n                created: new Date(\n                  Number(message.consensus_timestamp.split('.')[0]) * 1000 +\n                    Number(message.consensus_timestamp.split('.')[1] || 0) /\n                      1_000_000\n                ),\n\n                payer: message.payer_account_id,\n              };\n\n              messages.push(hcsMsg);\n            } catch (error: unknown) {\n              const e = error as Error;\n              this.logger.error(\n                `Error processing individual message: ${e.message}`\n              );\n            }\n          }\n        }\n        if (options?.limit && messages.length >= options.limit) break;\n        nextUrl = data.links?.next ? `${data.links.next}` : '';\n      }\n      return messages;\n    } catch (error: unknown) {\n      const e = error as Error;\n      this.logger.error(\n        `Error querying filtered topic messages for ${topicId}: ${e.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves token balances for a given account ID.\n   * @param accountId The ID of the account.\n   * @param limit The maximum number of tokens to return.\n   * @returns A promise that resolves to an array of AccountTokenBalance or null.\n   */\n  async getAccountTokens(\n    accountId: string,\n    limit: number = 100\n  ): Promise<AccountTokenBalance[] | null> {\n    this.logger.info(`Getting tokens for account ${accountId}`);\n    let allTokens: AccountTokenBalance[] = [];\n    let endpoint = `/api/v1/accounts/${accountId}/tokens?limit=${limit}`;\n\n    try {\n      for (let i = 0; i < 10 && endpoint; i++) {\n        const response = await this._requestWithRetry<AccountTokensResponse>(\n          endpoint\n        );\n        if (response && response.tokens) {\n          allTokens = allTokens.concat(response.tokens);\n        }\n        endpoint = response.links?.next || '';\n        if (!endpoint || (limit && allTokens.length >= limit)) {\n          if (limit && allTokens.length > limit) {\n            allTokens = allTokens.slice(0, limit);\n          }\n          break;\n        }\n      }\n      return allTokens;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching tokens for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves transaction details by consensus timestamp.\n   * @param timestamp The consensus timestamp of the transaction (e.g., \"1629400000.000000000\").\n   * @returns A promise that resolves to the transaction details or null.\n   */\n  async getTransactionByTimestamp(\n    timestamp: string\n  ): Promise<HederaTransaction[]> {\n    this.logger.info(`Getting transaction by timestamp: ${timestamp}`);\n\n    try {\n      const response = await this._requestWithRetry<{\n        transactions: HederaTransaction[];\n      }>(`/api/v1/transactions?timestamp=${timestamp}&limit=1`);\n\n      return response.transactions;\n    } catch (error: unknown) {\n      this.logger.error(\n        `Error fetching transaction by timestamp ${timestamp}: ${error}`\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Retrieves NFTs for a given account ID, optionally filtered by token ID.\n   * @param accountId The ID of the account.\n   * @param tokenId Optional ID of the token to filter NFTs by.\n   * @param limit The maximum number of NFTs to return per page (API has its own max).\n   * @returns A promise that resolves to an array of NftDetail or null.\n   */\n  async getAccountNfts(\n    accountId: string,\n    tokenId?: string,\n    limit: number = 100\n  ): Promise<NftDetail[] | null> {\n    this.logger.info(\n      `Getting NFTs for account ${accountId}${\n        tokenId ? ` for token ${tokenId}` : ''\n      }`\n    );\n    let allNfts: NftDetail[] = [];\n    let endpoint = `/api/v1/accounts/${accountId}/nfts?limit=${limit}`;\n    if (tokenId) {\n      endpoint += `&token.id=${tokenId}`;\n    }\n\n    try {\n      for (let i = 0; i < 10 && endpoint; i++) {\n        const response = await this._requestWithRetry<AccountNftsResponse>(\n          endpoint\n        );\n        if (response && response.nfts) {\n          const nftsWithUri = response.nfts.map((nft: NftDetail) => {\n            let tokenUri: string | undefined = undefined;\n            if (nft.metadata) {\n              try {\n                if (this.isServerEnvironment) {\n                  tokenUri = Buffer.from(nft.metadata, 'base64').toString(\n                    'utf-8'\n                  );\n                } else {\n                  tokenUri = new TextDecoder().decode(\n                    Uint8Array.from(atob(nft.metadata), (c) => c.charCodeAt(0))\n                  );\n                }\n              } catch (e) {\n                this.logger.warn(\n                  `Failed to decode metadata for NFT ${nft.token_id} SN ${\n                    nft.serial_number\n                  }: ${(e as Error).message}`\n                );\n              }\n            }\n            return { ...nft, token_uri: tokenUri };\n          });\n          allNfts = allNfts.concat(nftsWithUri as NftDetail[]);\n        }\n        endpoint = response.links?.next || '';\n        if (!endpoint) break;\n      }\n      return allNfts;\n    } catch (error: unknown) {\n      this.logger.error(\n        `Error fetching NFTs for account ${accountId}: ${error}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Validates NFT ownership by checking if a specific serial number of a token ID exists for an account.\n   * @param accountId The ID of the account.\n   * @param tokenId The ID of the NFT's token.\n   * @param serialNumber The serial number of the NFT.\n   * @returns A promise that resolves to the NftDetail if owned, or null otherwise.\n   */\n  async validateNFTOwnership(\n    accountId: string,\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftDetail | null> {\n    this.logger.info(\n      `Validating ownership of NFT ${tokenId} SN ${serialNumber} for account ${accountId}`\n    );\n    try {\n      const nfts = await this.getAccountNfts(accountId, tokenId);\n      if (nfts) {\n        const foundNft = nfts.find(\n          (nft) =>\n            nft.token_id === tokenId && nft.serial_number === serialNumber\n        );\n        return foundNft || null;\n      }\n      return null;\n    } catch (error: any) {\n      this.logger.error(`Error validating NFT ownership: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Performs a read-only query against a smart contract (eth_call like).\n   * @param contractIdOrAddress The contract ID (e.g., \"0.0.123\") or EVM address (e.g., \"0x...\").\n   * @param functionSelector The function selector and encoded parameters (e.g., \"0xabcdef12...\").\n   * @param payerAccountId The account ID of the payer (not strictly payer for read-only, but often required as 'from').\n   * @param estimate Whether this is an estimate call. Mirror node might not support this directly in /contracts/call for true estimation.\n   * @param block Block parameter, e.g., \"latest\", \"pending\", or block number.\n   * @param value The value in tinybars to send with the call (for payable view/pure functions, usually 0).\n   * @returns A promise that resolves to the contract call query response or null.\n   */\n  async readSmartContractQuery(\n    contractIdOrAddress: string,\n    functionSelector: string,\n    payerAccountId: string,\n    options?: {\n      estimate?: boolean;\n      block?: string;\n      value?: number;\n      gas?: number;\n      gasPrice?: number;\n    }\n  ): Promise<ContractCallQueryResponse | null> {\n    this.logger.info(\n      `Reading smart contract ${contractIdOrAddress} with selector ${functionSelector}`\n    );\n\n    const toAddress = contractIdOrAddress.startsWith('0x')\n      ? contractIdOrAddress\n      : `0x${AccountId.fromString(contractIdOrAddress).toSolidityAddress()}`;\n    const fromAddress = payerAccountId.startsWith('0x')\n      ? payerAccountId\n      : `0x${AccountId.fromString(payerAccountId).toSolidityAddress()}`;\n\n    const body: any = {\n      block: options?.block || 'latest',\n      data: functionSelector,\n      estimate: options?.estimate || false,\n      from: fromAddress,\n      to: toAddress,\n      gas: options?.gas,\n      gasPrice: options?.gasPrice,\n      value: options?.value || 0,\n    };\n\n    Object.keys(body).forEach((key) => {\n      const K = key as keyof typeof body;\n      if (body[K] === undefined) {\n        delete body[K];\n      }\n    });\n\n    try {\n      const url = this.constructUrl('/api/v1/contracts/call');\n      const response = await this._fetchWithRetry<ContractCallQueryResponse>(\n        url,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        }\n      );\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error reading smart contract ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves outstanding token airdrops sent by an account.\n   * @param accountId The ID of the account that sent the airdrops.\n   * @param options Optional parameters for filtering airdrops.\n   * @returns A promise that resolves to an array of TokenAirdrop or null.\n   */\n  async getOutstandingTokenAirdrops(\n    accountId: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      receiverId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    this.logger.info(\n      `Getting outstanding token airdrops sent by account ${accountId}`\n    );\n    let endpoint = `/api/v1/accounts/${accountId}/airdrops/outstanding`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.receiverId) {\n      params.append('receiver.id', options.receiverId);\n    }\n    if (options?.serialNumber) {\n      params.append('serialnumber', options.serialNumber);\n    }\n    if (options?.tokenId) {\n      params.append('token.id', options.tokenId);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<TokenAirdropsResponse>(\n        endpoint\n      );\n      return response.airdrops || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching outstanding token airdrops for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves pending token airdrops received by an account.\n   * @param accountId The ID of the account that received the airdrops.\n   * @param options Optional parameters for filtering airdrops.\n   * @returns A promise that resolves to an array of TokenAirdrop or null.\n   */\n  async getPendingTokenAirdrops(\n    accountId: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      senderId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    this.logger.info(\n      `Getting pending token airdrops received by account ${accountId}`\n    );\n    let endpoint = `/api/v1/accounts/${accountId}/airdrops/pending`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.senderId) {\n      params.append('sender.id', options.senderId);\n    }\n    if (options?.serialNumber) {\n      params.append('serialnumber', options.serialNumber);\n    }\n    if (options?.tokenId) {\n      params.append('token.id', options.tokenId);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<TokenAirdropsResponse>(\n        endpoint\n      );\n      return response.airdrops || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching pending token airdrops for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves blocks from the network.\n   * @param options Optional parameters for filtering blocks.\n   * @returns A promise that resolves to an array of Block or null.\n   */\n  async getBlocks(options?: {\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    blockNumber?: string;\n  }): Promise<Block[] | null> {\n    this.logger.info('Getting blocks from the network');\n    let endpoint = `/api/v1/blocks`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.blockNumber) {\n      params.append('block.number', options.blockNumber);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<BlocksResponse>(endpoint);\n      return response.blocks || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching blocks: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a specific block by number or hash.\n   * @param blockNumberOrHash The block number or hash.\n   * @returns A promise that resolves to a Block or null.\n   */\n  async getBlock(blockNumberOrHash: string): Promise<Block | null> {\n    this.logger.info(`Getting block ${blockNumberOrHash}`);\n    try {\n      const response = await this._requestWithRetry<Block>(\n        `/api/v1/blocks/${blockNumberOrHash}`\n      );\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching block ${blockNumberOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract entities from the network.\n   * @param options Optional parameters for filtering contracts.\n   * @returns A promise that resolves to an array of ContractEntity or null.\n   */\n  async getContracts(options?: {\n    contractId?: string;\n    limit?: number;\n    order?: 'asc' | 'desc';\n  }): Promise<ContractEntity[] | null> {\n    this.logger.info('Getting contracts from the network');\n    let url = `/api/v1/contracts`;\n    const params = new URLSearchParams();\n\n    if (options?.contractId) {\n      params.append('contract.id', options.contractId);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractsResponse>(url);\n      return response.contracts || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching contracts: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a specific contract by ID or address.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param timestamp Optional timestamp for historical data.\n   * @returns A promise that resolves to a ContractEntity or null.\n   */\n  async getContract(\n    contractIdOrAddress: string,\n    timestamp?: string\n  ): Promise<ContractEntity | null> {\n    this.logger.info(`Getting contract ${contractIdOrAddress}`);\n    let url = `/api/v1/contracts/${contractIdOrAddress}`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractEntity>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract results from the network.\n   * @param options Optional parameters for filtering contract results.\n   * @returns A promise that resolves to an array of ContractResult or null.\n   */\n  async getContractResults(options?: {\n    from?: string;\n    blockHash?: string;\n    blockNumber?: string;\n    internal?: boolean;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    transactionIndex?: number;\n  }): Promise<ContractResult[] | null> {\n    this.logger.info('Getting contract results from the network');\n    let url = `/api/v1/contracts/results`;\n    const params = new URLSearchParams();\n\n    if (options?.from) {\n      params.append('from', options.from);\n    }\n    if (options?.blockHash) {\n      params.append('block.hash', options.blockHash);\n    }\n    if (options?.blockNumber) {\n      params.append('block.number', options.blockNumber);\n    }\n    if (options?.internal !== undefined) {\n      params.append('internal', options.internal.toString());\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.transactionIndex) {\n      params.append('transaction.index', options.transactionIndex.toString());\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractResultsResponse>(\n        url\n      );\n      return response.results || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching contract results: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a specific contract result by transaction ID or hash.\n   * @param transactionIdOrHash The transaction ID or hash.\n   * @param nonce Optional nonce filter.\n   * @returns A promise that resolves to a ContractResult or null.\n   */\n  async getContractResult(\n    transactionIdOrHash: string,\n    nonce?: number\n  ): Promise<ContractResult | null> {\n    this.logger.info(`Getting contract result for ${transactionIdOrHash}`);\n    let url = `/api/v1/contracts/results/${transactionIdOrHash}`;\n\n    if (nonce !== undefined) {\n      url += `?nonce=${nonce}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractResult>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract result for ${transactionIdOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract results for a specific contract.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param options Optional parameters for filtering.\n   * @returns A promise that resolves to an array of ContractResult or null.\n   */\n  async getContractResultsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      blockHash?: string;\n      blockNumber?: string;\n      from?: string;\n      internal?: boolean;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      transactionIndex?: number;\n    }\n  ): Promise<ContractResult[] | null> {\n    this.logger.info(\n      `Getting contract results for contract ${contractIdOrAddress}`\n    );\n    let url = `/api/v1/contracts/${contractIdOrAddress}/results`;\n    const params = new URLSearchParams();\n\n    if (options?.blockHash) {\n      params.append('block.hash', options.blockHash);\n    }\n    if (options?.blockNumber) {\n      params.append('block.number', options.blockNumber);\n    }\n    if (options?.from) {\n      params.append('from', options.from);\n    }\n    if (options?.internal !== undefined) {\n      params.append('internal', options.internal.toString());\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.transactionIndex) {\n      params.append('transaction.index', options.transactionIndex.toString());\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractResultsResponse>(\n        url\n      );\n      return response.results || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract results for ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract state for a specific contract.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param options Optional parameters for filtering.\n   * @returns A promise that resolves to an array of ContractState or null.\n   */\n  async getContractState(\n    contractIdOrAddress: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      slot?: string;\n      timestamp?: string;\n    }\n  ): Promise<ContractState[] | null> {\n    this.logger.info(`Getting contract state for ${contractIdOrAddress}`);\n    let url = `/api/v1/contracts/${contractIdOrAddress}/state`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.slot) {\n      params.append('slot', options.slot);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractStateResponse>(url);\n      return response.state || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract state for ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract actions for a specific transaction.\n   * @param transactionIdOrHash The transaction ID or hash.\n   * @param options Optional parameters for filtering.\n   * @returns A promise that resolves to an array of ContractAction or null.\n   */\n  async getContractActions(\n    transactionIdOrHash: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<ContractAction[] | null> {\n    this.logger.info(`Getting contract actions for ${transactionIdOrHash}`);\n    let url = `/api/v1/contracts/results/${transactionIdOrHash}/actions`;\n    const params = new URLSearchParams();\n\n    if (options?.index) {\n      params.append('index', options.index);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractActionsResponse>(\n        url\n      );\n      return response.actions || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract actions for ${transactionIdOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract logs from the network.\n   * @param options Optional parameters for filtering logs.\n   * @returns A promise that resolves to an array of ContractLog or null.\n   */\n  async getContractLogs(options?: {\n    index?: string;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    topic0?: string;\n    topic1?: string;\n    topic2?: string;\n    topic3?: string;\n    transactionHash?: string;\n  }): Promise<ContractLog[] | null> {\n    this.logger.info('Getting contract logs from the network');\n    let url = `/api/v1/contracts/results/logs`;\n    const params = new URLSearchParams();\n\n    if (options?.index) {\n      params.append('index', options.index);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.topic0) {\n      params.append('topic0', options.topic0);\n    }\n    if (options?.topic1) {\n      params.append('topic1', options.topic1);\n    }\n    if (options?.topic2) {\n      params.append('topic2', options.topic2);\n    }\n    if (options?.topic3) {\n      params.append('topic3', options.topic3);\n    }\n    if (options?.transactionHash) {\n      params.append('transaction.hash', options.transactionHash);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractLogsResponse>(url);\n      return response.logs || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching contract logs: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract logs for a specific contract.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param options Optional parameters for filtering logs.\n   * @returns A promise that resolves to an array of ContractLog or null.\n   */\n  async getContractLogsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      topic0?: string;\n      topic1?: string;\n      topic2?: string;\n      topic3?: string;\n    }\n  ): Promise<ContractLog[] | null> {\n    this.logger.info(\n      `Getting contract logs for contract ${contractIdOrAddress}`\n    );\n    let url = `/api/v1/contracts/${contractIdOrAddress}/results/logs`;\n    const params = new URLSearchParams();\n\n    if (options?.index) {\n      params.append('index', options.index);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.topic0) {\n      params.append('topic0', options.topic0);\n    }\n    if (options?.topic1) {\n      params.append('topic1', options.topic1);\n    }\n    if (options?.topic2) {\n      params.append('topic2', options.topic2);\n    }\n    if (options?.topic3) {\n      params.append('topic3', options.topic3);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractLogsResponse>(url);\n      return response.logs || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract logs for ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves NFT information by token ID and serial number.\n   * @param tokenId The token ID.\n   * @param serialNumber The serial number of the NFT.\n   * @returns A promise that resolves to an NftInfo or null.\n   */\n  async getNftInfo(\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftInfo | null> {\n    this.logger.info(`Getting NFT info for ${tokenId}/${serialNumber}`);\n    const url = `/api/v1/tokens/${tokenId}/nfts/${serialNumber}`;\n\n    try {\n      const response = await this._requestWithRetry<NftInfo>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching NFT info for ${tokenId}/${serialNumber}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves NFTs for a specific token.\n   * @param tokenId The token ID.\n   * @param options Optional parameters for filtering NFTs.\n   * @returns A promise that resolves to an array of NftInfo or null.\n   */\n  async getNftsByToken(\n    tokenId: string,\n    options?: {\n      accountId?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      serialNumber?: string;\n    }\n  ): Promise<NftInfo[] | null> {\n    this.logger.info(`Getting NFTs for token ${tokenId}`);\n    let url = `/api/v1/tokens/${tokenId}/nfts`;\n    const params = new URLSearchParams();\n\n    if (options?.accountId) {\n      params.append('account.id', options.accountId);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.serialNumber) {\n      params.append('serialnumber', options.serialNumber);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NftsResponse>(url);\n      return response.nfts || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching NFTs for token ${tokenId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network information.\n   * @returns A promise that resolves to NetworkInfo or null.\n   */\n  async getNetworkInfo(): Promise<NetworkInfo | null> {\n    this.logger.info('Getting network information');\n    const url = `/api/v1/network/nodes`;\n\n    try {\n      const response = await this._requestWithRetry<NetworkInfo>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network info: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network fees.\n   * @param timestamp Optional timestamp for historical fees.\n   * @returns A promise that resolves to NetworkFees or null.\n   */\n  async getNetworkFees(timestamp?: string): Promise<NetworkFees | null> {\n    this.logger.info('Getting network fees');\n    let url = `/api/v1/network/fees`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NetworkFees>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network fees: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network supply information.\n   * @param timestamp Optional timestamp for historical supply data.\n   * @returns A promise that resolves to NetworkSupply or null.\n   */\n  async getNetworkSupply(timestamp?: string): Promise<NetworkSupply | null> {\n    this.logger.info('Getting network supply');\n    let url = `/api/v1/network/supply`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NetworkSupply>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network supply: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network stake information.\n   * @param timestamp Optional timestamp for historical stake data.\n   * @returns A promise that resolves to NetworkStake or null.\n   */\n  async getNetworkStake(timestamp?: string): Promise<NetworkStake | null> {\n    this.logger.info('Getting network stake');\n    let url = `/api/v1/network/stake`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NetworkStake>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network stake: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves opcode traces for a specific transaction.\n   * @param transactionIdOrHash The transaction ID or hash.\n   * @param options Optional parameters for trace details.\n   * @returns A promise that resolves to an OpcodesResponse or null.\n   */\n  async getOpcodeTraces(\n    transactionIdOrHash: string,\n    options?: {\n      stack?: boolean;\n      memory?: boolean;\n      storage?: boolean;\n    }\n  ): Promise<OpcodesResponse | null> {\n    this.logger.info(`Getting opcode traces for ${transactionIdOrHash}`);\n    let url = `/api/v1/contracts/results/${transactionIdOrHash}/opcodes`;\n    const params = new URLSearchParams();\n\n    if (options?.stack !== undefined) {\n      params.append('stack', options.stack.toString());\n    }\n    if (options?.memory !== undefined) {\n      params.append('memory', options.memory.toString());\n    }\n    if (options?.storage !== undefined) {\n      params.append('storage', options.storage.toString());\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<OpcodesResponse>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching opcode traces for ${transactionIdOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n}\n","import {\n  AccountId,\n  Client,\n  PublicKey,\n  TransactionId,\n  TransactionReceipt,\n  ScheduleSignTransaction,\n  ScheduleId,\n} from '@hashgraph/sdk';\nimport { AbstractSigner } from '../signer/abstract-signer';\nimport {\n  SignScheduledTransactionParams,\n  AgentOperationalMode,\n  HederaNetworkType,\n  MirrorNodeConfig,\n} from '../types';\nimport type { IPlugin, GenericPluginContext, HederaTool } from '../plugins';\nimport { HcsBuilder } from '../builders/hcs/hcs-builder';\nimport { HtsBuilder } from '../builders/hts/hts-builder';\nimport { AccountBuilder } from '../builders/account/account-builder';\nimport { ScsBuilder } from '../builders/scs/scs-builder';\nimport { QueryBuilder } from '../builders/query/query-builder';\nimport { ExecuteResult } from '../builders/base-service-builder';\nimport { ModelCapability } from '../types/model-capability';\nimport { HederaMirrorNode } from '../services/mirror-node';\nimport { Logger } from '../utils/logger';\n\nexport interface PluginConfig {\n  plugins?: IPlugin[];\n  appConfig?: Record<string, unknown> | undefined;\n}\nconst NOT_INITIALIZED_ERROR =\n  'HederaAgentKit not initialized. Call await kit.initialize() first.';\n\n/**\n * HederaAgentKit provides a simplified interface for interacting with the Hedera network,\n * abstracting away the complexities of the underlying SDK for common use cases.\n * It supports various operations related to HCS, HTS, and HBAR transfers through a Signer and Builders.\n * The kit must be initialized using the async `initialize()` method before its tools can be accessed.\n */\nexport class HederaAgentKit {\n  public readonly client: Client;\n  public readonly network: HederaNetworkType;\n  public readonly signer: AbstractSigner;\n  public readonly mirrorNode: HederaMirrorNode;\n  private loadedPlugins: IPlugin[];\n  private aggregatedTools: HederaTool[];\n  private pluginConfigInternal?: PluginConfig | undefined;\n  private isInitialized: boolean = false;\n  public readonly logger: Logger;\n  public operationalMode: AgentOperationalMode;\n  public userAccountId?: string | undefined;\n  public scheduleUserTransactionsInBytesMode: boolean;\n  public modelCapability: ModelCapability;\n  public modelName?: string | undefined;\n\n  constructor(\n    signer: AbstractSigner,\n    pluginConfigInput?: PluginConfig | undefined,\n    initialOperationalMode: AgentOperationalMode = 'returnBytes',\n    userAccountId?: string,\n    scheduleUserTransactionsInBytesMode: boolean = true,\n    modelCapability: ModelCapability = ModelCapability.MEDIUM,\n    modelName?: string,\n    mirrorNodeConfig?: MirrorNodeConfig,\n    disableLogging: boolean = false\n  ) {\n    this.signer = signer;\n    this.network = this.signer.getNetwork();\n\n    const shouldDisableLogs =\n      disableLogging || process.env.DISABLE_LOGS === 'true';\n\n    this.logger = new Logger({\n      level: shouldDisableLogs ? 'silent' : 'info',\n      module: 'HederaAgentKit',\n      silent: shouldDisableLogs,\n    });\n\n    if (this.network === 'mainnet') {\n      this.client = Client.forMainnet();\n    } else if (this.network === 'testnet') {\n      this.client = Client.forTestnet();\n    } else {\n      throw new Error(`Unsupported network type: ${this.network}`);\n    }\n    this.client.setOperator(\n      this.signer.getAccountId(),\n      this.signer.getOperatorPrivateKey()\n    );\n\n    this.mirrorNode = new HederaMirrorNode(\n      this.network,\n      new Logger({\n        level: shouldDisableLogs ? 'silent' : 'info',\n        module: 'HederaAgentKit-MirrorNode',\n        silent: shouldDisableLogs,\n      }),\n      mirrorNodeConfig\n    );\n\n    this.pluginConfigInternal = pluginConfigInput;\n    this.loadedPlugins = [];\n    this.aggregatedTools = [];\n    this.operationalMode = initialOperationalMode;\n    this.userAccountId = userAccountId;\n    this.scheduleUserTransactionsInBytesMode =\n      scheduleUserTransactionsInBytesMode;\n    this.modelCapability = modelCapability;\n    this.modelName = modelName;\n  }\n\n  /**\n   * Initializes the HederaAgentKit, including loading any configured plugins and aggregating tools.\n   * This method must be called before `getAggregatedLangChainTools()` can be used.\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      this.logger.warn('HederaAgentKit is already initialized.');\n      return;\n    }\n\n    this.loadedPlugins = [];\n\n    const contextForPlugins: GenericPluginContext = {\n      logger: this.logger,\n      config: {\n        ...(this.pluginConfigInternal?.appConfig || {}),\n        hederaKit: this,\n        modelCapability: this.modelCapability,\n      },\n      client: {\n        getNetwork: () => this.network,\n      },\n    };\n\n    // Ensure unique plugins by id\n    const uniquePlugins: IPlugin[] = [];\n    const seenIds = new Set<string>();\n    if (this.pluginConfigInternal?.plugins) {\n      for (const pluginInstance of this.pluginConfigInternal.plugins) {\n        if (!seenIds.has(pluginInstance.id)) {\n          uniquePlugins.push(pluginInstance);\n          seenIds.add(pluginInstance.id);\n        }\n      }\n    }\n\n    for (const pluginInstance of uniquePlugins) {\n      try {\n        this.logger.info(\n          `Initializing plugin: ${pluginInstance.name}`\n        );\n        await pluginInstance.initialize(contextForPlugins);\n        this.loadedPlugins.push(pluginInstance);\n        this.logger.info(\n          `Successfully initialized and added plugin: ${pluginInstance.name}`\n        );\n      } catch (error: unknown) {\n        this.logger.error(\n          `Failed to initialize plugin ${pluginInstance.name}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // Aggregate tools only from plugins\n    const pluginTools: HederaTool[] = this.loadedPlugins.flatMap((plugin) => {\n      return plugin.getTools();\n    });\n    this.aggregatedTools = [...pluginTools];\n\n    this.isInitialized = true;\n    this.logger.info(\n      'HederaAgentKit initialized successfully with all tools aggregated.'\n    );\n  }\n\n  public async getOperator(): Promise<{ id: AccountId; publicKey: PublicKey }> {\n    return {\n      id: this.signer.getAccountId(),\n      publicKey: await this.signer.getPublicKey(),\n    };\n  }\n\n  /**\n   * Retrieves the aggregated list of LangChain tools from the kit, core tools, and plugins.\n   * The HederaAgentKit instance must be initialized via `await kit.initialize()` before calling this method.\n   * @returns {Tool[]} An array of LangChain Tool objects.\n   * @throws {Error} If the kit has not been initialized.\n   */\n  public getAggregatedLangChainTools(): HederaTool[] {\n    if (!this.isInitialized) {\n      throw new Error(\n        'HederaAgentKit not initialized. Call await kit.initialize() before accessing tools.'\n      );\n    }\n    return this.aggregatedTools;\n  }\n\n  /**\n   * Provides access to the Hedera Consensus Service (HCS) builder.\n   * @returns {HcsBuilder} An instance of HcsBuilder.\n   * @throws {Error} If HederaAgentKit has not been initialized via `await initialize()`.\n   */\n  public hcs(): HcsBuilder {\n    if (!this.isInitialized) {\n      throw new Error(NOT_INITIALIZED_ERROR);\n    }\n    return new HcsBuilder(this);\n  }\n\n  /**\n   * Provides access to the Hedera Token Service (HTS) builder.\n   * @returns {HtsBuilder} An instance of HtsBuilder.\n   * @throws {Error} If HederaAgentKit has not been initialized via `await initialize()`.\n   */\n  public hts(): HtsBuilder {\n    if (!this.isInitialized) {\n      throw new Error(NOT_INITIALIZED_ERROR);\n    }\n    return new HtsBuilder(this);\n  }\n\n  /**\n   * Provides access to the Hedera Account Service builder.\n   * @returns {AccountBuilder} An instance of AccountBuilder.\n   * @throws {Error} If HederaAgentKit has not been initialized via `await initialize()`.\n   */\n  public accounts(): AccountBuilder {\n    if (!this.isInitialized) {\n      throw new Error(NOT_INITIALIZED_ERROR);\n    }\n    return new AccountBuilder(this);\n  }\n\n  /**\n   * Provides access to the Hedera Smart Contract Service (SCS) builder.\n   * @returns {ScsBuilder} An instance of ScsBuilder.\n   * @throws {Error} If HederaAgentKit has not been initialized via `await initialize()`.\n   */\n  public scs(): ScsBuilder {\n    if (!this.isInitialized) {\n      throw new Error(NOT_INITIALIZED_ERROR);\n    }\n    return new ScsBuilder(this);\n  }\n\n  /**\n   * Provides access to the Hedera Query builder for read-only operations.\n   * @returns {QueryBuilder} An instance of QueryBuilder.\n   * @throws {Error} If HederaAgentKit has not been initialized via `await initialize()`.\n   */\n  public query(): QueryBuilder {\n    if (!this.isInitialized) {\n      throw new Error(NOT_INITIALIZED_ERROR);\n    }\n    return new QueryBuilder(this);\n  }\n  /**\n   * Retrieves the transaction receipt for a given transaction ID string.\n   * @param {string} transactionIdString - The transaction ID (e.g., \"0.0.xxxx@16666666.77777777\").\n   * @returns {Promise<TransactionReceipt>} A promise that resolves to the TransactionReceipt.\n   * @throws {Error} If the transaction ID is invalid or receipt cannot be fetched.\n   */\n  public async getTransactionReceipt(\n    transactionIdInput: TransactionId | string\n  ): Promise<TransactionReceipt> {\n    const transactionId =\n      typeof transactionIdInput === 'string'\n        ? TransactionId.fromString(transactionIdInput)\n        : transactionIdInput;\n    try {\n      return await transactionId.getReceipt(this.client);\n    } catch (error: unknown) {\n      this.logger.error(\n        `Failed to get transaction receipt for ${transactionId.toString()}: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Signs a scheduled transaction.\n   * The transaction is signed by the operator configured in the current signer.\n   * @param {SignScheduledTransactionParams} params - Parameters for the ScheduleSign transaction.\n   * @returns {Promise<ExecuteResult>} A promise that resolves to an object indicating success, receipt, and transactionId.\n   * @throws {Error} If the execution fails.\n   */\n  public async signScheduledTransaction(\n    params: SignScheduledTransactionParams\n  ): Promise<ExecuteResult> {\n    if (!this.isInitialized) {\n      throw new Error(\n        'HederaAgentKit not initialized. Call await kit.initialize() first.'\n      );\n    }\n    this.logger.info(\n      `Attempting to sign scheduled transaction: ${params.scheduleId.toString()}`\n    );\n\n    const scheduleId =\n      typeof params.scheduleId === 'string'\n        ? ScheduleId.fromString(params.scheduleId)\n        : params.scheduleId;\n\n    const transaction = new ScheduleSignTransaction().setScheduleId(scheduleId);\n\n    if (params.memo) {\n      transaction.setTransactionMemo(params.memo);\n    }\n\n    let transactionIdToReport: string | undefined;\n    if (!transaction.transactionId) {\n      transaction.freezeWith(this.client);\n    }\n    transactionIdToReport = transaction.transactionId?.toString();\n\n    try {\n      const receipt = await this.signer.signAndExecuteTransaction(transaction);\n\n      return {\n        success: true,\n        receipt: receipt,\n        transactionId: transactionIdToReport,\n      };\n    } catch (error: unknown) {\n      this.logger.error(\n        `Failed to sign scheduled transaction ${params.scheduleId.toString()}: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        transactionId: transactionIdToReport,\n      };\n    }\n  }\n}\n\nexport default HederaAgentKit;\n","import { ModelCapability } from '../types/model-capability';\n\n/**\n * Model capability configuration for different AI models\n */\ninterface ModelConfig {\n  capability: ModelCapability;\n  contextWindow: number;\n  description: string;\n}\n\n/**\n * OpenRouter API model response structure\n */\ninterface OpenRouterModel {\n  id: string;\n  name: string;\n  description: string;\n  context_length: number;\n  pricing: {\n    prompt: string;\n    completion: string;\n  };\n}\n\n/**\n * Static fallback registry for essential models (used when API is unavailable)\n */\nconst FALLBACK_MODEL_REGISTRY: Record<string, ModelConfig> = {\n  'gpt-3.5-turbo': {\n    capability: ModelCapability.SMALL,\n    contextWindow: 16385,\n    description: 'OpenAI GPT-3.5 Turbo',\n  },\n  'gpt-4': {\n    capability: ModelCapability.LARGE,\n    contextWindow: 8192,\n    description: 'OpenAI GPT-4',\n  },\n  'gpt-4-turbo': {\n    capability: ModelCapability.MEDIUM,\n    contextWindow: 128000,\n    description: 'OpenAI GPT-4 Turbo',\n  },\n  'gpt-4o': {\n    capability: ModelCapability.MEDIUM,\n    contextWindow: 128000,\n    description: 'OpenAI GPT-4o',\n  },\n  'gpt-4o-mini': {\n    capability: ModelCapability.SMALL,\n    contextWindow: 128000,\n    description: 'OpenAI GPT-4o Mini',\n  },\n  'o1-preview': {\n    capability: ModelCapability.LARGE,\n    contextWindow: 128000,\n    description: 'OpenAI o1 Preview',\n  },\n  'o1-mini': {\n    capability: ModelCapability.MEDIUM,\n    contextWindow: 128000,\n    description: 'OpenAI o1 Mini',\n  },\n  'o3-mini': {\n    capability: ModelCapability.MEDIUM,\n    contextWindow: 128000,\n    description: 'OpenAI o3 Mini',\n  },\n  'claude-3.5-sonnet': {\n    capability: ModelCapability.LARGE,\n    contextWindow: 200000,\n    description: 'Anthropic Claude 3.5 Sonnet',\n  },\n  'claude-4': {\n    capability: ModelCapability.LARGE,\n    contextWindow: 200000,\n    description: 'Anthropic Claude 4',\n  },\n  'gemini-1.5-pro': {\n    capability: ModelCapability.LARGE,\n    contextWindow: 2000000,\n    description: 'Google Gemini 1.5 Pro',\n  },\n};\n\n/**\n * Model capability detector that provides scalable model capability inference\n * Fetches comprehensive model data from OpenRouter API and caches it\n */\nexport class ModelCapabilityDetector {\n  private static instance: ModelCapabilityDetector;\n  private registry: Record<string, ModelConfig>;\n  private lastFetchTime: number = 0;\n  private readonly CACHE_DURATION = 24 * 60 * 60 * 1000;\n  private readonly OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/models';\n\n  private constructor() {\n    this.registry = { ...FALLBACK_MODEL_REGISTRY };\n  }\n\n  /**\n   * Get singleton instance\n   */\n  public static getInstance(): ModelCapabilityDetector {\n    if (!ModelCapabilityDetector.instance) {\n      ModelCapabilityDetector.instance = new ModelCapabilityDetector();\n    }\n    return ModelCapabilityDetector.instance;\n  }\n\n  /**\n   * Determine model capability based on context window and model characteristics\n   */\n  private determineCapability(model: OpenRouterModel): ModelCapability {\n    const modelId = model.id.toLowerCase();\n    const contextLength = model.context_length;\n\n    if (\n      modelId.includes('mini') ||\n      modelId.includes('tiny') ||\n      modelId.includes('light') ||\n      modelId.includes('instant') ||\n      modelId.includes('3.5-turbo')\n    ) {\n      return ModelCapability.SMALL;\n    }\n\n    if (\n      modelId.includes('local') ||\n      modelId.includes('llama') ||\n      modelId.includes('mistral') ||\n      modelId.includes('yi-') ||\n      modelId.includes('qwen') ||\n      modelId.includes('deepseek') ||\n      modelId.includes('phi-') ||\n      modelId.includes('mythomax') ||\n      modelId.includes('valkyrie')\n    ) {\n      return ModelCapability.UNLIMITED;\n    }\n    if (contextLength <= 16000) {\n      return ModelCapability.SMALL;\n    } else if (contextLength <= 50000) {\n      return ModelCapability.MEDIUM;\n    } else {\n      return ModelCapability.LARGE;\n    }\n  }\n\n  /**\n   * Fetch models from OpenRouter API\n   */\n  private async fetchModelsFromAPI(): Promise<void> {\n    try {\n      const response = await fetch(this.OPENROUTER_API_URL, {\n        headers: {\n          Accept: 'application/json',\n          'User-Agent': 'hedera-agent-kit/1.0',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      const models: OpenRouterModel[] = data.data || [];\n\n      this.registry = { ...FALLBACK_MODEL_REGISTRY };\n\n      for (const model of models) {\n        const config: ModelConfig = {\n          capability: this.determineCapability(model),\n          contextWindow: model.context_length,\n          description: model.name,\n        };\n\n        this.registry[model.id] = config;\n\n        const simplifiedId = this.getSimplifiedModelId(model.id);\n        if (simplifiedId !== model.id) {\n          this.registry[simplifiedId] = config;\n        }\n      }\n\n      this.lastFetchTime = Date.now();\n      console.log(\n        `ModelCapabilityDetector: Loaded ${models.length} models from OpenRouter API`\n      );\n    } catch (error) {\n      console.warn(\n        `ModelCapabilityDetector: Failed to fetch from API, using fallback registry:`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Get simplified model ID for common patterns\n   */\n  private getSimplifiedModelId(fullId: string): string {\n    if (fullId.startsWith('openai/')) {\n      return fullId.replace('openai/', '');\n    }\n    if (fullId.startsWith('anthropic/')) {\n      return fullId.replace('anthropic/', '');\n    }\n    if (fullId.startsWith('google/')) {\n      return fullId.replace('google/', '');\n    }\n    if (fullId.startsWith('mistralai/')) {\n      return fullId.replace('mistralai/', '');\n    }\n    if (fullId.startsWith('meta-llama/')) {\n      return fullId.replace('meta-llama/', '');\n    }\n\n    return fullId;\n  }\n\n  /**\n   * Ensure models are loaded and up-to-date\n   */\n  private async ensureModelsLoaded(): Promise<void> {\n    const now = Date.now();\n    const shouldRefresh = now - this.lastFetchTime > this.CACHE_DURATION;\n\n    if (shouldRefresh) {\n      await this.fetchModelsFromAPI();\n    }\n  }\n\n  /**\n   * Register a new model configuration\n   */\n  public registerModel(modelName: string, config: ModelConfig): void {\n    this.registry[modelName] = config;\n  }\n\n  /**\n   * Register multiple models at once\n   */\n  public registerModels(models: Record<string, ModelConfig>): void {\n    Object.assign(this.registry, models);\n  }\n\n  /**\n   * Get model capability for a given model name\n   */\n  public async getModelCapability(\n    modelName?: string\n  ): Promise<ModelCapability> {\n    if (!modelName) {\n      return ModelCapability.MEDIUM;\n    }\n\n    await this.ensureModelsLoaded();\n\n    const exactMatch = this.registry[modelName];\n    if (exactMatch) {\n      return exactMatch.capability;\n    }\n\n    const normalizedName = modelName.toLowerCase();\n\n    for (const [registeredName, config] of Object.entries(this.registry)) {\n      if (\n        normalizedName.includes(registeredName.toLowerCase()) ||\n        registeredName.toLowerCase().includes(normalizedName)\n      ) {\n        return config.capability;\n      }\n    }\n\n    return this.getCapabilityFromHeuristics(normalizedName);\n  }\n\n  /**\n   * Synchronous version that uses cached data only\n   */\n  public getModelCapabilitySync(modelName?: string): ModelCapability {\n    if (!modelName) {\n      return ModelCapability.MEDIUM;\n    }\n\n    const exactMatch = this.registry[modelName];\n    if (exactMatch) {\n      return exactMatch.capability;\n    }\n\n    const normalizedName = modelName.toLowerCase();\n\n    for (const [registeredName, config] of Object.entries(this.registry)) {\n      if (\n        normalizedName.includes(registeredName.toLowerCase()) ||\n        registeredName.toLowerCase().includes(normalizedName)\n      ) {\n        return config.capability;\n      }\n    }\n\n    return this.getCapabilityFromHeuristics(normalizedName);\n  }\n\n  /**\n   * Fallback heuristics for unknown models\n   */\n  private getCapabilityFromHeuristics(normalizedName: string): ModelCapability {\n    if (\n      normalizedName.includes('mini') ||\n      normalizedName.includes('3.5') ||\n      normalizedName.includes('tiny') ||\n      normalizedName.includes('light') ||\n      normalizedName.includes('instant')\n    ) {\n      return ModelCapability.SMALL;\n    }\n\n    if (\n      normalizedName.includes('turbo') ||\n      normalizedName.includes('4o') ||\n      normalizedName.includes('flash') ||\n      normalizedName.includes('small') ||\n      normalizedName.includes('medium') ||\n      normalizedName.includes('haiku') ||\n      normalizedName.includes('bison') ||\n      normalizedName.includes('palm')\n    ) {\n      return ModelCapability.MEDIUM;\n    }\n\n    if (\n      normalizedName.includes('claude') ||\n      normalizedName.includes('gpt-4') ||\n      normalizedName.includes('gemini') ||\n      normalizedName.includes('sonnet') ||\n      normalizedName.includes('opus') ||\n      normalizedName.includes('large') ||\n      normalizedName.includes('ultra') ||\n      normalizedName.includes('mixtral') ||\n      normalizedName.includes('command-r') ||\n      normalizedName.includes('o1') ||\n      normalizedName.includes('o3')\n    ) {\n      return ModelCapability.LARGE;\n    }\n\n    if (\n      normalizedName.includes('local') ||\n      normalizedName.includes('ollama') ||\n      normalizedName.includes('llama') ||\n      normalizedName.includes('mistral') ||\n      normalizedName.includes('yi-') ||\n      normalizedName.includes('qwen') ||\n      normalizedName.includes('deepseek') ||\n      normalizedName.includes('phi-')\n    ) {\n      return ModelCapability.UNLIMITED;\n    }\n\n    return ModelCapability.MEDIUM;\n  }\n\n  /**\n   * Get model configuration for a given model name\n   */\n  public async getModelConfig(\n    modelName: string\n  ): Promise<ModelConfig | undefined> {\n    await this.ensureModelsLoaded();\n    return this.registry[modelName];\n  }\n\n  /**\n   * Get context window size for a given model name\n   */\n  public async getContextWindow(modelName?: string): Promise<number> {\n    if (!modelName) {\n      return 16385;\n    }\n\n    await this.ensureModelsLoaded();\n\n    const exactMatch = this.registry[modelName];\n    if (exactMatch) {\n      return exactMatch.contextWindow;\n    }\n\n    const normalizedName = modelName.toLowerCase();\n\n    for (const [registeredName, config] of Object.entries(this.registry)) {\n      if (\n        normalizedName.includes(registeredName.toLowerCase()) ||\n        registeredName.toLowerCase().includes(normalizedName)\n      ) {\n        return config.contextWindow;\n      }\n    }\n\n    return 16385;\n  }\n\n  /**\n   * Synchronous version that uses cached data only for context window\n   */\n  public getContextWindowSync(modelName?: string): number {\n    if (!modelName) {\n      return 16385;\n    }\n\n    const exactMatch = this.registry[modelName];\n    if (exactMatch) {\n      return exactMatch.contextWindow;\n    }\n\n    const normalizedName = modelName.toLowerCase();\n\n    for (const [registeredName, config] of Object.entries(this.registry)) {\n      if (\n        normalizedName.includes(registeredName.toLowerCase()) ||\n        registeredName.toLowerCase().includes(normalizedName)\n      ) {\n        return config.contextWindow;\n      }\n    }\n\n    return 16385;\n  }\n\n  /**\n   * Get all registered models\n   */\n  public async getAllModels(): Promise<Record<string, ModelConfig>> {\n    await this.ensureModelsLoaded();\n    return { ...this.registry };\n  }\n\n  /**\n   * Check if a model is registered\n   */\n  public async isModelRegistered(modelName: string): Promise<boolean> {\n    await this.ensureModelsLoaded();\n    return modelName in this.registry;\n  }\n\n  /**\n   * Get models by capability\n   */\n  public async getModelsByCapability(\n    capability: ModelCapability\n  ): Promise<string[]> {\n    await this.ensureModelsLoaded();\n    return Object.entries(this.registry)\n      .filter(([, config]) => config.capability === capability)\n      .map(([name]) => name);\n  }\n\n  /**\n   * Force refresh models from API\n   */\n  public async refreshModels(): Promise<void> {\n    this.lastFetchTime = 0;\n    await this.fetchModelsFromAPI();\n  }\n\n  /**\n   * Get cache status\n   */\n  public getCacheStatus(): {\n    lastFetch: Date;\n    isStale: boolean;\n    modelCount: number;\n  } {\n    const now = Date.now();\n    const isStale = now - this.lastFetchTime > this.CACHE_DURATION;\n\n    return {\n      lastFetch: new Date(this.lastFetchTime),\n      isStale,\n      modelCount: Object.keys(this.registry).length,\n    };\n  }\n}\n","import { BaseCallbackHandler } from '@langchain/core/callbacks/base';\nimport { LLMResult } from '@langchain/core/outputs';\nimport { Logger } from './logger';\n\nconst DEFAULT_MODEL = 'gpt-4o-mini';\n\n/**\n * Token usage data structure\n */\nexport interface TokenUsage {\n  promptTokens: number;\n  completionTokens: number;\n  totalTokens: number;\n  modelName?: string | undefined;\n  timestamp?: Date | undefined;\n}\n\n/**\n * Cost calculation result\n */\nexport interface CostCalculation {\n  promptCost: number;\n  completionCost: number;\n  totalCost: number;\n  currency: string;\n}\n\n/**\n * OpenRouter model pricing structure\n */\nexport interface OpenRouterModel {\n  id: string;\n  name: string;\n  pricing: {\n    prompt: string;\n    completion: string;\n  };\n}\n\n/**\n * Model pricing manager that fetches and caches pricing from OpenRouter API\n */\nexport class ModelPricingManager {\n  private static instance: ModelPricingManager;\n  private pricingCache: Map<string, { prompt: number; completion: number }> =\n    new Map();\n  private lastFetchTime: number = 0;\n  private readonly CACHE_DURATION = 24 * 60 * 60 * 1000;\n  private readonly OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/models';\n  private readonly DEFAULT_MODEL = 'gpt-4o-mini';\n  private logger: Logger;\n\n  private constructor() {\n    this.logger = new Logger({ module: 'ModelPricingManager', level: 'info' });\n    this.initializeFallbackPricing();\n  }\n\n  public static getInstance(): ModelPricingManager {\n    if (!ModelPricingManager.instance) {\n      ModelPricingManager.instance = new ModelPricingManager();\n    }\n    return ModelPricingManager.instance;\n  }\n\n  private initializeFallbackPricing(): void {\n    const fallbackPricing = {\n      'gpt-4o': { prompt: 0.005, completion: 0.015 },\n      [this.DEFAULT_MODEL]: { prompt: 0.00015, completion: 0.0006 },\n      'gpt-4-turbo': { prompt: 0.01, completion: 0.03 },\n      'gpt-4': { prompt: 0.03, completion: 0.06 },\n      'gpt-3.5-turbo': { prompt: 0.0005, completion: 0.0015 },\n    };\n\n    for (const [model, pricing] of Object.entries(fallbackPricing)) {\n      this.pricingCache.set(model, pricing);\n    }\n  }\n\n  private async fetchPricingFromAPI(): Promise<void> {\n    try {\n      const response = await fetch(this.OPENROUTER_API_URL, {\n        headers: {\n          Accept: 'application/json',\n          'User-Agent': 'hedera-agent-kit/1.0',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      const models: OpenRouterModel[] = data.data || [];\n\n      for (const model of models) {\n        if (model.pricing?.prompt && model.pricing?.completion) {\n          const promptPrice = parseFloat(model.pricing.prompt);\n          const completionPrice = parseFloat(model.pricing.completion);\n\n          if (!isNaN(promptPrice) && !isNaN(completionPrice)) {\n            this.pricingCache.set(model.id, {\n              prompt: promptPrice * 1000,\n              completion: completionPrice * 1000,\n            });\n\n            const simplifiedId = this.getSimplifiedModelId(model.id);\n            if (simplifiedId !== model.id) {\n              this.pricingCache.set(simplifiedId, {\n                prompt: promptPrice * 1000,\n                completion: completionPrice * 1000,\n              });\n            }\n          }\n        }\n      }\n\n      this.lastFetchTime = Date.now();\n      this.logger.info(\n        `Loaded pricing for ${models.length} models from OpenRouter API`\n      );\n    } catch (error) {\n      this.logger.warn(\n        'Failed to fetch pricing from API, using fallback pricing',\n        error\n      );\n    }\n  }\n\n  private getSimplifiedModelId(fullId: string): string {\n    const prefixes = [\n      'openai/',\n      'anthropic/',\n      'google/',\n      'mistralai/',\n      'meta-llama/',\n    ];\n    for (const prefix of prefixes) {\n      if (fullId.startsWith(prefix)) {\n        return fullId.replace(prefix, '');\n      }\n    }\n    return fullId;\n  }\n\n  private async ensurePricingLoaded(): Promise<void> {\n    const now = Date.now();\n    const shouldRefresh = now - this.lastFetchTime > this.CACHE_DURATION;\n\n    if (shouldRefresh || this.pricingCache.size < 10) {\n      await this.fetchPricingFromAPI();\n    }\n  }\n\n  public async getPricing(\n    modelName: string\n  ): Promise<{ prompt: number; completion: number }> {\n    await this.ensurePricingLoaded();\n\n    const exactMatch = this.pricingCache.get(modelName);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    const normalizedName = modelName.toLowerCase();\n    for (const [key, value] of this.pricingCache.entries()) {\n      if (\n        key.toLowerCase().includes(normalizedName) ||\n        normalizedName.includes(key.toLowerCase())\n      ) {\n        return value;\n      }\n    }\n\n    return (\n      this.pricingCache.get(this.DEFAULT_MODEL) || {\n        prompt: 0.00015,\n        completion: 0.0006,\n      }\n    );\n  }\n\n  public getPricingSync(modelName: string): {\n    prompt: number;\n    completion: number;\n  } {\n    const exactMatch = this.pricingCache.get(modelName);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    const normalizedName = modelName.toLowerCase();\n    for (const [key, value] of this.pricingCache.entries()) {\n      if (\n        key.toLowerCase().includes(normalizedName) ||\n        normalizedName.includes(key.toLowerCase())\n      ) {\n        return value;\n      }\n    }\n\n    return (\n      this.pricingCache.get(this.DEFAULT_MODEL) || {\n        prompt: 0.00015,\n        completion: 0.0006,\n      }\n    );\n  }\n}\n\n/**\n * Callback handler to track token usage from OpenAI API responses\n */\nexport class TokenUsageCallbackHandler extends BaseCallbackHandler {\n  name = 'TokenUsageCallbackHandler';\n  private tokenUsageHistory: TokenUsage[] = [];\n  private currentTokenUsage: TokenUsage | undefined = undefined;\n  private logger: Logger;\n  private modelName?: string | undefined;\n\n  constructor(modelName?: string, logger?: Logger) {\n    super();\n    this.modelName = modelName;\n    this.logger =\n      logger || new Logger({ module: 'TokenUsageTracker', level: 'info' });\n  }\n\n  override async handleLLMEnd(output: LLMResult): Promise<void> {\n    try {\n      if (output.llmOutput?.tokenUsage) {\n        this.currentTokenUsage = {\n          promptTokens: output.llmOutput.tokenUsage.promptTokens || 0,\n          completionTokens: output.llmOutput.tokenUsage.completionTokens || 0,\n          totalTokens: output.llmOutput.tokenUsage.totalTokens || 0,\n          modelName: this.modelName,\n          timestamp: new Date(),\n        };\n\n        this.tokenUsageHistory.push(this.currentTokenUsage);\n\n        this.logger.debug('Token usage tracked:', {\n          promptTokens: this.currentTokenUsage.promptTokens,\n          completionTokens: this.currentTokenUsage.completionTokens,\n          totalTokens: this.currentTokenUsage.totalTokens,\n          model: this.modelName,\n        });\n      }\n    } catch (error) {\n      this.logger.error('Failed to track token usage:', error);\n    }\n  }\n\n  getLatestTokenUsage(): TokenUsage | undefined {\n    return this.currentTokenUsage;\n  }\n\n  getTokenUsageHistory(): TokenUsage[] {\n    return [...this.tokenUsageHistory];\n  }\n\n  getTotalTokenUsage(): TokenUsage {\n    const total = this.tokenUsageHistory.reduce(\n      (acc, usage) => ({\n        promptTokens: acc.promptTokens + usage.promptTokens,\n        completionTokens: acc.completionTokens + usage.completionTokens,\n        totalTokens: acc.totalTokens + usage.totalTokens,\n      }),\n      { promptTokens: 0, completionTokens: 0, totalTokens: 0 }\n    );\n\n    return {\n      ...total,\n      modelName: this.modelName,\n      timestamp: new Date(),\n    };\n  }\n\n  reset(): void {\n    this.currentTokenUsage = undefined;\n    this.tokenUsageHistory = [];\n  }\n}\n\n/**\n * Calculate cost based on token usage and model with dynamic pricing\n */\nexport async function calculateTokenCost(\n  tokenUsage: TokenUsage,\n  modelName?: string\n): Promise<CostCalculation> {\n  const model = modelName || tokenUsage.modelName || DEFAULT_MODEL;\n  const pricingManager = ModelPricingManager.getInstance();\n  const pricing = await pricingManager.getPricing(model);\n\n  const promptCost = (tokenUsage.promptTokens / 1000) * pricing.prompt;\n  const completionCost =\n    (tokenUsage.completionTokens / 1000) * pricing.completion;\n\n  return {\n    promptCost,\n    completionCost,\n    totalCost: promptCost + completionCost,\n    currency: 'USD',\n  };\n}\n\n/**\n * Synchronous version of calculateTokenCost using cached pricing\n */\nexport function calculateTokenCostSync(\n  tokenUsage: TokenUsage,\n  modelName?: string\n): CostCalculation {\n  const model = modelName || tokenUsage.modelName || DEFAULT_MODEL;\n  const pricingManager = ModelPricingManager.getInstance();\n  const pricing = pricingManager.getPricingSync(model);\n\n  const promptCost = (tokenUsage.promptTokens / 1000) * pricing.prompt;\n  const completionCost =\n    (tokenUsage.completionTokens / 1000) * pricing.completion;\n\n  return {\n    promptCost,\n    completionCost,\n    totalCost: promptCost + completionCost,\n    currency: 'USD',\n  };\n}\n\n/**\n * Format cost for display\n */\nexport function formatCost(\n  cost: CostCalculation,\n  precision: number = 6\n): string {\n  return `$${cost.totalCost.toFixed(precision)} ${cost.currency}`;\n}\n\n/**\n * Estimate tokens from text (rough approximation)\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n","import {\n  AccountId,\n  PublicKey,\n  Transaction,\n  TransactionReceipt,\n  PrivateKey,\n  Client,\n} from '@hashgraph/sdk';\nimport { HederaMirrorNode } from '../services/mirror-node';\nimport { HederaNetworkType } from '../types';\nimport { Logger } from '../utils/logger';\n\n/**\n * AbstractSigner provides a common interface and shared functionality for different signing mechanisms.\n * Concrete implementations will handle specifics for server-side, browser (WalletConnect), etc.\n */\nexport abstract class AbstractSigner {\n  public mirrorNode!: HederaMirrorNode;\n\n  /**\n   * Retrieves the Hedera account ID associated with this signer.\n   * This must be implemented by concrete classes.\n   * @returns {AccountId} The Hedera AccountId object.\n   */\n  public abstract getAccountId(): AccountId;\n\n  /**\n   * Retrieves the public key associated with this signer's account using the Hedera Mirror Node.\n   * This method relies on the `mirrorNode` property being initialized by the concrete signer.\n   * @returns {Promise<PublicKey>} A promise that resolves to the Hedera PublicKey object.\n   * @throws {Error} If the public key cannot be retrieved from the mirror node or if mirrorNode is not initialized.\n   */\n  public async getPublicKey(): Promise<PublicKey> {\n    if (!this.mirrorNode) {\n      throw new Error(\n        'AbstractSigner: HederaMirrorNode has not been initialized by the concrete signer implementation. This is an internal error.'\n      );\n    }\n    const accountIdToQuery = this.getAccountId();\n    try {\n      return await this.mirrorNode.getPublicKey(accountIdToQuery.toString());\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      throw new Error(\n        `Failed to retrieve public key from mirror node for account ${accountIdToQuery.toString()}: ${errorMessage}`\n      );\n    }\n  }\n\n  /**\n   * Signs and executes a Hedera transaction, returning its receipt.\n   * Concrete implementations will manage their own client interactions for this process.\n   * @param {Transaction} transaction - The transaction to sign and execute.\n   * @returns {Promise<TransactionReceipt>} A promise that resolves to the transaction receipt.\n   */\n  public abstract signAndExecuteTransaction(\n    transaction: Transaction\n  ): Promise<TransactionReceipt>;\n\n  /**\n   * Retrieves the Hedera network type this signer is configured for.\n   * This must be implemented by concrete classes.\n   * @returns {HederaNetworkType} The configured Hedera network type ('mainnet' or 'testnet').\n   */\n  public abstract getNetwork(): HederaNetworkType;\n\n  /**\n   * Retrieves the operator's private key.\n   * This is needed by HederaAgentKit to set the operator on its internal client.\n   * Concrete implementations must provide this.\n   * @returns {PrivateKey} The operator's private key.\n   */\n  public abstract getOperatorPrivateKey(): PrivateKey;\n\n  /**\n   * Retrieves the client instance configured for this signer.\n   * This is needed for operations like freezing transactions with the correct payer.\n   * @returns {Client} The Hedera Client object.\n   */\n  public abstract getClient(): Client;\n\n  /**\n   * Initializes the HederaMirrorNode instance for the signer.\n   * Concrete classes must call this in their constructor.\n   * @param {HederaNetworkType} network - The network for the mirror node.\n   * @param {string} moduleName - A descriptive name for the logger module (e.g., 'ServerSigner').\n   */\n  protected initializeMirrorNode(\n    network: HederaNetworkType,\n    moduleName: string\n  ): void {\n    this.mirrorNode = new HederaMirrorNode(\n      network,\n      new Logger({\n        level: 'info',\n        module: `${moduleName}-MirrorNode`,\n      })\n    );\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport {\n  PublicKey,\n  AccountId,\n  TopicId,\n  PrivateKey,\n  CustomFee,\n  TokenType,\n  TokenSupplyType,\n  TokenId,\n  Long,\n  NftId,\n  CustomFixedFee,\n  Key,\n  FileId,\n  ContractFunctionParameters,\n  KeyList,\n  ContractId,\n  Hbar,\n  EvmAddress,\n  PendingAirdropId,\n  TransactionId,\n  ScheduleId,\n} from '@hashgraph/sdk';\n\nexport {\n  PublicKey,\n  AccountId,\n  TopicId,\n  PrivateKey,\n  CustomFee,\n  TokenType,\n  TokenSupplyType,\n  TokenId,\n  Long,\n  NftId,\n  CustomFixedFee,\n  Key,\n  FileId,\n  ContractFunctionParameters,\n  KeyList,\n  ContractId,\n  Hbar,\n  EvmAddress,\n  PendingAirdropId,\n  TransactionId,\n  ScheduleId,\n};\n\nexport type AgentOperationalMode = 'autonomous' | 'returnBytes';\nexport type HederaNetworkType = 'mainnet' | 'testnet' | 'previewnet';\n\n/**\n * Configuration for custom mirror node providers.\n *\n * @example\n * // Using HGraph with API key in URL\n * const config = {\n *   customUrl: 'https://mainnet.hedera.api.hgraph.dev/v1/<API-KEY>',\n *   apiKey: 'your-api-key-here'\n * };\n *\n * @example\n * // Using custom provider with API key in headers\n * const config = {\n *   customUrl: 'https://custom-mirror-node.com',\n *   apiKey: 'your-api-key',\n *   headers: {\n *     'X-Custom-Header': 'value'\n *   }\n * };\n */\nexport interface MirrorNodeConfig {\n  /** Custom mirror node URL. Can include <API-KEY> placeholder for URL-based API keys. */\n  customUrl?: string;\n  /** API key for authentication. Will be used in both Authorization header and URL replacement. */\n  apiKey?: string;\n  /** Additional custom headers to include with requests. */\n  headers?: Record<string, string>;\n}\n\nexport type TokenBalance = {\n  account: string;\n  balance: number;\n  decimals: number;\n};\n\nexport type TokenHoldersBalancesApiResponse = {\n  timestamp: string;\n  balances: TokenBalance[];\n  links: {\n    next: string;\n  };\n};\n\nexport type DetailedTokenBalance = {\n  tokenId: string;\n  tokenSymbol: string;\n  tokenName: string;\n  tokenDecimals: string;\n  balance: number;\n  balanceInDisplayUnit: BigNumber;\n  timestamp: string;\n  balances: {\n    account: string;\n    balance: number;\n    tokens: {\n      token_id: string;\n      balance: number;\n    }[];\n  }[];\n  links: {\n    next: string | null;\n  };\n};\n\nexport type HtsTokenBalanceApiReponse = {\n  timestamp: string;\n  balances: TokenBalance[];\n  links: {\n    next: string;\n  };\n};\n\ntype ProtobufEncodedKey = {\n  _type: 'ProtobufEncoded';\n  key: string;\n};\n\nexport type CustomFees = {\n  created_timestamp: string;\n  fixed_fees: unknown[];\n  fractional_fees: unknown[];\n};\n\nexport type HtsTokenDetails = {\n  admin_key: ProtobufEncodedKey;\n  auto_renew_account: string;\n  auto_renew_period: number;\n  created_timestamp: string;\n  custom_fees: CustomFees;\n  decimals: string;\n  deleted: boolean;\n  expiry_timestamp: number;\n  fee_schedule_key: ProtobufEncodedKey;\n  freeze_default: boolean;\n  freeze_key: ProtobufEncodedKey;\n  initial_supply: string;\n  kyc_key: ProtobufEncodedKey;\n  max_supply: string;\n  memo: string;\n  metadata: string;\n  metadata_key: ProtobufEncodedKey | null;\n  modified_timestamp: string;\n  name: string;\n  pause_key: ProtobufEncodedKey;\n  pause_status: 'PAUSED' | 'UNPAUSED';\n  supply_key: ProtobufEncodedKey;\n  supply_type: 'FINITE' | 'INFINITE';\n  symbol: string;\n  token_id: string;\n  total_supply: string;\n  treasury_account_id: string;\n  type: 'FUNGIBLE_COMMON' | 'NON_FUNGIBLE_UNIQUE';\n  wipe_key: ProtobufEncodedKey;\n  supplyType: TokenSupplyType;\n  maxSupply?: number | BigNumber;\n};\n\nexport type AllTokensBalancesApiResponse = {\n  timestamp: string;\n  balances: {\n    account: string; // Account ID in the format \"0.0.x\"\n    balance: number; // Total balance equivalent in HBAR\n    tokens: {\n      token_id: string; // Token ID in the format \"0.0.x\"\n      balance: number; // Balance of the specific token\n    }[];\n  }[];\n  links: {\n    next: string | null; // link to next page\n  };\n};\n\nexport type Airdrop = {\n  amount: number;\n  receiver_id: string;\n  sender_id: string;\n  token_id: string;\n};\n\nexport type PendingAirdropsApiResponse = {\n  airdrops: Airdrop[];\n  links: {\n    next: string | null;\n  };\n};\n\ntype TimestampRange = {\n  from: string;\n  to?: string | null;\n};\n\nexport type TopicInfoApiResponse = {\n  admin_key?: Key | null;\n  auto_renew_account?: string | null;\n  auto_renew_period?: number | null;\n  created_timestamp?: string | null;\n  deleted?: boolean | null;\n  memo?: string;\n  submit_key?: Key | null;\n  timestamp?: TimestampRange;\n  topic_id?: string | null;\n};\n\nexport type HCSMessage = {\n  chunk_info: unknown | null;\n  consensus_timestamp: string;\n  message: string;\n  payer_account_id: string;\n  running_hash: string;\n  running_hash_version: number;\n  sequence_number: number;\n  topic_id: string;\n  supplyType: TokenSupplyType;\n  maxSupply?: number | BigNumber;\n  raw_content?: string;\n};\n\nexport type HCSMessageApiResponse = {\n  messages: HCSMessage[];\n  links: {\n    next: string | null;\n  };\n};\n\nexport enum AgentKitActionName {\n  CREATE_TOPIC_CUSTODIAL = 'createTopicCustodial',\n  CREATE_TOPIC_NON_CUSTODIAL = 'createTopicNonCustodial',\n  DELETE_TOPIC_CUSTODIAL = 'deleteTopicCustodial',\n  DELETE_TOPIC_NON_CUSTODIAL = 'deleteTopicNonCustodial',\n  SUBMIT_TOPIC_MESSAGE_CUSTODIAL = 'submitTopicMessageCustodial',\n  SUBMIT_TOPIC_MESSAGE_NON_CUSTODIAL = 'submitTopicMessageCustodial',\n  CREATE_TOKEN_CUSTODIAL = 'createTokenCustodial',\n  CREATE_TOKEN_NON_CUSTODIAL = 'createTokenNonCustodial',\n  ASSOCIATE_TOKEN_CUSTODIAL = 'associateTokenCustodial',\n  ASSOCIATE_TOKEN_NON_CUSTODIAL = 'associateTokenNonCustodial',\n  DISSOCIATE_TOKEN_CUSTODIAL = 'dissociateTokenCustodial',\n  DISSOCIATE_TOKEN_NON_CUSTODIAL = 'dissociateTokenNonCustodial',\n  AIRDROP_TOKEN_CUSTODIAL = 'airdropTokenCustodial',\n  AIRDROP_TOKEN_NON_CUSTODIAL = 'airdropTokenNonCustodial',\n  REJECT_TOKEN_CUSTODIAL = 'rejectedTokenCustodial',\n  REJECT_TOKEN_NON_CUSTODIAL = 'rejectedTokenNonCustodial',\n  MINT_TOKEN_CUSTODIAL = 'mintTokenCustodial',\n  MINT_TOKEN_NON_CUSTODIAL = 'mintTokenNonCustodial',\n  MINT_NFT_TOKEN_CUSTODIAL = 'mintNFTTokenCustodial',\n  MINT_NFT_TOKEN_NON_CUSTODIAL = 'mintNFTTokenNonCustodial',\n  CLAIM_AIRDROP_CUSTODIAL = 'claimAirdropCustodial',\n  CLAIM_AIRDROP_NON_CUSTODIAL = 'claimAirdropNonCustodial',\n  TRANSFER_TOKEN_CUSTODIAL = 'transferTokenCustodial',\n  TRANSFER_TOKEN_NON_CUSTODIAL = 'transferTokenNonCustodial',\n  TRANSFER_HBAR_CUSTODIAL = 'transferHbarCustodial',\n  TRANSFER_HBAR_NON_CUSTODIAL = 'transferHbarNonCustodial',\n  ASSET_ALLOWANCE_CUSTODIAL = 'assetAllowedCustodial',\n  ASSET_ALLOWANCE_NON_CUSTODIAL = 'assetAllowedNonCustodial',\n}\n\n/**\n * Parameters for creating a new Hedera Consensus Service (HCS) topic.\n */\nexport interface CreateTopicParams {\n  /** Optional. The publicly visible memo for the topic. */\n  memo?: string;\n  /**\n   * Optional. The administrative key for the topic.\n   * Can be a PrivateKey string (for the builder to derive public key and potentially sign if different from operator)\n   * or a PublicKey object.\n   * If not provided, the topic might be immutable depending on Hedera defaults, or operator may become admin.\n   */\n  adminKey?: string | Key;\n  /**\n   * Optional. The key authorized to submit messages to the topic.\n   * Can be a PrivateKey string or a PublicKey object.\n   * If not provided, anyone can submit.\n   */\n  submitKey?: string | Key;\n  /**\n   * Optional. The auto-renewal period for the topic, in seconds.\n   * Defaults to 7776000 (approximately 90 days) if not specified by the user; the builder will apply this default.\n   */\n  autoRenewPeriod?: number;\n  /**\n   * Optional. The account ID to be used for auto-renewal payments.\n   * If not provided, and if an adminKey is the current signer, the signer's account may be used by default by Hedera.\n   * Can be an AccountId object or a string representation (e.g., \"0.0.xxxx\").\n   */\n  autoRenewAccountId?: string | AccountId;\n  /** Optional. The key which can change the token's custom fee schedule. If not set, the adminKey may control this. */\n  feeScheduleKey?: string | Key;\n  /** Optional. A list of account IDs that should be exempt from custom fees. */\n  exemptAccountIds?: string[];\n  /** Optional. A list of custom fees to be applied to the topic. */\n  customFees?: CustomFixedFee[];\n}\n\n/**\n * Parameters for submitting a message to an HCS topic.\n */\nexport interface SubmitMessageParams {\n  /** The ID of the topic to submit the message to. */\n  topicId: string | TopicId;\n  /** The message content. Can be a string or Uint8Array for binary data. */\n  message: string | Uint8Array;\n  /**\n   * Optional. The maximum number of chunks to divide the message into if it exceeds single transaction limits.\n   * The builder will handle chunking if necessary.\n   */\n  maxChunks?: number;\n  /**\n   * Optional. The size of each chunk in bytes if chunking is performed.\n   * Defaults to a reasonable value (e.g., 1024 bytes) if not specified and chunking is needed.\n   */\n  chunkSize?: number;\n  /**\n   * Optional. A specific private key to sign message submission if the topic requires it\n   * and it's different from the main operator/signer.\n   * Can be a PrivateKey object or its string representation.\n   */\n  submitKey?: string | PrivateKey;\n}\n\n/**\n * Parameters for deleting an HCS topic.\n */\nexport interface DeleteTopicParams {\n  /** The ID of the topic to be deleted. */\n  topicId: string | TopicId;\n}\n\n/**\n * Represents a single hbar transfer operation.\n * Amount is in hbars (positive for credit, negative for debit).\n */\nexport interface HbarTransfer {\n  accountId: string | AccountId;\n  amount: Hbar;\n}\n\n/**\n * Parameters for an HBAR transfer operation, potentially involving multiple accounts.\n * The sum of all transfer amounts must be zero.\n */\nexport interface HbarTransferParams {\n  transfers: HbarTransfer[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for creating a new Hedera Fungible Token.\n */\nexport interface FTCreateParams {\n  /** The publicly visible name of the token. Max 100 characters. */\n  tokenName: string;\n  /** The publicly visible symbol of the token. Max 100 characters. */\n  tokenSymbol: string;\n  /** The account which will act as a treasury for the token. This account will receive the initial supply. */\n  treasuryAccountId: string | AccountId;\n  /** The initial supply of tokens to be minted to the treasury account. In the smallest denomination. */\n  initialSupply: number | BigNumber;\n  /** The number of decimal places a token is divisible by. */\n  decimals: number;\n  /** The key which can perform update/delete operations on the token. */\n  adminKey?: string | Key;\n  /** The key which can grant or revoke KYC of an account for the token. */\n  kycKey?: string | Key;\n  /** The key which can sign to freeze or unfreeze an account for token transactions. */\n  freezeKey?: string | Key;\n  /** The key which can wipe the token balance of an account. */\n  wipeKey?: string | Key;\n  /** The key which can change the total supply of a token. */\n  supplyKey?: string | Key;\n  /** The key which can change the token's custom fee schedule. */\n  feeScheduleKey?: string | Key;\n  /** The key which can pause or unpause the token. */\n  pauseKey?: string | Key;\n  /** The account which will be automatically charged to renew the token's expiration. */\n  autoRenewAccountId?: string | AccountId;\n  /** The period that the auto-renew account will be charged to extend the token's expiry. In seconds. Defaults to 7776000 (90 days). */\n  autoRenewPeriod?: number;\n  /** The memo associated with the token. Max 100 characters. */\n  memo?: string;\n  /** The default freeze status (frozen or unfrozen) of accounts signed up for this token. Defaults to false (unfrozen). */\n  freezeDefault?: boolean;\n  /** The custom fees to be assessed during atomic swaps for this token. */\n  customFees?: CustomFee[] | undefined;\n  /** The supply type of the token (Finite or Infinite). */\n  supplyType: TokenSupplyType;\n  /** The maximum number of tokens that can be in circulation. Required if supplyType is Finite. */\n  maxSupply?: number | BigNumber;\n}\n\n/**\n * Parameters for creating a new Hedera Non-Fungible Token (NFT).\n */\nexport interface NFTCreateParams {\n  /** The publicly visible name of the token. Max 100 characters. */\n  tokenName: string;\n  /** The publicly visible symbol of the token. Max 100 characters. */\n  tokenSymbol: string;\n  /** The account which will act as a treasury for the token. */\n  treasuryAccountId: string | AccountId;\n  /** The key which can perform update/delete operations on the token. */\n  adminKey?: string | Key;\n  /** The key which can grant or revoke KYC of an account for the token. */\n  kycKey?: string | Key;\n  /** The key which can sign to freeze or unfreeze an account for token transactions. */\n  freezeKey?: string | Key;\n  /** The key which can wipe the token balance of an account. */\n  wipeKey?: string | Key;\n  /** The key which can change the total supply of a token (mint/burn). */\n  supplyKey?: string | Key;\n  /** The key which can change the token's custom fee schedule. */\n  feeScheduleKey?: string | Key;\n  /** The key which can pause or unpause the token. */\n  pauseKey?: string | Key;\n  /** The account which will be automatically charged to renew the token's expiration. */\n  autoRenewAccountId?: string | AccountId;\n  /** The period that the auto-renew account will be charged to extend the token's expiry. In seconds. Defaults to 7776000 (90 days). */\n  autoRenewPeriod?: number;\n  /** The memo associated with the token. Max 100 characters. */\n  memo?: string;\n  /** The default freeze status (frozen or unfrozen) of accounts signed up for this token. Defaults to false (unfrozen). */\n  freezeDefault?: boolean;\n  /** The custom fees to be assessed. Instances of FixedFee, FractionalFee, RoyaltyFee (all extend CustomFee). */\n  customFees?: CustomFee[];\n  /** The supply type, typically Finite for NFTs. Max supply also needed for Finite. */\n  supplyType: TokenSupplyType; // e.g., TokenSupplyType.Finite\n  /** The maximum number of NFTs that can be minted. Required if supplyType is Finite. */\n  maxSupply?: number | BigNumber; // BigNumber for consistency, though NFTs are u64\n}\n\n/**\n * Parameters for minting new NFTs for a given NFT token.\n */\nexport interface MintNFTParams {\n  /** The ID of the NFT token to mint for. */\n  tokenId: string | TokenId;\n  /**\n   * An array of human-readable strings representing metadata for each NFT to be minted.\n   * Each string will be encoded as UTF-8 and must result in 100 bytes or less.\n   */\n  metadata: string[];\n  /** Optional. The batch size for minting transactions if many NFTs are minted. Defaults to 10. */\n  batchSize?: number | undefined;\n  nftId?: NftId | undefined;\n  senderAccountId?: string | AccountId | undefined;\n  receiverAccountId?: string | AccountId | undefined;\n  isApproved?: boolean | undefined;\n  memo?: string | undefined;\n}\n\n/**\n * Parameters for updating an existing HCS topic.\n * All fields are optional except topicId. Providing `null` to a key field typically clears it.\n * Using an empty string for memo clears it.\n */\nexport interface UpdateTopicParams {\n  /** The ID of the topic to update. */\n  topicId: string | TopicId;\n  /** New memo for the topic. An empty string effectively clears the memo. `null` can also be used to signal clearing. */\n  memo?: string | null;\n  /** New admin key for the topic. `null` to clear the admin key (if permissible). */\n  adminKey?: string | Key | null;\n  /** New submit key for the topic. `null` to clear the submit key. */\n  submitKey?: string | Key | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New account ID for auto-renewal. `null` to clear the auto-renew account. */\n  autoRenewAccountId?: string | AccountId | null;\n  /** New fee schedule key for the topic. `null` to clear. */\n  feeScheduleKey?: string | Key | null;\n  /** Optional. A list of account IDs that should be exempt from custom fees. This will overwrite any existing exemptions. To clear all exemptions, provide an empty array. */\n  exemptAccountIds?: string[];\n}\n\n/**\n * Parameters for minting more fungible tokens.\n */\nexport interface MintFTParams {\n  /** The ID of the fungible token to mint for. */\n  tokenId: string | TokenId;\n  /** The amount of tokens to mint, in the smallest unit of the token. */\n  amount: number | BigNumber;\n}\n\n/**\n * Parameters for burning fungible tokens.\n */\nexport interface BurnFTParams {\n  /** The ID of the fungible token to burn. */\n  tokenId: string | TokenId;\n  /** The amount of tokens to burn, in the smallest unit of the token. */\n  amount: number | BigNumber;\n}\n\n/**\n * Parameters for burning Non-Fungible Tokens.\n */\nexport interface BurnNFTParams {\n  /** The ID of the NFT token whose serials are to be burned. */\n  tokenId: string | TokenId;\n  /** An array of serial numbers to burn. Values can be number, Long, or BigNumber for large serials. */\n  serials: Array<number | Long | BigNumber>;\n}\n\n/**\n * Parameters for transferring a single Non-Fungible Token (NFT).\n */\nexport interface TransferNFTParams {\n  /** The token ID of the NFT (e.g., \"0.0.12345\"). */\n  tokenId: string;\n  /** The serial number of the NFT within the token. Can be a number or a string representing a positive integer.*/\n  serial: string | number;\n  /** The account ID of the sender. */\n  senderAccountId: string | AccountId;\n  /** The account ID of the receiver. */\n  receiverAccountId: string | AccountId;\n  /**\n   * Optional. Set to true if the sender is not the owner of the NFT but is an approved operator for it (or for all of owner's NFTs).\n   * Defaults to false, indicating the sender is the owner.\n   */\n  isApproved?: boolean;\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for associating tokens with an account.\n */\nexport interface AssociateTokensParams {\n  /** The account ID to associate tokens with. */\n  accountId: string | AccountId;\n  /** An array of token IDs to associate. */\n  tokenIds: Array<string | TokenId>;\n  initialBalance?: number | BigNumber | undefined;\n  key: string | PublicKey;\n  memo?: string;\n  autoRenewAccountId?: string | AccountId;\n  autoRenewPeriod?: number;\n  receiverSignatureRequired?: boolean;\n  maxAutomaticTokenAssociations?: number;\n  stakedAccountId?: string | AccountId;\n  stakedNodeId?: number | Long;\n  declineStakingReward?: boolean;\n  alias?: EvmAddress | string;\n}\n\n/**\n * Parameters for dissociating tokens from an account.\n */\nexport interface DissociateTokensParams {\n  /** The account ID to dissociate tokens from. */\n  accountId: string | AccountId;\n  /** An array of token IDs to dissociate. */\n  tokenIds: Array<string | TokenId>;\n}\n\n/**\n * Represents a single fungible token transfer operation.\n * Amount is in the smallest unit (positive for credit, negative for debit).\n */\nexport interface FungibleTokenTransferSpec {\n  type: 'fungible';\n  tokenId: string | TokenId;\n  accountId: string | AccountId;\n  amount: number | BigNumber;\n}\n\n/**\n * Represents a single non-fungible token (NFT) transfer operation.\n */\nexport interface NonFungibleTokenTransferSpec {\n  type: 'nft';\n  nftId: NftId;\n  senderAccountId: string | AccountId;\n  receiverAccountId: string | AccountId;\n  isApproved?: boolean;\n}\n\n/**\n * Union type for different kinds of token transfers.\n */\nexport type TokenTransferSpec =\n  | FungibleTokenTransferSpec\n  | NonFungibleTokenTransferSpec;\n\n/**\n * Parameters for a generic token transfer operation, potentially involving multiple tokens and NFTs.\n */\nexport interface TransferTokensParams {\n  /** An array of token transfer specifications (fungible or NFT). */\n  tokenTransfers: TokenTransferSpec[];\n  /** Optional. An array of HBAR transfer specifications. */\n  hbarTransfers?: HbarTransfer[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for wiping tokens (fungible or non-fungible) from an account.\n */\nexport interface WipeTokenAccountParams {\n  /** The ID of the token to wipe. */\n  tokenId: string | TokenId;\n  /** The account ID from which tokens will be wiped. */\n  accountId: string | AccountId;\n  /** For Fungible Tokens: the amount to wipe. In the smallest unit. */\n  amount?: number | BigNumber;\n  /** For Non-Fungible Tokens: an array of serial numbers to wipe. */\n  serials?: Array<number | Long | BigNumber>;\n}\n\n/**\n * Parameters for freezing an account for a specific token.\n */\nexport interface FreezeTokenAccountParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to be frozen for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for unfreezing an account for a specific token.\n */\nexport interface UnfreezeTokenAccountParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to be unfrozen for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for granting KYC to an account for a specific token.\n */\nexport interface GrantKycTokenParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to be granted KYC for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for revoking KYC from an account for a specific token.\n */\nexport interface RevokeKycTokenParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to have KYC revoked for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for pausing a token.\n */\nexport interface PauseTokenParams {\n  /** The ID of the token to pause. */\n  tokenId: string | TokenId;\n}\n\n/**\n * Parameters for unpausing a token.\n */\nexport interface UnpauseTokenParams {\n  /** The ID of the token to unpause. */\n  tokenId: string | TokenId;\n}\n\n/**\n * Parameters for updating an existing Hedera token (fungible or non-fungible).\n * All fields are optional except `tokenId`. Providing `null` to a key field clears it.\n * Using an empty string for memo/name/symbol clears them if applicable by SDK.\n */\nexport interface UpdateTokenParams {\n  /** The ID of the token to update. */\n  tokenId: string | TokenId;\n  /** New name for the token. */\n  tokenName?: string | null; // null or empty to clear/reset if SDK allows\n  /** New symbol for the token. */\n  tokenSymbol?: string | null; // null or empty to clear/reset if SDK allows\n  /** New treasury account for the token. */\n  treasuryAccountId?: string | AccountId;\n  /** New admin key for the token. `null` to clear. */\n  adminKey?: string | Key | null;\n  /** New KYC key for the token. `null` to clear. */\n  kycKey?: string | Key | null;\n  /** New freeze key for the token. `null` to clear. */\n  freezeKey?: string | Key | null;\n  /** New wipe key for the token. `null` to clear. */\n  wipeKey?: string | Key | null;\n  /** New supply key for the token. `null` to clear. */\n  supplyKey?: string | Key | null;\n  /** New fee schedule key for the token. `null` to clear. */\n  feeScheduleKey?: string | Key | null;\n  /** New pause key for the token. `null` to clear. */\n  pauseKey?: string | Key | null;\n  /** New auto-renew account for the token. `null` to clear. */\n  autoRenewAccountId?: string | AccountId | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New memo for the token. An empty string or `null` to clear. */\n  memo?: string | null;\n  // Note: Custom fees are not updated via TokenUpdateTransaction. Use TokenFeeScheduleUpdateTransaction.\n}\n\n/**\n * Parameters for deleting a token.\n */\nexport interface DeleteTokenParams {\n  /** The ID of the token to delete. */\n  tokenId: string | TokenId;\n}\n\n/**\n * Parameters for updating the fee schedule of a token.\n */\nexport interface TokenFeeScheduleUpdateParams {\n  /** The ID of the token whose fee schedule is to be updated. */\n  tokenId: string | TokenId;\n  /** An array of new custom fees for the token. This will replace the existing fee schedule. */\n  customFees: CustomFee[];\n}\n\n/**\n * Parameters for creating a new Hedera account.\n */\nexport interface CreateAccountParams {\n  /** The initial balance of the new account in HBAR. Defaults to 0 if not specified. */\n  initialBalance?: number | BigNumber | undefined;\n  /**\n   * The public key for the new account.\n   * Can be a PublicKey object or a string representation of a PrivateKey\n   * from which the PublicKey will be derived by the builder.\n   * If a PrivateKey string is provided, it is used ONLY to derive the public key for account creation\n   * and is NOT stored or used for signing by the builder itself.\n   */\n  key: string | PublicKey;\n  /** Optional. The memo for the account. */\n  memo?: string;\n  /** Optional. The account to be used for auto-renewal payments. */\n  autoRenewAccountId?: string | AccountId;\n  /** Optional. The auto-renewal period for the account, in seconds. Defaults to ~90 days. */\n  autoRenewPeriod?: number;\n  /** Optional. If true, the account must sign any transaction transferring hbar out of this account. Defaults to false. */\n  receiverSignatureRequired?: boolean;\n  /** Optional. The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0. */\n  maxAutomaticTokenAssociations?: number;\n  /** Optional. The account to which this account is staked. */\n  stakedAccountId?: string | AccountId;\n  /** Optional. The node ID to which this account is staked. */\n  stakedNodeId?: number | Long;\n  /** Optional. If true, the account declines receiving a staking reward. Defaults to false. */\n  declineStakingReward?: boolean;\n  /** Optional. The alias for the account. If an alias is set, the key property is not used. */\n  alias?: EvmAddress | string; // string could be an EVM address string\n}\n\n/**\n * Parameters for querying a smart contract function (local call).\n */\nexport interface ContractCallQueryParams {\n  /** The ID of the contract to call. */\n  contractId: string | ContractId;\n  /** The gas to use for the query. Often less critical for local queries but can be set. */\n  gas?: number | Long; // Optional, as SDK might default or it might not be needed for all local queries\n  /** The function name and optionally its parameter types, e.g., \"getBalance(address)\". */\n  functionName: string;\n  /** The parameters to pass to the function. */\n  functionParameters?: ContractFunctionParameters;\n  /** Optional: The maximum payment allowed for this query. If not set, defaults to a value set by the SDK or node. */\n  maxQueryPayment?: Hbar;\n  /** Optional: Payment transaction ID for this query. */\n  paymentTransactionId?: string | TransactionId;\n}\n\n/**\n * Parameters for creating a new smart contract.\n */\nexport interface CreateContractParams {\n  /** The ID of the file containing the contract bytecode. Use this OR `bytecode`. */\n  bytecodeFileId?: string | FileId;\n  /** The contract bytecode as a hex-encoded string or Uint8Array. Use this OR `bytecodeFileId`. */\n  bytecode?: string | Uint8Array;\n  /** The admin key for the contract. */\n  adminKey?: string | Key;\n  /** The gas to deploy the contract. */\n  gas: number | Long;\n  /** Initial balance to send to the contract (payable constructor). In HBAR. */\n  initialBalance?: number | BigNumber;\n  /** The parameters to pass to the constructor. */\n  constructorParameters?: Uint8Array | ContractFunctionParameters;\n  /** Memo for the contract creation transaction. */\n  memo?: string;\n  /** Auto-renewal period for the contract. In seconds. */\n  autoRenewPeriod?: number;\n  /** Account to which this contract is staked. */\n  stakedAccountId?: string | AccountId;\n  /** Node ID to which this contract is staked. */\n  stakedNodeId?: number | Long;\n  /** If true, the contract declines receiving a staking reward. */\n  declineStakingReward?: boolean;\n  /** Max automatic token associations for the contract. */\n  maxAutomaticTokenAssociations?: number;\n  contractId: string | ContractId;\n  functionName: string;\n  functionParameters?: ContractFunctionParameters;\n  payableAmount?: number | BigNumber | Hbar;\n}\n\n/**\n * Parameters for executing a function of a smart contract.\n */\nexport interface ExecuteContractParams {\n  /** The ID of the contract to call. */\n  contractId: string | ContractId; // ContractId from SDK\n  /** The gas to use for the call. */\n  gas: number | Long;\n  /** The function to call. Can be just the name or name with parameters like \"functionName(uint32,string)\". */\n  functionName: string;\n  /** The parameters to pass to the function. */\n  functionParameters?: ContractFunctionParameters;\n  /** Amount of HBAR to send with the call (for payable functions). */\n  payableAmount?: number | BigNumber | Hbar;\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for creating a new file on Hedera File Service.\n */\nexport interface CreateFileParams {\n  /** The contents of the file. */\n  contents: string | Uint8Array;\n  /**\n   * The keys that must sign any transaction to modify or delete the file.\n   * If not set, the file is immutable (except for append if no keys are set at all).\n   * Each element can be a PrivateKey string (to derive PublicKey), a PublicKey object, or a KeyList object.\n   */\n  keys?: Array<string | Key | KeyList>;\n  /** A memo associated with the file. Max 100 characters. */\n  adminKey?: string | Key | null;\n  autoRenewPeriod?: number;\n  memo?: string | null;\n  stakedAccountId?: string | AccountId | '0.0.0' | null;\n  stakedNodeId?: number | Long | null;\n  declineStakingReward?: boolean;\n  maxAutomaticTokenAssociations?: number;\n  proxyAccountId?: string | AccountId | '0.0.0' | null;\n}\n\n/**\n * Parameters for appending content to an existing file on Hedera File Service.\n */\nexport interface AppendFileParams {\n  /** The ID of the file to append to. */\n  fileId: string | FileId;\n  /** The content to append. */\n  contents: string | Uint8Array;\n  /** Optional. The number of chunks to break the content into if it exceeds the transaction size limit. */\n  maxChunks?: number;\n  /** Optional. The size of each chunk in bytes. Defaults to a value like 4KB or 6KB minus overhead. */\n  chunkSize?: number;\n}\n\n/**\n * Parameters for updating the attributes of an existing file on Hedera File Service.\n * Note: This does not replace file contents; use FileAppend or recreate for that.\n */\nexport interface UpdateFileParams {\n  /** The ID of the file to update. */\n  fileId: string | FileId;\n  /** New keys for the file. An empty array can be used to remove all keys, making the file immutable. */\n  keys?: Array<string | Key | KeyList> | null; // null or empty array to clear keys\n  /** New memo for the file. An empty string or `null` to clear. */\n  memo?: string | null;\n  /** New contents for the file. */\n  contents?: string | Uint8Array;\n}\n\n/**\n * Parameters for deleting a file from Hedera File Service.\n */\nexport interface DeleteFileParams {\n  /** The ID of the file to delete. */\n  fileId: string | FileId;\n}\n\n/**\n * Parameters for updating an existing smart contract.\n * All fields are optional except `contractId`.\n */\nexport interface UpdateContractParams {\n  /** The ID of the contract to update. */\n  contractId: string | ContractId;\n  /** New admin key for the contract. `null` to clear. */\n  adminKey?: string | Key | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New memo for the contract. An empty string or `null` to clear. */\n  memo?: string | null;\n  /** New account to which this contract is staked. `null` to unstake. */\n  stakedAccountId?: string | AccountId | '0.0.0' | null; // \"0.0.0\" to remove staking\n  /** New node ID to which this contract is staked. `-1` to remove staking. */\n  stakedNodeId?: number | Long | null;\n  /** If true, the contract declines receiving a staking reward. */\n  declineStakingReward?: boolean;\n  /** New max automatic token associations for the contract. */\n  maxAutomaticTokenAssociations?: number;\n  /** New proxy account ID for the contract. `null` or `\"0.0.0\"` to clear. */\n  proxyAccountId?: string | AccountId | '0.0.0' | null;\n  // Updating bytecode (bytecodeFileId) is not part of ContractUpdateTransaction.\n}\n\n/**\n * Parameters for deleting a smart contract.\n */\nexport interface DeleteContractParams {\n  /** The ID of the contract to delete. */\n  contractId: string | ContractId;\n  /**\n   * Optional. The account ID to transfer the contract's remaining HBAR balance to.\n   * Required if the contract has a non-zero balance. Use this OR `transferContractId`.\n   */\n  transferAccountId?: string | AccountId;\n  /**\n   * Optional. The contract ID to transfer the contract's remaining HBAR balance to.\n   * Required if the contract has a non-zero balance. Use this OR `transferAccountId`.\n   */\n  transferContractId?: string | ContractId;\n  // Note: If contract has balance, one of transferAccountId or transferContractId must be set.\n  // The builder method will need to enforce this or document it clearly.\n}\n\n/**\n * Parameters for updating an existing Hedera account.\n * All fields are optional except `accountIdToUpdate`.\n */\nexport interface UpdateAccountParams {\n  /** The ID of the account to update. */\n  accountIdToUpdate: string | AccountId;\n  /** New key for the account. `null` to clear (not typically allowed unless other conditions met). */\n  key?: string | Key | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New memo for the account. An empty string or `null` to clear. */\n  memo?: string | null;\n  /** New max automatic token associations for the account. */\n  maxAutomaticTokenAssociations?: number;\n  /** New account to which this account is staked. \"0.0.0\" or `null` to remove staking. */\n  stakedAccountId?: string | AccountId | '0.0.0' | null;\n  /** New node ID to which this account is staked. `-1` or `null` to remove staking. */\n  stakedNodeId?: number | Long | null;\n  /** If true, the account declines receiving a staking reward. */\n  declineStakingReward?: boolean;\n  /** If true, the account must sign any transaction transferring hbar out of this account. */\n  receiverSignatureRequired?: boolean;\n  amount: number | Long;\n}\n\n/**\n * Parameters for deleting an account.\n */\nexport interface DeleteAccountParams {\n  /** The ID of the account to be deleted. This account must sign the transaction. */\n  deleteAccountId: string | AccountId;\n  /** The ID of the account to transfer the remaining HBAR balance to. */\n  transferAccountId: string | AccountId;\n}\n\n/**\n * Parameters for approving an HBAR allowance.\n */\nexport interface ApproveHbarAllowanceParams {\n  /** The account ID of the HBAR owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender who is being granted the allowance. */\n  spenderAccountId: string | AccountId;\n  /** The maximum HBAR amount that the spender can use from the owner's account. */\n  amount: Hbar;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for approving an NFT allowance.\n */\nexport interface ApproveTokenNftAllowanceParams {\n  /** The account ID of the NFT owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender who is being granted the allowance. */\n  spenderAccountId: string | AccountId;\n  /** The ID of the NFT collection. */\n  tokenId: string | TokenId;\n  /** Optional. Specific serial numbers to approve. Use this OR `allSerials`. */\n  serials?: Array<number | Long | BigNumber>;\n  /** Optional. If true, approves the spender for all serials of the given NFT ID owned by the owner. Use this OR `serials`. */\n  allSerials?: boolean;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for approving a fungible token allowance.\n */\nexport interface ApproveFungibleTokenAllowanceParams {\n  /** The account ID of the token owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender who is being granted the allowance. */\n  spenderAccountId: string | AccountId;\n  /** The ID of the fungible token. */\n  tokenId: string | TokenId;\n  /** The maximum amount of the token that the spender can use from the owner's account. In smallest unit. */\n  amount: number | BigNumber;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for deleting all NFT allowances for a specific token collection granted by an owner.\n * This removes allowances for all spenders for all serials of the specified token type from this owner.\n */\nexport interface DeleteNftAllowanceAllSerialsParams {\n  /** The account ID of the NFT owner whose allowances are being deleted. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The ID of the NFT collection (token ID) for which all serial allowances will be deleted. */\n  tokenId: string | TokenId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for revoking/clearing an HBAR allowance for a specific spender.\n */\nexport interface RevokeHbarAllowanceParams {\n  /** The account ID of the HBAR owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender whose HBAR allowance is to be revoked (set to zero). */\n  spenderAccountId: string | AccountId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for revoking/clearing a fungible token allowance for a specific spender.\n */\nexport interface RevokeFungibleTokenAllowanceParams {\n  /** The account ID of the token owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender whose token allowance is to be revoked (set to zero). */\n  spenderAccountId: string | AccountId;\n  /** The ID of the fungible token. */\n  tokenId: string | TokenId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Represents a recipient for a token airdrop.\n */\nexport interface AirdropRecipient {\n  /** The account ID of the recipient. */\n  accountId: string | AccountId;\n  /** The amount of tokens to send (in smallest denomination). */\n  amount: number | Long; // Consistent with other token amounts\n}\n\n/**\n * Parameters for airdropping fungible tokens from the operator's account.\n * The operator (signer) is implicitly the sender of all amounts.\n */\nexport interface AirdropTokenParams {\n  /** The ID of the fungible token to airdrop. */\n  tokenId: string | TokenId;\n  /** An array of recipient objects, each specifying an account and an amount. */\n  recipients: AirdropRecipient[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n  pendingAirdropIds: PendingAirdropId[];\n}\n\n/**\n * Parameters for rejecting a pending airdrop or future tokens.\n */\nexport interface RejectAirdropParams {\n  /** The ID of the token that was airdropped. */\n  tokenId: string | TokenId;\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for claiming pending airdrops.\n */\nexport interface ClaimAirdropParams {\n  /** An array of SDK PendingAirdropId objects to claim. The operator (signer) is the recipient. */\n  pendingAirdropIds: PendingAirdropId[]; // Assuming PendingAirdropId is imported from @hashgraph/sdk\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for cancelling previously sent (but still pending) airdrops.\n */\nexport interface CancelAirdropParams {\n  /** An array of SDK PendingAirdropId objects to cancel. The operator (signer) must be the original sender. */\n  pendingAirdropIds: PendingAirdropId[]; // Assuming PendingAirdropId is imported from @hashgraph/sdk\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for rejecting future auto-associations with specified token types.\n */\nexport interface RejectFutureAssociationsParams {\n  // Implementation of this parameter is not provided in the original file or the code block\n  // This parameter is mentioned in the RejectAirdropParams, but its implementation is not clear\n  // It's assumed to exist as it's called in the RejectAirdropParams\n}\n\n/**\n * Parameters for signing a scheduled transaction.\n */\nexport interface SignScheduledTransactionParams {\n  /** The ID of the schedule to add a signature to. */\n  scheduleId: string | ScheduleId;\n  /** Optional memo for the ScheduleSign transaction itself. */\n  memo?: string;\n}\n\n/**\n * Parameters for querying topic information.\n */\nexport interface GetTopicInfoParams {\n  /** The ID of the topic to query. */\n  topicId: string | TopicId;\n  /** Optional. Maximum number of retries for the query. */\n  maxRetries?: number;\n}\n\n/**\n * Result of querying topic information.\n */\nexport interface TopicInfoResult {\n  topicId: string;\n  topicMemo: string;\n  runningHash: string; // hex encoded\n  sequenceNumber: string; // string representation of u64\n  expirationTime?: string; // ISO string format\n  adminKey?: string; // string representation of the key\n  autoRenewAccount?: string;\n  autoRenewPeriod?: string; // string representation of seconds\n  ledgerId?: string;\n}\n\n/**\n * Parameters for deleting/revoking NFT allowances for a *specific spender* for a token collection.\n * This uses AccountAllowanceDeleteTransaction.deleteAllTokenNftAllowances(tokenId, owner, spender).\n */\nexport interface DeleteNftSpenderAllowanceParams {\n  /** The account ID of the NFT owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The ID of the NFT collection (token ID). */\n  nftId: string | NftId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for deleting/revoking NFT allowances for specific serials for a specific spender.\n */\nexport interface DeleteNftSpenderAllowanceToolParams {\n  ownerAccountId?: string | AccountId;\n  spenderAccountId: string | AccountId;\n  tokenId: string | TokenId;\n  serials: Array<number | string | Long>;\n  memo?: string;\n}\n\n/**\n * Parameters for deleting all spender allowances for a specific NFT serial, granted by an owner.\n */\nexport interface DeleteNftSerialAllowancesParams {\n  ownerAccountId?: string | AccountId;\n  nftIdString: string; // e.g., \"0.0.tokenid.serial\"\n  memo?: string;\n  pendingAirdropIds: PendingAirdropId[];\n}\n\n// Added for ClaimAirdropTool\n/**\n * Parameters for claiming pending airdrops.\n * The SDK's PendingAirdropId is an object. For the tool's input,\n * we'll expect the structure that the SDK uses or a string that can be parsed into it.\n * The current HederaClaimAirdropTool Zod schema expects an array of strings.\n */\nexport interface ClaimAirdropParams {\n  /**\n   * An array of pending airdrop IDs to claim.\n   * These are expected to be strings that can be parsed into SDK PendingAirdropId objects if needed,\n   * or directly match the structure if SDK PendingAirdropId is serializable/deserializable simply.\n   * The @hashgraph/sdk PendingAirdropId is constructed with (accountId, tokenId, serialNumber).\n   * For simplicity in the tool input, we might expect an array of objects or structured strings.\n   * The tool placeholder Zod schema uses `z.array(z.string())` - this will need careful implementation\n   * in the actual tool to parse these strings into proper SDK PendingAirdropId objects.\n   * Let's align the type with the SDK's actual PendingAirdropId for now for builder methods.\n   */\n  pendingAirdropIds: PendingAirdropId[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n// Added for GetFileContentsTool\n/**\n * Parameters for querying file contents.\n */\nexport interface GetFileContentsParams {\n  fileId: string | FileId;\n  // maxRetries, payment, etc. could be added if BaseHederaQueryTool supports them\n}\n\n/**\n * Result of querying file contents.\n */\nexport interface FileContentsResult {\n  fileId: string;\n  contents: string; // Assuming string representation for simplicity, could be Uint8Array\n  // Could also include other file info if the query returns more\n}\n\n// Added for CallContractQueryTool\n/**\n * Parameters for calling a smart contract query function.\n * This aligns with SDK's ContractExecuteTransaction but for queries (ContractCallQuery).\n */\nexport interface CallContractQueryParams {\n  contractId: string | ContractId;\n  gas?: number | Long; // SDK: Long\n  functionName: string; // For query, this is often just the function selector or name\n  functionParameters?: ContractFunctionParameters;\n  maxQueryPayment?: Hbar; // For queries\n  paymentTransactionId?: TransactionId; // For queries\n  // senderAccountId?: string | AccountId; // For queries, client usually pays\n}\n\n/**\n * Result of a smart contract query call.\n */\nexport interface ContractQueryResult {\n  // Based on ContractFunctionResult from SDK\n  contractId?: string;\n  errorMessage?: string;\n  gasUsed?: string; // u64\n  // Various ways to get results based on type, e.getString, getInt32, etc.\n  // For a generic tool, might return raw bytes or a common representation.\n  resultAsBytes?: Uint8Array; // Raw result\n  resultDecoded?: unknown; // If ABI is available and decoding is attempted by the tool\n}\n","import { Key, PublicKey } from '@hashgraph/sdk';\nimport { detectKeyTypeFromString } from './key-type-detector';\n\n/**\n * Parses a string representation of a key into an SDK Key object.\n * Supports hex-encoded private keys (derives public key) or hex/DER-encoded public keys.\n * @param keyString The key string.\n * @returns An SDK Key object or null if parsing fails.\n */\nexport function parseKey(keyString: string): Key | null {\n  if (!keyString) {\n    return null;\n  }\n  try {\n    const keyDetection = detectKeyTypeFromString(keyString);\n    return keyDetection.privateKey.publicKey;\n  } catch {\n    try {\n      return PublicKey.fromString(keyString);\n    } catch {\n      return null;\n    }\n  }\n}\n","import { z } from 'zod';\nimport { StructuredTool, ToolParams } from '@langchain/core/tools';\nimport { HederaAgentKit } from '../../../agent/agent';\nimport { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountId, Key, TransactionId } from '@hashgraph/sdk';\nimport { parseKey } from '../../../utils/key-utils';\nimport { Logger } from '../../../utils/logger';\n\n/**\n * Zod schema for transaction meta options that can be used with any Hedera transaction tool.\n */\nexport const HederaTransactionMetaOptionsSchema = z\n  .object({\n    transactionMemo: z\n      .string()\n      .optional()\n      .describe('Optional memo for the Hedera transaction.'),\n    transactionId: z\n      .string()\n      .optional()\n      .describe(\n        'Optional transaction ID to use (e.g., for pre-generated IDs).'\n      ),\n    nodeAccountIds: z\n      .array(z.string())\n      .optional()\n      .describe(\n        'Optional specific node account IDs to target for the transaction.'\n      ),\n    schedule: z\n      .boolean()\n      .optional()\n      .describe(\n        'Set to true to schedule the transaction. If true, output will be for a ScheduleCreate transaction.'\n      ),\n    scheduleMemo: z\n      .string()\n      .optional()\n      .describe('Optional memo for the ScheduleCreate transaction itself.'),\n    schedulePayerAccountId: z\n      .string()\n      .optional()\n      .describe(\n        'Optional payer account ID for the ScheduleCreate transaction.'\n      ),\n    scheduleAdminKey: z\n      .string()\n      .optional()\n      .describe(\n        'Optional admin key (serialized string) for the ScheduleCreate transaction. Builder parses.'\n      ),\n  })\n  .optional();\n\nexport type HederaTransactionMetaOptions = z.infer<\n  typeof HederaTransactionMetaOptionsSchema\n>;\n\n/**\n * Parameters required to initialize a BaseHederaTransactionTool.\n */\nexport interface BaseHederaTransactionToolParams extends ToolParams {\n  hederaKit: HederaAgentKit;\n  logger?: Logger;\n}\n\n/**\n * Schedule options used when executing transactions.\n */\ninterface ScheduleExecutionOptions {\n  schedule?: boolean;\n  scheduleMemo?: string;\n  schedulePayerAccountId?: string | AccountId;\n  scheduleAdminKey?: Key;\n}\n\n/**\n * Base class for all Hedera transaction tools.\n * Handles common transaction processing logic across different tool types.\n *\n * @template S - The Zod schema that defines the input parameters for the specific tool\n */\nexport abstract class BaseHederaTransactionTool<\n  //@ts-ignore\n  S extends z.ZodObject<z.ZodRawShape, z.UnknownKeysParam, z.ZodTypeAny>\n> extends StructuredTool<\n  //@ts-ignore\n  z.ZodObject<\n    S['shape'] & { metaOptions: typeof HederaTransactionMetaOptionsSchema },\n    z.UnknownKeysParam,\n    z.ZodTypeAny,\n    z.infer<S> & { metaOptions?: HederaTransactionMetaOptions },\n    z.infer<S> & { metaOptions?: HederaTransactionMetaOptions }\n  >\n> {\n  protected hederaKit: HederaAgentKit;\n  protected logger: Logger;\n  protected neverScheduleThisTool: boolean = false;\n\n  /**\n   * Indicates if this tool requires multiple transactions to complete.\n   * Tools that require multiple transactions cannot be used in returnBytes mode.\n   */\n  protected requiresMultipleTransactions: boolean = false;\n\n  abstract specificInputSchema: S;\n  abstract namespace: string;\n\n  //@ts-ignore: Ignoring complex type compatibility issues\n  get schema(): this['lc_kwargs']['schema'] {\n    //@ts-ignore: Ignoring complex type compatibility issues\n    return this.specificInputSchema.extend({\n      metaOptions: HederaTransactionMetaOptionsSchema,\n    });\n  }\n\n  constructor({ hederaKit, logger, ...rest }: BaseHederaTransactionToolParams) {\n    super(rest);\n    this.hederaKit = hederaKit;\n    this.logger = logger || hederaKit.logger;\n  }\n\n  /**\n   * Get the appropriate service builder for this tool's operations.\n   */\n  protected abstract getServiceBuilder(): BaseServiceBuilder;\n\n  /**\n   * Call the appropriate builder method with the tool-specific arguments.\n   */\n  protected abstract callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<S>,\n    runManager?: CallbackManagerForToolRun\n  ): Promise<void>;\n\n  /**\n   * Apply any meta options specified in the tool call to the service builder.\n   */\n  protected async _applyMetaOptions(\n    builder: BaseServiceBuilder,\n    metaOpts: HederaTransactionMetaOptions | undefined,\n    specificCallArgs: z.infer<S>\n  ): Promise<void> {\n    await this._substituteKeyFields(specificCallArgs);\n    this._applyTransactionOptions(builder, metaOpts);\n  }\n\n  /**\n   * Handle substitution of special key field values like 'current_signer'\n   */\n  private async _substituteKeyFields(\n    specificCallArgs: z.infer<S>\n  ): Promise<void> {\n    const keyFieldNames: (keyof typeof specificCallArgs)[] = [\n      'adminKey',\n      'kycKey',\n      'freezeKey',\n      'wipeKey',\n      'supplyKey',\n      'feeScheduleKey',\n      'pauseKey',\n    ];\n\n    for (const keyField of keyFieldNames) {\n      const originalKeyValue = (specificCallArgs as Record<string, unknown>)[\n        keyField as string\n      ];\n\n      if (originalKeyValue === 'current_signer') {\n        try {\n          const operatorPubKey = await this.hederaKit.signer.getPublicKey();\n          const pubKeyString = operatorPubKey.toStringDer();\n          (specificCallArgs as Record<string, unknown>)[keyField as string] =\n            pubKeyString;\n          this.logger.info(\n            `Substituted ${\n              keyField as string\n            } with current signer's public key.`\n          );\n        } catch (error) {\n          const typedError = error as Error;\n          this.logger.error(\n            `Failed to get current signer's public key for ${\n              keyField as string\n            } substitution: ${typedError.message}`,\n            error\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Apply transaction-specific options from metaOptions\n   */\n  private _applyTransactionOptions(\n    builder: BaseServiceBuilder,\n    metaOptions?: HederaTransactionMetaOptions\n  ): void {\n    if (!metaOptions) return;\n\n    if (metaOptions.transactionId) {\n      try {\n        builder.setTransactionId(\n          TransactionId.fromString(metaOptions.transactionId)\n        );\n      } catch {\n        this.logger.warn(\n          `Invalid transactionId format in metaOptions: ${metaOptions.transactionId}, ignoring.`\n        );\n      }\n    }\n\n    if (metaOptions.nodeAccountIds && metaOptions.nodeAccountIds.length > 0) {\n      try {\n        builder.setNodeAccountIds(\n          metaOptions.nodeAccountIds.map((id: string) =>\n            AccountId.fromString(id)\n          )\n        );\n      } catch {\n        this.logger.warn(\n          `Invalid nodeAccountId format in metaOptions, ignoring.`\n        );\n      }\n    }\n\n    if (metaOptions.transactionMemo) {\n      builder.setTransactionMemo(metaOptions.transactionMemo);\n    }\n  }\n\n  /**\n   * Handle direct execution mode for the transaction\n   */\n  private async _handleAutonomous(\n    builder: BaseServiceBuilder,\n    metaOpts: HederaTransactionMetaOptions | undefined,\n    allNotes: string[]\n  ): Promise<string> {\n    const execOptions = this._buildScheduleOptions(metaOpts);\n\n    this.logger.info(\n      `Executing transaction directly (mode: autonomous): ${this.name}`\n    );\n\n    const result = await builder.execute(execOptions);\n    return JSON.stringify({ ...result, notes: allNotes });\n  }\n\n  /**\n   * Handle providing transaction bytes mode\n   */\n  private async _handleReturnBytes(\n    builder: BaseServiceBuilder,\n    metaOpts: HederaTransactionMetaOptions | undefined,\n    allNotes: string[]\n  ): Promise<string> {\n    if (this.requiresMultipleTransactions) {\n      const errorMessage =\n        `The ${this.name} tool requires multiple transactions and cannot be used in returnBytes mode. ` +\n        `Please use autonomous mode or break down the operation into individual steps.`;\n      this.logger.warn(errorMessage);\n      return JSON.stringify({\n        success: false,\n        error: errorMessage,\n        requiresAutonomous: true,\n        notes: allNotes,\n      });\n    }\n\n    const shouldSchedule = this._shouldScheduleTransaction(metaOpts);\n\n    if (shouldSchedule) {\n      return this._handleScheduledTransaction(builder, metaOpts, allNotes);\n    } else {\n      return this._handleUnscheduledTransaction(builder, allNotes);\n    }\n  }\n\n  /**\n   * Determine if a transaction should be scheduled\n   */\n  private _shouldScheduleTransaction(\n    metaOptions?: HederaTransactionMetaOptions\n  ): boolean {\n    return (\n      !this.neverScheduleThisTool &&\n      (metaOptions?.schedule ??\n        (this.hederaKit.operationalMode === 'returnBytes' &&\n          this.hederaKit.scheduleUserTransactionsInBytesMode))\n    );\n  }\n\n  /**\n   * Handle creating a scheduled transaction\n   */\n  private async _handleScheduledTransaction(\n    builder: BaseServiceBuilder,\n    metaOpts: HederaTransactionMetaOptions | undefined,\n    allNotes: string[]\n  ): Promise<string> {\n    this.logger.info(\n      `Preparing scheduled transaction (mode: returnBytes, schedule: true): ${this.name}`\n    );\n\n    const execOptions = this._buildScheduleOptions(metaOpts, true);\n    execOptions.schedulePayerAccountId = this.hederaKit.signer.getAccountId();\n\n    const scheduleCreateResult = await builder.execute(execOptions);\n\n    if (scheduleCreateResult.success && scheduleCreateResult.scheduleId) {\n      const description =\n        metaOpts?.transactionMemo || `Scheduled ${this.name} operation.`;\n\n      const userInfo = this.hederaKit.userAccountId\n        ? ` User (${this.hederaKit.userAccountId}) will be payer of scheduled transaction.`\n        : '';\n\n      return JSON.stringify({\n        success: true,\n        op: 'schedule_create',\n        scheduleId: scheduleCreateResult.scheduleId.toString(),\n        description: description + userInfo,\n        payer_account_id_scheduled_tx:\n          this.hederaKit.userAccountId || 'unknown',\n        memo_scheduled_tx: metaOpts?.transactionMemo,\n        notes: allNotes,\n      });\n    } else {\n      return JSON.stringify({\n        success: false,\n        error:\n          scheduleCreateResult.error ||\n          'Failed to create schedule and retrieve ID.',\n        notes: allNotes,\n      });\n    }\n  }\n\n  /**\n   * Handle returning transaction bytes for an unscheduled transaction\n   */\n  private async _handleUnscheduledTransaction(\n    builder: BaseServiceBuilder,\n    allNotes: string[]\n  ): Promise<string> {\n    this.logger.info(\n      `Returning transaction bytes (mode: returnBytes, schedule: false): ${this.name}`\n    );\n\n    const bytes = await builder.getTransactionBytes({});\n    return JSON.stringify({\n      success: true,\n      transactionBytes: bytes,\n      transactionId: builder.getCurrentTransaction()?.transactionId?.toString(),\n      notes: allNotes,\n    });\n  }\n\n  /**\n   * Build schedule options from meta options\n   */\n  private _buildScheduleOptions(\n    metaOptions?: HederaTransactionMetaOptions,\n    forceSchedule = false\n  ): ScheduleExecutionOptions {\n    const options: ScheduleExecutionOptions = {};\n\n    if (forceSchedule || metaOptions?.schedule) {\n      options.schedule = true;\n\n      if (metaOptions?.scheduleMemo) {\n        options.scheduleMemo = metaOptions.scheduleMemo;\n      }\n\n      if (metaOptions?.schedulePayerAccountId) {\n        try {\n          options.schedulePayerAccountId = AccountId.fromString(\n            metaOptions.schedulePayerAccountId\n          );\n        } catch {\n          this.logger.warn('Invalid schedulePayerAccountId');\n        }\n      }\n\n      if (metaOptions?.scheduleAdminKey) {\n        try {\n          const parsedKey = parseKey(metaOptions.scheduleAdminKey);\n          if (parsedKey) options.scheduleAdminKey = parsedKey;\n        } catch {\n          this.logger.warn('Invalid scheduleAdminKey');\n        }\n      }\n    }\n\n    return options;\n  }\n\n  /**\n   * Optional method for concrete tools to provide a user-friendly note for a specific Zod-defaulted parameter.\n   * @param key The key of the parameter that was defaulted by Zod.\n   * @param schemaDefaultValue The default value defined in the Zod schema for this key.\n   * @param actualValue The current/final value of the parameter after Zod parsing.\n   * @returns A user-friendly string for the note, or undefined to use a generic note.\n   */\n  protected getNoteForKey?(\n    //eslint-disable-next-line @typescript-eslint/no-unused-vars\n    key: string,\n    //eslint-disable-next-line @typescript-eslint/no-unused-vars\n    schemaDefaultValue: unknown,\n    //eslint-disable-next-line @typescript-eslint/no-unused-vars\n    actualValue: unknown\n  ): string | undefined {\n    return undefined;\n  }\n\n  /**\n   * Main method called when the tool is executed.\n   * Processes arguments, calls the specific builder method, and handles\n   * transaction execution based on the kit's operational mode.\n   */\n  protected async _call(\n    args: z.infer<ReturnType<this['schema']>>,\n    runManager?: CallbackManagerForToolRun\n  ): Promise<string> {\n    const llmProvidedMetaOptions = args.metaOptions;\n    const specificCallArgs = this._extractSpecificArgsFromCombinedArgs(args);\n\n    this.logger.info(\n      `Executing ${this.name} with Zod-parsed specific args (schema defaults applied by LangChain):`,\n      JSON.parse(JSON.stringify(specificCallArgs)),\n      'and metaOptions:',\n      llmProvidedMetaOptions\n    );\n\n    const zodSchemaInfoNotes: string[] = [];\n    if (this.specificInputSchema && this.specificInputSchema.shape) {\n      for (const key in this.specificInputSchema.shape) {\n        if (\n          Object.prototype.hasOwnProperty.call(\n            this.specificInputSchema.shape,\n            key\n          )\n        ) {\n          const fieldSchema = this.specificInputSchema.shape[\n            key\n          ] as z.ZodTypeAny;\n\n          if (\n            fieldSchema._def &&\n            (fieldSchema._def as z.ZodDefaultDef<z.ZodTypeAny>).typeName ===\n              'ZodDefault'\n          ) {\n            const defaultValueOrFn = (\n              fieldSchema._def as z.ZodDefaultDef<z.ZodTypeAny>\n            ).defaultValue();\n            let schemaDefinedDefaultValue = defaultValueOrFn;\n            if (typeof defaultValueOrFn === 'function') {\n              try {\n                schemaDefinedDefaultValue = defaultValueOrFn();\n              } catch (eDefaultFn) {\n                this.logger.warn(\n                  `Could not execute default value function for key ${key}. Error: ${\n                    (eDefaultFn as Error).message\n                  }`\n                );\n                schemaDefinedDefaultValue = '[dynamic schema default]';\n              }\n            }\n\n            const currentValue =\n              specificCallArgs[key as keyof typeof specificCallArgs];\n            let noteMessage: string | undefined;\n\n            if (this.getNoteForKey) {\n              noteMessage = this.getNoteForKey(\n                key,\n                schemaDefinedDefaultValue,\n                currentValue\n              );\n            }\n\n            if (!noteMessage) {\n              noteMessage = `For the parameter '${key}', the value '${JSON.stringify(\n                currentValue\n              )}' was used. This field has a tool schema default of '${JSON.stringify(\n                schemaDefinedDefaultValue\n              )}'.`;\n            }\n            zodSchemaInfoNotes.push(noteMessage);\n          }\n        }\n      }\n    }\n\n    this.logger.debug('Zod Schema Default Info Notes:', zodSchemaInfoNotes);\n\n    try {\n      const builder = this.getServiceBuilder();\n      builder.clearNotes();\n\n      await this.callBuilderMethod(builder, specificCallArgs, runManager);\n      await this._applyMetaOptions(\n        builder,\n        llmProvidedMetaOptions,\n        specificCallArgs\n      );\n\n      const builderAppliedDefaultNotes = builder.getNotes();\n      this.logger.debug(\n        'Builder Applied Default Notes:',\n        builderAppliedDefaultNotes\n      );\n      const allNotes = [...zodSchemaInfoNotes, ...builderAppliedDefaultNotes];\n      this.logger.debug('All Notes combined:', allNotes);\n\n      if (this.hederaKit.operationalMode === 'autonomous') {\n        return this._handleAutonomous(\n          builder,\n          llmProvidedMetaOptions,\n          allNotes\n        );\n      } else {\n        return this._handleReturnBytes(\n          builder,\n          llmProvidedMetaOptions,\n          allNotes\n        );\n      }\n    } catch (error) {\n      const builder = this.getServiceBuilder();\n      const builderNotesOnError = builder ? builder.getNotes() : [];\n      const allNotesOnError = [...zodSchemaInfoNotes, ...builderNotesOnError];\n      return this._handleError(error, allNotesOnError);\n    }\n  }\n\n  private _extractSpecificArgsFromCombinedArgs(\n    combinedArgs: z.infer<ReturnType<this['schema']>>\n  ): z.infer<S> {\n    const specificArgs: Record<string, unknown> = {};\n    if (this.specificInputSchema && this.specificInputSchema.shape) {\n      for (const key in this.specificInputSchema.shape) {\n        if (Object.prototype.hasOwnProperty.call(combinedArgs, key)) {\n          specificArgs[key] = (combinedArgs as Record<string, unknown>)[key];\n        }\n      }\n    }\n    return specificArgs as z.infer<S>;\n  }\n\n  private _handleError(error: unknown, notes?: string[]): string {\n    const errorMessage =\n      error instanceof Error ? error.message : JSON.stringify(error);\n    this.logger.error(`Error in ${this.name}: ${errorMessage}`, error);\n    return JSON.stringify({\n      success: false,\n      error: errorMessage,\n      notes: notes || [],\n    });\n  }\n}\n","import { z } from 'zod';\nimport { CreateAccountParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst CreateAccountZodSchemaCore = z.object({\n  key: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Public key string (hex) or private key string for the new account. Used if alias is not set. Builder validates presence of key or alias.'\n    ),\n  alias: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Account alias (e.g., EVM address or serialized PublicKey string). Takes precedence over key. Builder validates presence of key or alias.'\n    ),\n  initialBalance: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe(\n      'Optional. Initial balance in HBAR. Builder handles conversion. Defaults to 0.'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the account.'),\n  autoRenewAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Account ID for auto-renewal payments (e.g., \"0.0.xxxx\").'\n    ),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe(\n      'Optional. Auto-renewal period in seconds (e.g., 7776000 for 90 days).'\n    ),\n  receiverSignatureRequired: z\n    .boolean()\n    .optional()\n    .describe('Optional. If true, account must sign transfers out of it.'),\n  maxAutomaticTokenAssociations: z\n    .number()\n    .int()\n    .optional()\n    .describe('Optional. Max automatic token associations for the account.'),\n  stakedAccountId: z\n    .string()\n    .optional()\n    .describe('Optional. Account ID to stake to (e.g., \"0.0.zzzz\").'),\n  stakedNodeId: z\n    .number()\n    .int()\n    .optional()\n    .describe(\n      'Optional. Node ID to stake to. Builder handles Long conversion.'\n    ),\n  declineStakingReward: z\n    .boolean()\n    .optional()\n    .describe('Optional. If true, decline staking rewards.'),\n});\n\nexport class HederaCreateAccountTool extends BaseHederaTransactionTool<\n  typeof CreateAccountZodSchemaCore\n> {\n  name = 'hedera-account-create';\n  description =\n    'Creates a new Hedera account. Requires key or alias (builder validates). Builder handles parsing and defaults.';\n  specificInputSchema = CreateAccountZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof CreateAccountZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).createAccount(\n      specificArgs as unknown as CreateAccountParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { HbarTransferParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst HbarTransferInputSchema = z.object({\n  accountId: z\n    .string()\n    .describe('Account ID for the transfer (e.g., \"0.0.xxxx\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'HBAR amount. Positive for credit, negative for debit. Builder handles Hbar unit & sum validation.'\n    ),\n});\n\nconst TransferHbarZodSchemaCore = z.object({\n  transfers: z\n    .array(HbarTransferInputSchema)\n    .min(1)\n    .describe(\n      'Array of HBAR transfers, each with accountId and amount in HBARs.'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaTransferHbarTool extends BaseHederaTransactionTool<\n  typeof TransferHbarZodSchemaCore\n> {\n  name = 'hedera-account-transfer-hbar';\n  description =\n    'Transfers HBAR between accounts. Builder validates amounts and sum.';\n  specificInputSchema = TransferHbarZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof TransferHbarZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).transferHbar(\n      specificArgs as unknown as HbarTransferParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { UpdateAccountParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\n/*\n * Zod schema defines the direct input expected from the LLM.\n * Omitted optional fields will result in no change to those account properties.\n * The builder translates provided values to SDK calls.\n */\nconst UpdateAccountZodSchemaCore = z.object({\n  accountIdToUpdate: z.string().describe('The ID of the account to update (e.g., \"0.0.12345\").'),\n  key: z.string().nullable().optional()\n    .describe('Optional. New key (serialized string). Pass null to clear (if allowed by SDK). Builder handles parsing.'),\n  autoRenewPeriod: z.number().int().positive().optional()\n    .describe('Optional. New auto-renewal period in seconds (e.g., 7776000 for 90 days).'),\n  memo: z.string().nullable().optional()\n    .describe('Optional. New memo. Pass null or empty string to clear.'),\n  maxAutomaticTokenAssociations: z.number().int().min(0).optional()\n    .describe('Optional. New max automatic token associations (0-5000).'),\n  stakedAccountId: z.string().nullable().optional()\n    .describe('Optional. New account ID to stake to. Pass \"0.0.0\" or null to clear.'),\n  stakedNodeId: z.number().int().nullable().optional()\n    .describe('Optional. New node ID to stake to. Pass -1 or null to clear. Builder handles Long conversion.'),\n  declineStakingReward: z.boolean().optional()\n    .describe('Optional. If true, account declines staking rewards.'),\n  receiverSignatureRequired: z.boolean().optional()\n    .describe('Optional. If true, account must sign transfers out of it.'),\n});\n\nexport class HederaUpdateAccountTool extends BaseHederaTransactionTool<\n  typeof UpdateAccountZodSchemaCore\n> {\n  name = 'hedera-account-update';\n  description =\n    'Updates an existing Hedera account. Specify accountIdToUpdate and fields to change. Builder handles parsing and clearing logic.';\n  specificInputSchema = UpdateAccountZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  /**\n   * Passes the validated arguments directly to the AccountBuilder's updateAccount method.\n   * The builder is responsible for all transformations and applying logic based on input values.\n   * Omitted optional fields from the LLM mean those properties will not be targeted for update.\n   */\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof UpdateAccountZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).updateAccount(\n      specificArgs as unknown as UpdateAccountParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { DeleteAccountParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst DeleteAccountZodSchemaCore = z.object({\n  deleteAccountId: z\n    .string()\n    .describe(\n      'The ID of the account to be deleted (e.g., \"0.0.xxxx\"). This account must sign.'\n    ),\n  transferAccountId: z\n    .string()\n    .describe(\n      'The ID of the account to transfer the remaining HBAR balance to (e.g., \"0.0.yyyy\").'\n    ),\n});\n\nexport class HederaDeleteAccountTool extends BaseHederaTransactionTool<\n  typeof DeleteAccountZodSchemaCore\n> {\n  name = 'hedera-account-delete';\n  description =\n    'Deletes an account, transferring its HBAR balance to another account.';\n  specificInputSchema = DeleteAccountZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DeleteAccountZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).deleteAccount(\n      specificArgs as unknown as DeleteAccountParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { ApproveHbarAllowanceParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst ApproveHbarAllowanceZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The HBAR owner account ID (e.g., \"0.0.xxxx\"). Defaults to operator if not provided.'\n    ),\n  spenderAccountId: z\n    .string()\n    .describe(\n      'The spender account ID being granted the allowance (e.g., \"0.0.yyyy\").'\n    ),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'Max HBAR amount spender can use (in HBARs). Builder handles Hbar object creation.'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaApproveHbarAllowanceTool extends BaseHederaTransactionTool<\n  typeof ApproveHbarAllowanceZodSchemaCore\n> {\n  name = 'hedera-account-approve-hbar-allowance';\n  description =\n    'Approves an HBAR allowance for a spender. Builder handles Hbar unit conversion.';\n  specificInputSchema = ApproveHbarAllowanceZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof ApproveHbarAllowanceZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).approveHbarAllowance(\n      specificArgs as unknown as ApproveHbarAllowanceParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { ApproveFungibleTokenAllowanceParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst ApproveFungibleTokenAllowanceZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The token owner account ID (e.g., \"0.0.xxxx\"). Defaults to operator.'\n    ),\n  spenderAccountId: z\n    .string()\n    .describe('The spender account ID (e.g., \"0.0.yyyy\").'),\n  tokenId: z.string().describe('The fungible token ID (e.g., \"0.0.zzzz\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'Max token amount (smallest unit) spender can use. Builder handles conversion.'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaApproveFungibleTokenAllowanceTool extends BaseHederaTransactionTool<\n  typeof ApproveFungibleTokenAllowanceZodSchemaCore\n> {\n  name = 'hedera-account-approve-fungible-token-allowance';\n  description =\n    'Approves a fungible token allowance for a spender. Builder handles amount conversion.';\n  specificInputSchema = ApproveFungibleTokenAllowanceZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof ApproveFungibleTokenAllowanceZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).approveFungibleTokenAllowance(\n      specificArgs as unknown as ApproveFungibleTokenAllowanceParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { ApproveTokenNftAllowanceParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst ApproveTokenNftAllowanceZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The NFT owner account ID (e.g., \"0.0.xxxx\"). Defaults to operator.'\n    ),\n  spenderAccountId: z\n    .string()\n    .describe('The spender account ID (e.g., \"0.0.yyyy\").'),\n  tokenId: z.string().describe('The NFT collection ID (e.g., \"0.0.zzzz\").'),\n  serials: z\n    .array(z.union([z.number().int().positive(), z.string()]))\n    .optional()\n    .describe(\n      'Optional. Specific serial numbers to approve. Use this OR allSerials. Builder handles conversion.'\n    ),\n  allSerials: z\n    .boolean()\n    .optional()\n    .describe(\n      'Optional. If true, approves spender for all serials of the NFT ID. Use this OR serials.'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaApproveTokenNftAllowanceTool extends BaseHederaTransactionTool<\n  typeof ApproveTokenNftAllowanceZodSchemaCore\n> {\n  name = 'hedera-account-approve-nft-allowance';\n  description =\n    'Approves an NFT allowance. Builder validates serials/allSerials logic and handles serial conversion.';\n  specificInputSchema = ApproveTokenNftAllowanceZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof ApproveTokenNftAllowanceZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).approveTokenNftAllowance(\n      specificArgs as unknown as ApproveTokenNftAllowanceParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { RevokeHbarAllowanceParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst RevokeHbarAllowanceZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The HBAR owner account ID (e.g., \"0.0.xxxx\"). Defaults to operator.'\n    ),\n  spenderAccountId: z\n    .string()\n    .describe(\n      'The spender account ID whose HBAR allowance is to be revoked (e.g., \"0.0.yyyy\").'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaRevokeHbarAllowanceTool extends BaseHederaTransactionTool<\n  typeof RevokeHbarAllowanceZodSchemaCore\n> {\n  name = 'hedera-account-revoke-hbar-allowance';\n  description =\n    'Revokes/clears an HBAR allowance for a specific spender by approving zero HBAR.';\n  specificInputSchema = RevokeHbarAllowanceZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof RevokeHbarAllowanceZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).revokeHbarAllowance(\n      specificArgs as unknown as RevokeHbarAllowanceParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { RevokeFungibleTokenAllowanceParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\n\nconst RevokeFungibleTokenAllowanceZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The token owner account ID (e.g., \"0.0.xxxx\"). Defaults to operator.'\n    ),\n  spenderAccountId: z\n    .string()\n    .describe(\n      'The spender account ID whose token allowance is to be revoked (e.g., \"0.0.yyyy\").'\n    ),\n  tokenId: z\n    .string()\n    .describe('The ID of the fungible token (e.g., \"0.0.zzzz\").'),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaRevokeFungibleTokenAllowanceTool extends BaseHederaTransactionTool<\n  typeof RevokeFungibleTokenAllowanceZodSchemaCore\n> {\n  name = 'hedera-account-revoke-fungible-token-allowance';\n  description =\n    'Revokes/clears a fungible token allowance for a specific spender by approving zero amount.';\n  specificInputSchema = RevokeFungibleTokenAllowanceZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof RevokeFungibleTokenAllowanceZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).revokeFungibleTokenAllowance(\n      specificArgs as unknown as RevokeFungibleTokenAllowanceParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { DeleteNftSpenderAllowanceToolParams } from '../../../types';\n\nconst DeleteNftSpenderAllowanceZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The ID of the NFT owner. Defaults to the operator/signer if not provided.'\n    ),\n  spenderAccountId: z\n    .string()\n    .describe(\n      'The ID of the spender whose allowance for specific NFTs will be deleted.'\n    ),\n\n  nftIdString: z\n    .string()\n    .describe(\n      'The NFT ID including serial number (e.g., \"0.0.token.serial\") for which the allowance will be deleted.'\n    ),\n\n  tokenId: z\n    .string()\n    .describe('The token ID of the NFT collection (e.g., \"0.0.xxxx\").'),\n  serials: z\n    .array(z.union([z.number().int().positive(), z.string()]))\n    .min(1)\n    .describe('An array of serial numbers of the NFT to remove allowance for.'),\n});\n\nexport class HederaDeleteNftSpenderAllowanceTool extends BaseHederaTransactionTool<\n  typeof DeleteNftSpenderAllowanceZodSchemaCore\n> {\n  name = 'hedera-account-delete-nft-spender-allowance';\n  description =\n    'Deletes/revokes NFT allowances for specific serial numbers of a token for a specific spender. The owner of the NFTs must sign.';\n  specificInputSchema = DeleteNftSpenderAllowanceZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DeleteNftSpenderAllowanceZodSchemaCore>\n  ): Promise<void> {\n    await (builder as AccountBuilder).deleteTokenNftAllowanceForSpender(\n      specificArgs as unknown as DeleteNftSpenderAllowanceToolParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\n\nconst DeleteNftSerialAllowancesZodSchemaCore = z.object({\n  ownerAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. The ID of the NFT owner. Defaults to the operator/signer if not provided.'\n    ),\n  nftIdString: z\n    .string()\n    .describe(\n      'The specific NFT ID including serial number (e.g., \"0.0.token.serial\") for which all spender allowances will be deleted.'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaDeleteNftSerialAllowancesTool extends BaseHederaTransactionTool<\n  typeof DeleteNftSerialAllowancesZodSchemaCore\n> {\n  name = 'hedera-account-delete-nft-serial-allowances-for-all-spenders';\n  description =\n    'Deletes all allowances for a specific NFT serial (for all spenders), granted by an owner. This action must be signed by the NFT owner.';\n  specificInputSchema = DeleteNftSerialAllowancesZodSchemaCore;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DeleteNftSerialAllowancesZodSchemaCore>\n  ): Promise<void> {\n    // Note: Type cast necessary due to interface mismatch between Zod schema and builder params\n    await (builder as AccountBuilder).deleteNftSerialAllowancesForAllSpenders(\n      specificArgs as unknown as Parameters<AccountBuilder['deleteNftSerialAllowancesForAllSpenders']>[0]\n    );\n  }\n}\n","import { StructuredTool, ToolParams } from '@langchain/core/tools';\nimport { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { z } from 'zod';\nimport { HederaAgentKit } from '../../../agent/agent';\nimport { ModelCapabilityDetector } from '../../../utils/model-capability-detector';\nimport { ModelCapability } from '../../../types/model-capability';\nimport { Logger } from '../../../utils/logger';\n\n/**\n * Field processing configuration\n */\nexport interface FieldProcessor {\n  maxLength?: number;\n  truncateMessage?: string;\n  summarize?: boolean;\n  exclude?: boolean;\n}\n\n/**\n * Response processing strategy\n */\nexport interface ResponseStrategy {\n  maxTokens: number;\n  summarizeArrays?: boolean;\n  maxArrayLength?: number;\n  includeMetadata?: boolean;\n}\n\n/**\n * Model-specific response strategies\n */\nconst MODEL_STRATEGIES: Record<ModelCapability, ResponseStrategy> = {\n  [ModelCapability.SMALL]: {\n    maxTokens: 4000,\n    summarizeArrays: true,\n    maxArrayLength: 3,\n    includeMetadata: true,\n  },\n  [ModelCapability.MEDIUM]: {\n    maxTokens: 12000,\n    summarizeArrays: false,\n    maxArrayLength: 10,\n    includeMetadata: true,\n  },\n  [ModelCapability.LARGE]: {\n    maxTokens: 32000,\n    summarizeArrays: false,\n    maxArrayLength: 50,\n    includeMetadata: false,\n  },\n  [ModelCapability.UNLIMITED]: {\n    maxTokens: Infinity,\n    summarizeArrays: false,\n    includeMetadata: false,\n  },\n};\n\n/**\n * Parameters required to initialize a BaseHederaQueryTool.\n */\nexport interface BaseHederaQueryToolParams extends ToolParams {\n  hederaKit: HederaAgentKit;\n  logger?: Logger;\n  modelCapability?: ModelCapability;\n  customStrategy?: Partial<ResponseStrategy>;\n}\n\n/**\n * Base class for all Hedera query tools.\n * Handles common query processing logic across different tool types.\n * Unlike transaction tools, query tools are read-only and don't require signing.\n *\n * @template S - The Zod schema that defines the input parameters for the specific tool\n */\nexport abstract class BaseHederaQueryTool<\n  //@ts-ignore\n  S extends z.ZodObject<unknown, unknown, unknown, unknown>\n  //@ts-ignore\n> extends StructuredTool<S> {\n  protected hederaKit: HederaAgentKit;\n  protected logger: Logger;\n  protected responseStrategy: ResponseStrategy;\n  protected modelCapability: ModelCapability;\n  private notes: string[] = [];\n\n  abstract specificInputSchema: S;\n  abstract namespace: string;\n\n  get schema(): S {\n    return this.specificInputSchema;\n  }\n\n  constructor({\n    hederaKit,\n    logger,\n    modelCapability = ModelCapability.MEDIUM,\n    customStrategy,\n    ...rest\n  }: BaseHederaQueryToolParams) {\n    super(rest);\n    this.hederaKit = hederaKit;\n    this.logger = logger || hederaKit.logger;\n    this.modelCapability = modelCapability;\n\n    const baseStrategy = MODEL_STRATEGIES[modelCapability];\n    this.responseStrategy = { ...baseStrategy, ...customStrategy };\n\n    this.logger.debug(\n      `Initialized query tool with ${modelCapability} capability strategy`\n    );\n  }\n\n  /**\n   * Execute the specific query operation.\n   * This method should be implemented by concrete query tools.\n   */\n  protected abstract executeQuery(\n    args: z.infer<S>,\n    runManager?: CallbackManagerForToolRun\n  ): Promise<unknown>;\n\n  /**\n   * Tools can define which fields should be processed for size optimization.\n   * Return a map of field paths to processing configurations.\n   * Field paths support dot notation (e.g., 'contract.bytecode') and wildcards (e.g., '*.bytecode')\n   */\n  protected getLargeFieldProcessors?(\n    args: z.infer<S>\n  ): Record<string, FieldProcessor>;\n\n  /**\n   * Allow tools to define custom response processing logic\n   */\n  protected processCustomResponse?(result: unknown, args: z.infer<S>): unknown;\n\n  /**\n   * Estimate token count (rough approximation: 1 token ≈ 4 characters)\n   */\n  private estimateTokens(text: string): number {\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Check if a field path matches a pattern (supports wildcards)\n   */\n  private matchesPattern(fieldPath: string, pattern: string): boolean {\n    if (pattern === fieldPath) return true;\n    if (pattern.includes('*')) {\n      const regex = new RegExp('^' + pattern.replace(/\\*/g, '[^.]*') + '$');\n      return regex.test(fieldPath);\n    }\n    return false;\n  }\n\n  /**\n   * Process any data structure based on field processors and strategy\n   */\n  private processData(\n    data: unknown,\n    args: z.infer<S>,\n    path: string = ''\n  ): unknown {\n    if (this.responseStrategy.maxTokens === Infinity) {\n      return data;\n    }\n\n    const processors = this.getLargeFieldProcessors\n      ? this.getLargeFieldProcessors(args)\n      : {};\n\n    if (data === null || data === undefined) {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return this.processArray(data, args, path);\n    }\n\n    if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n      return this.processObject(\n        data as Record<string, unknown>,\n        args,\n        path,\n        processors\n      );\n    }\n\n    if (typeof data === 'string') {\n      return this.processString(data, path, processors);\n    }\n\n    return data;\n  }\n\n  /**\n   * Process array data\n   */\n  private processArray(\n    arr: unknown[],\n    args: z.infer<S>,\n    path: string\n  ): unknown[] {\n    const processedArray = arr.map((item, index) =>\n      this.processData(item, args, `${path}[${index}]`)\n    );\n\n    if (\n      this.responseStrategy.summarizeArrays &&\n      this.responseStrategy.maxArrayLength &&\n      arr.length > this.responseStrategy.maxArrayLength\n    ) {\n      const maxLength = this.responseStrategy.maxArrayLength;\n      const takeFirst = Math.floor(maxLength / 2);\n      const takeLast = maxLength - takeFirst - 1;\n\n      return [\n        ...processedArray.slice(0, takeFirst),\n        {\n          _summary: `[${arr.length - maxLength} items truncated]`,\n          _originalLength: arr.length,\n          _truncatedAt: path,\n        },\n        ...processedArray.slice(-takeLast),\n      ];\n    }\n\n    return processedArray;\n  }\n\n  /**\n   * Process object data\n   */\n  private processObject(\n    obj: Record<string, unknown>,\n    args: z.infer<S>,\n    path: string,\n    processors: Record<string, FieldProcessor>\n  ): Record<string, unknown> {\n    const result: Record<string, unknown> = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      const fieldPath = path ? `${path}.${key}` : key;\n\n      const matchingEntry = Object.entries(processors).find(([pattern]) =>\n        this.matchesPattern(fieldPath, pattern)\n      );\n      const matchingProcessor = matchingEntry ? matchingEntry[1] : undefined;\n\n      if (matchingProcessor && matchingProcessor.exclude) {\n        continue;\n      }\n\n      result[key] = this.processData(value, args, fieldPath);\n    }\n\n    return result;\n  }\n\n  /**\n   * Process string data\n   */\n  private processString(\n    str: string,\n    path: string,\n    processors: Record<string, FieldProcessor>\n  ): string {\n    const matchingEntry = Object.entries(processors).find(([pattern]) =>\n      this.matchesPattern(path, pattern)\n    );\n    const matchingProcessor = matchingEntry ? matchingEntry[1] : undefined;\n\n    if (\n      matchingProcessor &&\n      matchingProcessor.maxLength &&\n      str.length > matchingProcessor.maxLength\n    ) {\n      const truncated = str.substring(0, matchingProcessor.maxLength);\n      const message = matchingProcessor.truncateMessage\n        ? matchingProcessor.truncateMessage\n        : `[TRUNCATED: ${str.length} chars total]`;\n      return `${truncated}...${message}`;\n    }\n\n    return str;\n  }\n\n  /**\n   * Format the query result for return to the LLM.\n   * Override this method to customize result formatting.\n   */\n  protected formatResult(result: unknown, args?: z.infer<S>): string {\n    if (typeof result === 'string') {\n      return result;\n    }\n\n    let processedResult = result;\n\n    if (this.processCustomResponse && args) {\n      processedResult = this.processCustomResponse(processedResult, args);\n    }\n\n    processedResult = this.processData(\n      processedResult,\n      args || ({} as z.infer<S>)\n    );\n\n    const jsonString = JSON.stringify(processedResult, null, 2);\n    const estimatedTokens = this.estimateTokens(jsonString);\n\n    if (\n      this.responseStrategy.includeMetadata &&\n      estimatedTokens > this.responseStrategy.maxTokens * 0.8\n    ) {\n      const responseWithMeta = {\n        ...(typeof processedResult === 'object' && processedResult !== null\n          ? processedResult\n          : { data: processedResult }),\n        _meta: {\n          estimatedTokens,\n          maxTokens: this.responseStrategy.maxTokens,\n          capability: Object.keys(MODEL_STRATEGIES).find(\n            (key) =>\n              MODEL_STRATEGIES[key as ModelCapability] === this.responseStrategy\n          ),\n          note: 'Response may be truncated. Use higher model capability for full data.',\n        },\n      };\n      return JSON.stringify(responseWithMeta, null, 2);\n    }\n\n    return jsonString;\n  }\n\n  /**\n   * Handle errors that occur during query execution.\n   */\n  protected handleError(error: unknown): string {\n    const errorMessage =\n      error instanceof Error ? error.message : JSON.stringify(error);\n    this.logger.error(`Error in query tool: ${errorMessage}`, error);\n    return JSON.stringify({\n      success: false,\n      error: errorMessage,\n    });\n  }\n\n  /**\n   * Main method called when the tool is executed.\n   * Processes arguments, executes the query, and formats the result.\n   */\n  protected async _call(\n    args: z.infer<S>,\n    runManager?: CallbackManagerForToolRun\n  ): Promise<string> {\n    this.clearNotes();\n\n    try {\n      this.logger.info(\n        `Executing ${this.name} with model capability: ${this.modelCapability}`\n      );\n\n      const rawData = await this.executeQuery(args, runManager);\n      const processed = await this.processLargeFields(rawData, args);\n\n      const allNotes = this.getNotes();\n\n      if (\n        typeof processed.data === 'object' &&\n        processed.data !== null &&\n        'success' in processed.data\n      ) {\n        const toolResponse = processed.data as Record<string, unknown> & {\n          success: unknown;\n          notes?: string[];\n        };\n        const response = {\n          ...toolResponse,\n          ...(allNotes.length > 0 && {\n            notes: [...(toolResponse.notes || []), ...allNotes],\n          }),\n        };\n        return JSON.stringify(response);\n      }\n\n      const response = {\n        success: true,\n        data: processed.data,\n        ...(allNotes.length > 0 && { notes: allNotes }),\n      };\n\n      return JSON.stringify(response);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      this.logger.error(`Error in ${this.name}: ${errorMessage}`, error);\n\n      const allNotes = this.getNotes();\n      return JSON.stringify({\n        success: false,\n        error: errorMessage,\n        ...(allNotes.length > 0 && { notes: allNotes }),\n      });\n    }\n  }\n\n  private async getModelCapabilityLimits(): Promise<{\n    maxTokens: number;\n    arrayLimit: number;\n  }> {\n    if (this.modelCapability === ModelCapability.UNLIMITED) {\n      return { maxTokens: Infinity, arrayLimit: Infinity };\n    }\n\n    try {\n      const detector = ModelCapabilityDetector.getInstance();\n\n      if (this.hederaKit.modelName) {\n        const contextWindow = await detector.getContextWindow(\n          this.hederaKit.modelName\n        );\n        if (contextWindow > 0) {\n          const toolDefinitionsReserve = Math.floor(contextWindow * 0.6);\n          const responseReserve = Math.floor(contextWindow * 0.2);\n          const availableTokens =\n            contextWindow - toolDefinitionsReserve - responseReserve;\n          const arrayLimit = this.calculateArrayLimit(availableTokens);\n\n          return {\n            maxTokens: Math.max(availableTokens, 1000),\n            arrayLimit,\n          };\n        }\n      }\n\n      const allModels = await detector.getAllModels();\n      let maxContextWindow = 0;\n      for (const [, config] of Object.entries(allModels)) {\n        if (\n          config.capability === this.modelCapability &&\n          config.contextWindow > maxContextWindow\n        ) {\n          maxContextWindow = config.contextWindow;\n        }\n      }\n\n      if (maxContextWindow > 0) {\n        const toolDefinitionsReserve = Math.floor(maxContextWindow * 0.6);\n        const responseReserve = Math.floor(maxContextWindow * 0.2);\n        const availableTokens =\n          maxContextWindow - toolDefinitionsReserve - responseReserve;\n        const arrayLimit = this.calculateArrayLimit(availableTokens);\n\n        return {\n          maxTokens: Math.max(availableTokens, 1000),\n          arrayLimit,\n        };\n      }\n    } catch (error) {\n      this.logger.warn(\n        'Failed to get model context window, using fallback limits',\n        error\n      );\n    }\n\n    switch (this.modelCapability) {\n      case ModelCapability.SMALL:\n        return { maxTokens: 1000, arrayLimit: 3 };\n      case ModelCapability.MEDIUM:\n        return { maxTokens: 4000, arrayLimit: 10 };\n      case ModelCapability.LARGE:\n        return { maxTokens: 12000, arrayLimit: 30 };\n      default:\n        return { maxTokens: 4000, arrayLimit: 10 };\n    }\n  }\n\n  private calculateArrayLimit(availableTokens: number): number {\n    if (availableTokens < 8000) {\n      return 5;\n    }\n    if (availableTokens < 50000) {\n      return 20;\n    }\n    if (availableTokens < 100000) {\n      return 50;\n    }\n    return 100;\n  }\n\n  private addNote(note: string): void {\n    this.notes.push(note);\n  }\n\n  private clearNotes(): void {\n    this.notes = [];\n  }\n\n  private getNotes(): string[] {\n    return [...this.notes];\n  }\n\n  private async processLargeFields(\n    data: unknown,\n    args?: z.infer<S>\n  ): Promise<{ data: unknown; notes: string[] }> {\n    const result: { data: unknown; notes: string[] } = {\n      data: JSON.parse(JSON.stringify(data)),\n      notes: [],\n    };\n\n    if (this.modelCapability === ModelCapability.UNLIMITED) {\n      return result;\n    }\n\n    const processors =\n      this.getLargeFieldProcessors && args\n        ? this.getLargeFieldProcessors(args)\n        : {};\n    const limits = await this.getModelCapabilityLimits();\n\n    for (const [path, processorConfig] of Object.entries(processors)) {\n      const value = this.getNestedValue(result.data, path);\n      if (\n        typeof value === 'string' &&\n        processorConfig.maxLength &&\n        value.length > processorConfig.maxLength\n      ) {\n        const truncated = value.substring(0, processorConfig.maxLength);\n        this.setNestedValue(result.data, path, truncated);\n\n        const userFriendlyMessage = processorConfig.truncateMessage\n          ? processorConfig.truncateMessage\n          : `Large data field was shortened to fit your model's capacity`;\n        this.addNote(\n          `${userFriendlyMessage}. Original size: ${value.length} characters, shown: ${processorConfig.maxLength} characters.`\n        );\n      }\n    }\n\n    result.data = this.processDataStructure(result.data, limits, result.notes);\n    return result;\n  }\n\n  private processDataStructure(\n    data: unknown,\n    limits: { maxTokens: number; arrayLimit: number },\n    notes: string[]\n  ): unknown {\n    if (Array.isArray(data)) {\n      if (data.length > limits.arrayLimit) {\n        const truncated = data.slice(0, limits.arrayLimit);\n        this.addNote(\n          `List was shortened to fit your model's capacity. Showing ${limits.arrayLimit} of ${data.length} items.`\n        );\n        return truncated.map((item) =>\n          this.processDataStructure(item, limits, notes)\n        );\n      }\n      return data.map((item) => this.processDataStructure(item, limits, notes));\n    }\n\n    if (data && typeof data === 'object' && !Array.isArray(data)) {\n      const processed: Record<string, unknown> = {};\n      for (const [key, value] of Object.entries(\n        data as Record<string, unknown>\n      )) {\n        processed[key] = this.processDataStructure(value, limits, notes);\n      }\n      return processed;\n    }\n\n    return data;\n  }\n\n  private getNestedValue(obj: unknown, path: string): unknown {\n    return path.split('.').reduce((current, key) => {\n      if (!current || typeof current !== 'object') {\n        return undefined;\n      }\n\n      const currentObj = current as Record<string, unknown>;\n\n      if (key.includes('[') && key.includes(']')) {\n        const [arrayKey, indexStr] = key.split('[');\n        const index = parseInt(indexStr.replace(']', ''));\n        const arrayValue = currentObj[arrayKey];\n        return Array.isArray(arrayValue) ? arrayValue[index] : undefined;\n      }\n\n      return currentObj[key];\n    }, obj);\n  }\n\n  private setNestedValue(obj: unknown, path: string, value: unknown): void {\n    if (!obj || typeof obj !== 'object') {\n      return;\n    }\n\n    const keys = path.split('.');\n    const lastKey = keys.pop()!;\n    const target = keys.reduce((current, key) => {\n      if (!current || typeof current !== 'object') {\n        return current;\n      }\n\n      const currentObj = current as Record<string, unknown>;\n\n      if (key.includes('[') && key.includes(']')) {\n        const [arrayKey, indexStr] = key.split('[');\n        const index = parseInt(indexStr.replace(']', ''));\n        const arrayValue = currentObj[arrayKey];\n        return Array.isArray(arrayValue) ? arrayValue[index] : undefined;\n      }\n\n      return currentObj[key];\n    }, obj);\n\n    if (!target || typeof target !== 'object') {\n      return;\n    }\n\n    const targetObj = target as Record<string, unknown>;\n\n    if (lastKey.includes('[') && lastKey.includes(']')) {\n      const [arrayKey, indexStr] = lastKey.split('[');\n      const index = parseInt(indexStr.replace(']', ''));\n      const arrayValue = targetObj[arrayKey];\n      if (Array.isArray(arrayValue)) {\n        arrayValue[index] = value;\n      }\n    } else {\n      targetObj[lastKey] = value;\n    }\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetOutstandingAirdropsZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID that sent the airdrops (e.g., \"0.0.123\")'),\n  limit: z.number().optional().describe('Maximum number of airdrops to return'),\n  order: z.enum(['asc', 'desc']).optional().describe('Order of results'),\n  receiverId: z.string().optional().describe('Filter by receiver account ID'),\n  serialNumber: z.string().optional().describe('Filter by NFT serial number'),\n  tokenId: z.string().optional().describe('Filter by token ID'),\n});\n\n/**\n * Tool for retrieving outstanding token airdrops sent by an account.\n */\nexport class HederaGetOutstandingAirdropsTool extends BaseHederaQueryTool<\n  typeof GetOutstandingAirdropsZodSchema\n> {\n  name = 'hedera-get-outstanding-airdrops';\n  description =\n    'Retrieves outstanding token airdrops that have been sent by an account but not yet claimed.';\n  specificInputSchema = GetOutstandingAirdropsZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetOutstandingAirdropsZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(\n      `Getting outstanding airdrops for account: ${args.accountId}`\n    );\n\n    const airdrops = await this.hederaKit\n      .query()\n      .getOutstandingTokenAirdrops(args);\n\n    if (airdrops === null) {\n      return {\n        success: false,\n        error: `Could not retrieve outstanding airdrops for account ${args.accountId}`,\n      };\n    }\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      airdrops,\n      count: airdrops.length,\n    };\n  }\n}\n\n ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetPendingAirdropsZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID that received the airdrops (e.g., \"0.0.123\")'),\n  limit: z\n    .number()\n    .optional()\n    .describe('Maximum number of airdrops to return'),\n  order: z\n    .enum(['asc', 'desc'])\n    .optional()\n    .describe('Order of results'),\n  senderId: z\n    .string()\n    .optional()\n    .describe('Filter by sender account ID'),\n  serialNumber: z\n    .string()\n    .optional()\n    .describe('Filter by NFT serial number'),\n  tokenId: z\n    .string()\n    .optional()\n    .describe('Filter by token ID'),\n});\n\n/**\n * Tool for retrieving pending token airdrops received by an account.\n */\nexport class HederaGetPendingAirdropsTool extends BaseHederaQueryTool<\n  typeof GetPendingAirdropsZodSchema\n> {\n  name = 'hedera-get-pending-airdrops';\n  description =\n    'Retrieves pending token airdrops that have been received by an account but not yet claimed.';\n  specificInputSchema = GetPendingAirdropsZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetPendingAirdropsZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting pending airdrops for account: ${args.accountId}`);\n\n    const airdrops = await this.hederaKit\n      .query()\n      .getPendingTokenAirdrops(args);\n\n    if (!airdrops) {\n      return {\n        success: false,\n        error: `Could not retrieve pending airdrops for account ${args.accountId}`,\n      };\n    }\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      airdrops,\n      count: airdrops.length,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetAccountBalanceZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to get balance for (e.g., \"0.0.12345\")'),\n});\n\n/**\n * Tool for retrieving Hedera account HBAR balance.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetAccountBalanceTool extends BaseHederaQueryTool<\n  typeof GetAccountBalanceZodSchema\n> {\n  name = 'hedera-get-account-balance';\n  description =\n    'Retrieves the HBAR balance for a Hedera account. Returns the balance in HBAR (not tinybars).';\n  specificInputSchema = GetAccountBalanceZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetAccountBalanceZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting balance for account ID: ${args.accountId}`);\n\n    const balance = await this.hederaKit\n      .query()\n      .getAccountBalance(args.accountId);\n\n    if (balance === null) {\n      return {\n        success: false,\n        error: `Could not retrieve balance for account ${args.accountId}`,\n      };\n    }\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      balance: balance,\n      unit: 'HBAR',\n    };\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetAccountInfoZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to get information for (e.g., \"0.0.12345\")'),\n});\n\n/**\n * Tool for retrieving full Hedera account information.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetAccountInfoTool extends BaseHederaQueryTool<\n  typeof GetAccountInfoZodSchema\n> {\n  name = 'hedera-get-account-info';\n  description =\n    'Retrieves comprehensive information about a Hedera account including balance, key, memo, and other metadata.';\n  specificInputSchema = GetAccountInfoZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetAccountInfoZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting account info for account ID: ${args.accountId}`);\n\n    const accountInfo = await this.hederaKit\n      .query()\n      .getAccountInfo(args.accountId);\n\n    if (!accountInfo) {\n      return {\n        success: false,\n        error: `Account ${args.accountId} not found`,\n      };\n    }\n\n    return {\n      success: true,\n      accountInfo,\n    };\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetAccountNftsZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to get NFTs for (e.g., \"0.0.12345\")'),\n  tokenId: z\n    .string()\n    .optional()\n    .describe('Optional token ID to filter NFTs by (e.g., \"0.0.67890\")'),\n  limit: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .default(100)\n    .describe('Maximum number of NFTs to return (default: 100)'),\n});\n\n/**\n * Tool for retrieving NFTs owned by a Hedera account.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetAccountNftsTool extends BaseHederaQueryTool<\n  typeof GetAccountNftsZodSchema\n> {\n  name = 'hedera-get-account-nfts';\n  description =\n    'Retrieves all NFTs owned by a Hedera account. Optionally filter by token ID.';\n  specificInputSchema = GetAccountNftsZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetAccountNftsZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting NFTs for account ID: ${args.accountId}`);\n    \n    const nfts = await this.hederaKit.query().getAccountNfts(\n      args.accountId,\n      args.tokenId,\n      args.limit\n    );\n    \n    if (!nfts) {\n      return {\n        success: false,\n        error: `Could not retrieve NFTs for account ${args.accountId}`,\n      };\n    }\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      tokenId: args.tokenId,\n      nftCount: nfts.length,\n      nfts,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetAccountPublicKeyZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to get the public key for (e.g., \"0.0.12345\")'),\n});\n\n/**\n * Tool for retrieving a Hedera account's public key.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetAccountPublicKeyTool extends BaseHederaQueryTool<\n  typeof GetAccountPublicKeyZodSchema\n> {\n  name = 'hedera-get-account-public-key';\n  description =\n    'Retrieves the public key for a Hedera account. Returns the public key in string format.';\n  specificInputSchema = GetAccountPublicKeyZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetAccountPublicKeyZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting public key for account ID: ${args.accountId}`);\n    \n    const publicKey = await this.hederaKit.query().getPublicKey(args.accountId);\n    \n    if (!publicKey) {\n      return {\n        success: false,\n        error: `Could not retrieve public key for account ${args.accountId}`,\n      };\n    }\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      publicKey: publicKey.toString(),\n      publicKeyDer: publicKey.toStringDer(),\n      publicKeyRaw: publicKey.toStringRaw(),\n    };\n  }\n} \n ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetAccountTokensZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to get token balances for (e.g., \"0.0.12345\")'),\n  limit: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .default(100)\n    .describe('Maximum number of tokens to return (default: 100)'),\n});\n\n/**\n * Tool for retrieving token balances for a Hedera account.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetAccountTokensTool extends BaseHederaQueryTool<\n  typeof GetAccountTokensZodSchema\n> {\n  name = 'hedera-get-account-tokens';\n  description =\n    'Retrieves all token balances for a Hedera account. Returns fungible and non-fungible token associations.';\n  specificInputSchema = GetAccountTokensZodSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetAccountTokensZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting tokens for account ID: ${args.accountId}`);\n    \n    const tokens = await this.hederaKit.query().getAccountTokens(args.accountId, args.limit);\n    \n    if (!tokens) {\n      return {\n        success: false,\n        error: `Could not retrieve tokens for account ${args.accountId}`,\n      };\n    }\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      tokenCount: tokens.length,\n      tokens,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport { SignScheduledTransactionParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { AccountBuilder } from '../../../builders/account/account-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\n\nconst signAndExecuteScheduledTransactionSchema = z.object({\n  scheduleId: z\n    .string()\n    .describe('The ID of the scheduled transaction (e.g., \"0.0.SCHEDID\").'),\n  memo: z\n    .string()\n    .optional()\n    .describe('Optional memo for the ScheduleSign transaction itself.'),\n});\n\nexport class SignAndExecuteScheduledTransactionTool extends BaseHederaTransactionTool<\n  typeof signAndExecuteScheduledTransactionSchema\n> {\n  name = 'hedera-sign-and-execute-scheduled-transaction';\n  description =\n    'Prepares a ScheduleSignTransaction to add a signature to an existing scheduled transaction. Depending on agent configuration, this will either return transaction bytes (for the user to sign and pay) or be executed directly by the agent (agent signs and pays).';\n  specificInputSchema = signAndExecuteScheduledTransactionSchema;\n  namespace = 'account';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n    this.neverScheduleThisTool = true; // Ensure this tool itself is never scheduled\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.accounts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof signAndExecuteScheduledTransactionSchema>\n  ): Promise<void> {\n    const accountBuilder = builder as AccountBuilder;\n    const params: SignScheduledTransactionParams = {\n      scheduleId: specificArgs.scheduleId,\n    };\n    if (specificArgs.memo && specificArgs.memo.trim() !== '') {\n      params.memo = specificArgs.memo;\n    }\n    await accountBuilder.prepareSignScheduledTransaction(params);\n  }\n}\n","import { z } from 'zod';\nimport { CreateTopicParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { HcsBuilder } from '../../../builders/hcs/hcs-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\n\n/**\n * Zod schema for the input structure of a single custom fee object.\n * This defines the structure the LLM should provide for each custom fee.\n */\nconst CustomFeeObjectSchema = z.object({\n  feeCollectorAccountId: z\n    .string()\n    .describe('The account ID to receive the custom fee.'),\n  denominatingTokenId: z\n    .string()\n    .optional()\n    .describe('The token ID for fee denomination (if not HBAR).'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'The fee amount (smallest unit for tokens, or tinybars for HBAR).'\n    ),\n});\n\nconst CreateTopicZodSchemaCore = z.object({\n  memo: z.string().optional().describe('Optional. Memo for the topic.'),\n  adminKey: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Admin key for the topic (e.g., serialized public key string, or private key string for derivation by builder).'\n    ),\n  submitKey: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Submit key for the topic (e.g., serialized public key string, or private key string for derivation by builder).'\n    ),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe(\n      'Optional. Auto-renewal period in seconds (e.g., 7776000 for 90 days).'\n    ),\n  autoRenewAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Account ID for auto-renewal payments (e.g., \"0.0.xxxx\").'\n    ),\n  feeScheduleKey: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Fee schedule key for the topic (e.g., serialized public key string, or private key string for derivation by builder).'\n    ),\n  customFees: z\n    .array(CustomFeeObjectSchema)\n    .optional()\n    .describe(\n      'Optional. Array of custom fee objects to be applied to the topic.'\n    ),\n  exemptAccountIds: z\n    .array(z.string())\n    .optional()\n    .describe('Optional. Account IDs exempt from custom fees.'),\n});\n\nexport class HederaCreateTopicTool extends BaseHederaTransactionTool<\n  typeof CreateTopicZodSchemaCore\n> {\n  name = 'hedera-hcs-create-topic';\n  description =\n    'Creates a new Hedera Consensus Service (HCS) topic. Provide parameters as needed. The builder handles defaults and key parsing.';\n  specificInputSchema = CreateTopicZodSchemaCore;\n  namespace = 'hcs';\n\n  /**\n   *  Topic Creation cannot be scheduled yet.\n   */\n  protected override neverScheduleThisTool = true;\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hcs();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof CreateTopicZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HcsBuilder).createTopic(\n      specificArgs as unknown as CreateTopicParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { SubmitMessageParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { HcsBuilder } from '../../../builders/hcs/hcs-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\n\nconst SubmitMessageZodSchemaCore = z.object({\n  topicId: z.string().describe('The ID of the topic (e.g., \"0.0.xxxx\").'),\n  message: z\n    .string()\n    .describe(\n      'The message content. For binary data, provide as a base64 encoded string; the builder handles decoding.'\n    ),\n  maxChunks: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe(\n      'Optional. Maximum number of chunks for messages exceeding single transaction limits. Builder handles chunking.'\n    ),\n  chunkSize: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe(\n      'Optional. Size of each chunk in bytes if chunking is performed. Builder applies default if needed.'\n    ),\n  submitKey: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Submit key if required by the topic and different from the operator (e.g., serialized public key string, or private key string for derivation by builder).'\n    ),\n});\n\nexport class HederaSubmitMessageTool extends BaseHederaTransactionTool<\n  typeof SubmitMessageZodSchemaCore\n> {\n  name = 'hedera-hcs-submit-message';\n  description =\n    'Submits a message to a Hedera Consensus Service (HCS) topic. The builder handles chunking and base64 decoding for binary messages.';\n  specificInputSchema = SubmitMessageZodSchemaCore;\n  namespace = 'hcs';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hcs();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof SubmitMessageZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HcsBuilder).submitMessageToTopic(\n      specificArgs as unknown as SubmitMessageParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { DeleteTopicParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { HcsBuilder } from '../../../builders/hcs/hcs-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\n\nconst DeleteTopicZodSchemaCore = z.object({\n  topicId: z\n    .string()\n    .describe('The ID of the topic to be deleted (e.g., \"0.0.xxxx\").'),\n});\n\nexport class HederaDeleteTopicTool extends BaseHederaTransactionTool<\n  typeof DeleteTopicZodSchemaCore\n> {\n  name = 'hedera-hcs-delete-topic';\n  description = 'Deletes an HCS topic. Requires topicId.';\n  specificInputSchema = DeleteTopicZodSchemaCore;\n  namespace = 'hcs';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hcs();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DeleteTopicZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HcsBuilder).deleteTopic(\n      specificArgs as unknown as DeleteTopicParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { UpdateTopicParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { HcsBuilder } from '../../../builders/hcs/hcs-builder';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\n\nconst UpdateTopicZodSchemaCore = z.object({\n  topicId: z\n    .string()\n    .describe('The ID of the topic to update (e.g., \"0.0.xxxx\").'),\n  memo: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New memo for the topic. Pass null to clear.'),\n  adminKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New admin key (serialized string). Pass null to clear.'\n    ),\n  submitKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New submit key (serialized string). Pass null to clear.'\n    ),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe('Optional. New auto-renewal period in seconds.'),\n  autoRenewAccountId: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New auto-renew account ID. Pass null to clear.'),\n  feeScheduleKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New fee schedule key (serialized string). Pass null to clear.'\n    ),\n  exemptAccountIds: z\n    .array(z.string())\n    .optional()\n    .describe(\n      'Optional. New list of exempt account IDs. An empty array clears all exemptions.'\n    ),\n});\n\nexport class HederaUpdateTopicTool extends BaseHederaTransactionTool<\n  typeof UpdateTopicZodSchemaCore\n> {\n  name = 'hedera-hcs-update-topic';\n  description =\n    'Updates an HCS topic. Requires topicId. Other fields are optional. Null can be used to clear certain fields.';\n  specificInputSchema = UpdateTopicZodSchemaCore;\n  namespace = 'hcs';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hcs();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof UpdateTopicZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HcsBuilder).updateTopic(\n      specificArgs as unknown as UpdateTopicParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetTopicMessagesByFilterZodSchema = z.object({\n  topicId: z\n    .string()\n    .describe('The topic ID to get messages for (e.g., \"0.0.12345\")'),\n  sequenceNumber: z\n    .string()\n    .optional()\n    .describe('Filter by sequence number (e.g., \"gt:10\", \"lte:20\")'),\n  startTime: z\n    .string()\n    .optional()\n    .describe('Filter by start consensus timestamp (e.g., \"1629400000.000000000\")'),\n  endTime: z\n    .string()\n    .optional()\n    .describe('Filter by end consensus timestamp (e.g., \"1629500000.000000000\")'),\n  limit: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe('Maximum number of messages to return'),\n  order: z\n    .enum(['asc', 'desc'])\n    .optional()\n    .describe('Order of messages (ascending or descending)'),\n});\n\n/**\n * Tool for retrieving filtered messages from a Hedera Consensus Service topic.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetTopicMessages extends BaseHederaQueryTool<\n  typeof GetTopicMessagesByFilterZodSchema\n> {\n  name = 'hedera-get-topic-messages-by-filter';\n  description =\n    'Retrieves filtered messages from a Hedera Consensus Service topic with optional filters for sequence number, time range, limit, and order.';\n  specificInputSchema = GetTopicMessagesByFilterZodSchema;\n  namespace = 'hcs';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetTopicMessagesByFilterZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting filtered messages for topic ID: ${args.topicId}`);\n    \n    const options: {\n      sequenceNumber?: string;\n      startTime?: string;\n      endTime?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    } = {};\n\n    if (args.sequenceNumber) options.sequenceNumber = args.sequenceNumber;\n    if (args.startTime) options.startTime = args.startTime;\n    if (args.endTime) options.endTime = args.endTime;\n    if (args.limit) options.limit = args.limit;\n    if (args.order) options.order = args.order;\n\n    const messages = await this.hederaKit.query().getTopicMessagesByFilter(\n      args.topicId,\n      options\n    );\n    \n    if (!messages) {\n      return {\n        success: false,\n        error: `Could not retrieve messages for topic ${args.topicId}`,\n      };\n    }\n\n    return {\n      success: true,\n      topicId: args.topicId,\n      messageCount: messages.length,\n      filters: options,\n      messages,\n    };\n  }\n} ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetTopicInfoZodSchema = z.object({\n  topicId: z\n    .string()\n    .describe('The topic ID to get information for (e.g., \"0.0.12345\")'),\n});\n\n/**\n * Tool for retrieving Hedera Consensus Service topic information.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetTopicInfoTool extends BaseHederaQueryTool<\n  typeof GetTopicInfoZodSchema\n> {\n  name = 'hedera-get-topic-info';\n  description =\n    'Retrieves information about a Hedera Consensus Service topic including admin key, submit key, memo, and other metadata.';\n  specificInputSchema = GetTopicInfoZodSchema;\n  namespace = 'hcs';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetTopicInfoZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting topic info for topic ID: ${args.topicId}`);\n    \n    const topicInfo = await this.hederaKit.query().getTopicInfo(args.topicId);\n    \n    if (!topicInfo) {\n      return {\n        success: false,\n        error: `Topic ${args.topicId} not found`,\n      };\n    }\n\n    return {\n      success: true,\n      topicInfo,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetTopicFeesZodSchema = z.object({\n  topicId: z\n    .string()\n    .describe('The topic ID to get custom fees for (e.g., \"0.0.12345\")'),\n});\n\n/**\n * Tool for retrieving custom fees for a Hedera Consensus Service topic.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetTopicFeesTool extends BaseHederaQueryTool<\n  typeof GetTopicFeesZodSchema\n> {\n  name = 'hedera-get-topic-fees';\n  description =\n    'Retrieves custom fees associated with a Hedera Consensus Service topic.';\n  specificInputSchema = GetTopicFeesZodSchema;\n  namespace = 'hcs';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetTopicFeesZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting custom fees for topic ID: ${args.topicId}`);\n    \n    const fees = await this.hederaKit.query().getTopicFees(args.topicId);\n    \n    if (!fees) {\n      return {\n        success: true,\n        topicId: args.topicId,\n        customFees: null,\n        message: 'No custom fees found for this topic',\n      };\n    }\n\n    return {\n      success: true,\n      topicId: args.topicId,\n      customFees: fees,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport { AirdropTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst AirdropRecipientSchema = z.object({\n  accountId: z.string().describe('Recipient account ID (e.g., \"0.0.xxxx\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe('Amount in smallest unit. Builder handles Long conversion.'),\n});\n\nconst AirdropTokenZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the fungible token to airdrop (e.g., \"0.0.yyyy\").'),\n  recipients: z\n    .array(AirdropRecipientSchema)\n    .min(1)\n    .describe('Array of recipient objects, each with accountId and amount.'),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaAirdropTokenTool extends BaseHederaTransactionTool<\n  typeof AirdropTokenZodSchemaCore\n> {\n  name = 'hedera-hts-airdrop-token';\n  description =\n    'Airdrops fungible tokens to multiple recipients. Builder handles parsing and validation.';\n  specificInputSchema = AirdropTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof AirdropTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).airdropToken(\n      specificArgs as unknown as AirdropTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { AssociateTokensParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst AssociateTokensZodSchemaCore = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to associate tokens with (e.g., \"0.0.xxxx\").'),\n  tokenIds: z\n    .array(z.string().describe('A token ID (e.g., \"0.0.yyyy\").'))\n    .min(1)\n    .describe('An array of one or more token IDs to associate.'),\n});\n\nexport class HederaAssociateTokensTool extends BaseHederaTransactionTool<\n  typeof AssociateTokensZodSchemaCore\n> {\n  name = 'hedera-hts-associate-tokens';\n  description = 'Associates one or more Hedera tokens with an account.';\n  specificInputSchema = AssociateTokensZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof AssociateTokensZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).associateTokens(\n      specificArgs as unknown as AssociateTokensParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { BurnFTParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst BurnFTZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the fungible token (e.g., \"0.0.xxxx\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'Amount to burn (smallest unit). Number or string for large values. Builder handles conversion.'\n    ),\n});\n\nexport class HederaBurnFungibleTokenTool extends BaseHederaTransactionTool<\n  typeof BurnFTZodSchemaCore\n> {\n  name = 'hedera-hts-burn-fungible-token';\n  description = 'Burns fungible tokens. Requires tokenId and amount.';\n  specificInputSchema = BurnFTZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof BurnFTZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).burnFungibleToken(\n      specificArgs as unknown as BurnFTParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { BurnNFTParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst BurnNFTZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the NFT collection (e.g., \"0.0.xxxx\").'),\n  serials: z\n    .array(z.union([z.number().int().positive(), z.string()]))\n    .min(1)\n    .describe(\n      'Array of serial numbers to burn. Numbers or strings for large serials. Builder handles conversion.'\n    ),\n});\n\nexport class HederaBurnNftTool extends BaseHederaTransactionTool<\n  typeof BurnNFTZodSchemaCore\n> {\n  name = 'hedera-hts-burn-nft';\n  description =\n    'Burns Non-Fungible Tokens (NFTs). Requires token ID and an array of serial numbers.';\n  specificInputSchema = BurnNFTZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof BurnNFTZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).burnNonFungibleToken(\n      specificArgs as unknown as BurnNFTParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { ClaimAirdropParams } from '../../../types';\nimport { AccountId, TokenId, Long, PendingAirdropId, NftId } from '@hashgraph/sdk';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst ClaimAirdropZodSchemaCore = z.object({\n  pendingAirdrops: z\n    .array(\n      z.object({\n        senderAccountId: z\n          .string()\n          .describe('The account ID of the sender of the airdrop.'),\n        tokenId: z.string().describe('The token ID of the airdropped token.'),\n        serialNumber: z\n          .union([z.number(), z.string()])\n          .describe(\n            'The serial number for an NFT, or a string/number convertible to Long(0) for fungible token claims (representing the whole pending amount for that FT from that sender).'\n          ),\n      })\n    )\n    .min(1)\n    .max(10)\n    .describe(\n      'An array of pending airdrops to claim. Each object must have senderAccountId, tokenId, and serialNumber. Max 10 entries.'\n    ),\n});\n\nexport class HederaClaimAirdropTool extends BaseHederaTransactionTool<\n  typeof ClaimAirdropZodSchemaCore\n> {\n  name = 'hedera-hts-claim-airdrop';\n  description =\n    'Claims pending airdropped tokens (fungible or NFT serials). Requires an array of airdrop objects, each specifying senderAccountId, tokenId, and serialNumber. Use metaOptions for execution control.';\n  specificInputSchema = ClaimAirdropZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof ClaimAirdropZodSchemaCore>\n  ): Promise<void> {\n    const sdkPendingAirdropIds: PendingAirdropId[] =\n      specificArgs.pendingAirdrops.map((item, index: number) => {\n        const itemNumber = index + 1;\n\n        let serialValue: Long;\n        if (typeof item.serialNumber === 'string') {\n          try {\n            serialValue = Long.fromString(item.serialNumber);\n          } catch (e: unknown) {\n            const error = e as Error;\n            throw new Error(\n              `Pending airdrop item #${itemNumber} serialNumber string ('${item.serialNumber}') is not a valid Long: ${error.message}`\n            );\n          }\n        } else {\n          serialValue = Long.fromNumber(item.serialNumber);\n        }\n\n        try {\n          const senderId = AccountId.fromString(item.senderAccountId);\n          const tokId = TokenId.fromString(item.tokenId);\n          return new PendingAirdropId({\n            senderId,\n            tokenId: tokId,\n            nftId: NftId.fromString(serialValue.toString()),\n          });\n        } catch (e: unknown) {\n          const error = e as Error;\n          throw new Error(\n            `Error constructing PendingAirdropId for item #${itemNumber} (sender: ${item.senderAccountId}, token: ${item.tokenId}, serial: ${item.serialNumber}): ${error.message}`\n          );\n        }\n      });\n\n    const claimParams: ClaimAirdropParams = {\n      pendingAirdropIds: sdkPendingAirdropIds,\n    };\n\n    (builder as HtsBuilder).claimAirdrop(claimParams);\n  }\n}\n","import {\n  CustomFee,\n  AccountId,\n  TokenId,\n  CustomFixedFee,\n  CustomFractionalFee,\n  CustomRoyaltyFee,\n  FeeAssessmentMethod,\n  Long,\n} from '@hashgraph/sdk';\nimport { Logger } from '../../../utils/logger';\n\nexport const SERIALIZED_KEY_DESCRIPTION =\n  'serialized string). Builder handles parsing.';\nexport const FEE_COLLECTOR_DESCRIPTION =\n  \"Fee collector's account ID. Defaults to user's account if in user-centric context and not specified.\";\n\ninterface FeeData {\n  feeCollectorAccountId: string;\n  feeType: 'FIXED_FEE' | 'FRACTIONAL_FEE' | 'ROYALTY_FEE';\n  amount?: string | number;\n  denominatingTokenId?: string;\n  numerator?: number;\n  denominator?: number;\n  minimumAmount?: string | number;\n  maximumAmount?: string | number;\n  assessmentMethod?: 'EXCLUSIVE' | 'INCLUSIVE';\n  netOfTransfers?: boolean;\n  fallbackFee?: {\n    amount: string | number;\n    denominatingTokenId?: string;\n  };\n  allCollectorsAreExempt?: boolean;\n}\n\n/**\n * Parses a JSON string representing an array of custom fee objects into an array of SDK CustomFee instances.\n * @param {string} customFeesJson - The JSON string to parse.\n * @param {StandardsSdkLogger} logger - Logger instance for error/warning logging.\n * @returns {CustomFee[]} An array of SDK CustomFee objects.\n * @throws {Error} If JSON parsing fails or fee data is invalid.\n */\nexport function parseCustomFeesJson(\n  customFeesJson: string,\n  logger: Logger\n): CustomFee[] {\n  let parsedFeesInput: FeeData[];\n  try {\n    parsedFeesInput = JSON.parse(customFeesJson) as FeeData[];\n    if (!Array.isArray(parsedFeesInput)) {\n      throw new Error('customFeesJson did not parse to an array.');\n    }\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Invalid JSON string for customFeesJson:', errorMessage);\n    throw new Error(`Invalid JSON string for customFeesJson: ${errorMessage}`);\n  }\n\n  return parsedFeesInput.map((feeData, index) => {\n    const feeCollectorAccountIdStr = feeData.feeCollectorAccountId;\n    if (\n      !feeCollectorAccountIdStr ||\n      typeof feeCollectorAccountIdStr !== 'string'\n    ) {\n      throw new Error(\n        `Fee #${\n          index + 1\n        }: feeCollectorAccountId is required and must be a string.`\n      );\n    }\n    const feeCollectorAccountId = AccountId.fromString(\n      feeCollectorAccountIdStr\n    );\n\n    let newFee: CustomFee;\n\n    switch (feeData.feeType) {\n      case 'FIXED_FEE':\n        const fixedFee = new CustomFixedFee().setFeeCollectorAccountId(\n          feeCollectorAccountId\n        );\n        if (feeData.denominatingTokenId) {\n          fixedFee.setDenominatingTokenId(\n            TokenId.fromString(feeData.denominatingTokenId)\n          );\n        }\n        if (feeData.amount === undefined || feeData.amount === null) {\n          throw new Error(`Fee #${index + 1} (FIXED_FEE): amount is required.`);\n        }\n        fixedFee.setAmount(\n          typeof feeData.amount === 'string'\n            ? Long.fromString(feeData.amount)\n            : Long.fromNumber(feeData.amount)\n        );\n        newFee = fixedFee;\n        break;\n\n      case 'FRACTIONAL_FEE':\n        if (\n          feeData.numerator === undefined ||\n          feeData.denominator === undefined\n        ) {\n          throw new Error(\n            `Fee #${\n              index + 1\n            } (FRACTIONAL_FEE): numerator and denominator are required.`\n          );\n        }\n        const fractionalFee = new CustomFractionalFee()\n          .setFeeCollectorAccountId(feeCollectorAccountId)\n          .setNumerator(Long.fromValue(feeData.numerator))\n          .setDenominator(Long.fromValue(feeData.denominator));\n        if (feeData.minimumAmount) {\n          fractionalFee.setMin(\n            typeof feeData.minimumAmount === 'string'\n              ? Long.fromString(feeData.minimumAmount)\n              : Long.fromNumber(feeData.minimumAmount)\n          );\n        }\n        if (feeData.maximumAmount) {\n          fractionalFee.setMax(\n            typeof feeData.maximumAmount === 'string'\n              ? Long.fromString(feeData.maximumAmount)\n              : Long.fromNumber(feeData.maximumAmount)\n          );\n        }\n        if (\n          feeData.assessmentMethod === 'EXCLUSIVE' ||\n          feeData.netOfTransfers === true\n        ) {\n          fractionalFee.setAssessmentMethod(FeeAssessmentMethod.Exclusive);\n        } else {\n          fractionalFee.setAssessmentMethod(FeeAssessmentMethod.Inclusive);\n        }\n        newFee = fractionalFee;\n        break;\n\n      case 'ROYALTY_FEE':\n        if (\n          feeData.numerator === undefined ||\n          feeData.denominator === undefined\n        ) {\n          throw new Error(\n            `Fee #${\n              index + 1\n            } (ROYALTY_FEE): numerator and denominator are required.`\n          );\n        }\n        const royaltyFee = new CustomRoyaltyFee()\n          .setFeeCollectorAccountId(feeCollectorAccountId)\n          .setNumerator(Long.fromValue(feeData.numerator))\n          .setDenominator(Long.fromValue(feeData.denominator));\n        if (feeData.fallbackFee) {\n          if (\n            typeof feeData.fallbackFee !== 'object' ||\n            feeData.fallbackFee === null\n          ) {\n            throw new Error(\n              `Fee #${\n                index + 1\n              } (ROYALTY_FEE): fallbackFee must be an object if provided.`\n            );\n          }\n          const fallback = new CustomFixedFee().setFeeCollectorAccountId(\n            feeCollectorAccountId\n          );\n          if (feeData.fallbackFee.denominatingTokenId) {\n            fallback.setDenominatingTokenId(\n              TokenId.fromString(feeData.fallbackFee.denominatingTokenId)\n            );\n          }\n          if (\n            feeData.fallbackFee.amount === undefined ||\n            feeData.fallbackFee.amount === null\n          ) {\n            throw new Error(\n              `Fee #${index + 1} (ROYALTY_FEE): fallbackFee.amount is required.`\n            );\n          }\n          fallback.setAmount(\n            typeof feeData.fallbackFee.amount === 'string'\n              ? Long.fromString(feeData.fallbackFee.amount)\n              : Long.fromNumber(feeData.fallbackFee.amount)\n          );\n          royaltyFee.setFallbackFee(fallback);\n        }\n        newFee = royaltyFee;\n        break;\n\n      default:\n        throw new Error(\n          `Fee #${index + 1}: Unknown custom fee type: ${\n            feeData.feeType\n          }. Supported types are FIXED_FEE, FRACTIONAL_FEE, ROYALTY_FEE.`\n        );\n    }\n\n    if (\n      feeData.allCollectorsAreExempt &&\n      typeof feeData.allCollectorsAreExempt === 'boolean'\n    ) {\n      newFee.setAllCollectorsAreExempt(feeData.allCollectorsAreExempt);\n    }\n    return newFee;\n  });\n}\n","import { z } from 'zod';\nimport { FTCreateParams } from '../../../types';\nimport { TokenSupplyType as SDKTokenSupplyType } from '@hashgraph/sdk';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders';\nimport { HtsBuilder } from '../../../builders';\nimport { SERIALIZED_KEY_DESCRIPTION, FEE_COLLECTOR_DESCRIPTION } from './hts-tool-utils';\n\nconst FixedFeeInputSchema = z.object({\n  type: z.enum(['FIXED', 'FIXED_FEE']),\n  feeCollectorAccountId: z.string().optional().describe(FEE_COLLECTOR_DESCRIPTION),\n  denominatingTokenId: z\n    .string()\n    .optional()\n    .describe('Denominating token ID for the fee (if not HBAR).'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe('Fee amount (smallest unit for tokens, or tinybars for HBAR).'),\n});\n\nconst FractionalFeeInputSchema = z.object({\n  type: z.enum(['FRACTIONAL', 'FRACTIONAL_FEE']),\n  feeCollectorAccountId: z.string().optional().describe(FEE_COLLECTOR_DESCRIPTION),\n  numerator: z.number().int().describe('Numerator of the fractional fee.'),\n  denominator: z\n    .number()\n    .int()\n    .positive()\n    .describe('Denominator of the fractional fee.'),\n  minAmount: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe('Minimum fractional fee amount.'),\n  maxAmount: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe('Maximum fractional fee amount (0 for no max).'),\n  assessmentMethodInclusive: z\n    .boolean()\n    .optional()\n    .describe('Fee is assessed on net amount (false) or gross (true).'),\n});\n\nconst RoyaltyFeeInputSchema = z.object({\n  type: z.enum(['ROYALTY', 'ROYALTY_FEE']),\n  feeCollectorAccountId: z.string().optional().describe(FEE_COLLECTOR_DESCRIPTION),\n  numerator: z.number().int().describe('Numerator of the royalty fee.'),\n  denominator: z\n    .number()\n    .int()\n    .positive()\n    .describe('Denominator of the royalty fee.'),\n  fallbackFee: FixedFeeInputSchema.omit({ type: true })\n    .optional()\n    .describe('Fallback fixed fee if royalty is not applicable.'),\n});\n\nconst CustomFeeInputUnionSchema = z.discriminatedUnion('type', [\n  FixedFeeInputSchema,\n  FractionalFeeInputSchema,\n  RoyaltyFeeInputSchema,\n]);\n\nexport type CustomFeeInputData = z.infer<typeof CustomFeeInputUnionSchema>;\n\nconst FTCreateZodSchemaCore = z.object({\n  tokenName: z.string().describe('The publicly visible name of the token.'),\n  tokenSymbol: z\n    .string()\n    .optional()\n    .describe('The publicly visible symbol of the token.'),\n  treasuryAccountId: z\n    .string()\n    .optional()\n    .describe('Treasury account ID (e.g., \"0.0.xxxx\").'),\n  initialSupply: z\n    .union([z.number(), z.string()])\n    .describe('Initial supply in the smallest denomination.'),\n  decimals: z\n    .number()\n    .int()\n    .optional()\n    .default(0)\n    .describe(\n      'Number of decimal places for the token. Defaults to 0 if not specified.'\n    ),\n  adminKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Admin key (${SERIALIZED_KEY_DESCRIPTION}. Required for token to be mutable.`\n    ),\n  kycKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. KYC key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  freezeKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Freeze key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  wipeKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Wipe key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  supplyKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Supply key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  feeScheduleKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Fee schedule key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  pauseKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Pause key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  autoRenewAccountId: z\n    .string()\n    .optional()\n    .describe('Optional. Auto-renew account ID (e.g., \"0.0.xxxx\").'),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe('Optional. Auto-renewal period in seconds.'),\n  memo: z.string().optional().describe('Optional. Memo for the token.'),\n  freezeDefault: z\n    .boolean()\n    .optional()\n    .describe('Optional. Default freeze status for accounts.'),\n  customFees: z\n    .array(CustomFeeInputUnionSchema)\n    .optional()\n    .describe('Optional. Array of custom fee objects for the token.'),\n  supplyType: z\n    .enum([\n      SDKTokenSupplyType.Finite.toString(),\n      SDKTokenSupplyType.Infinite.toString(),\n    ])\n    .optional()\n    .default(SDKTokenSupplyType.Finite.toString())\n    .describe(\n      'Supply type: FINITE or INFINITE. Defaults to FINITE if not specified.'\n    ),\n  maxSupply: z\n    .union([z.number(), z.string()])\n    .optional()\n    .default(1000000000000000)\n    .describe(\n      'Max supply if supplyType is FINITE. Builder validates against initialSupply.'\n    ),\n});\n\nexport class HederaCreateFungibleTokenTool extends BaseHederaTransactionTool<\n  typeof FTCreateZodSchemaCore\n> {\n  name = 'hedera-hts-create-fungible-token';\n  description =\n    'Creates a new Hedera Fungible Token (FT). Builder handles key parsing, fee construction, and supply validation.';\n  specificInputSchema = FTCreateZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof FTCreateZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).createFungibleToken(\n      specificArgs as unknown as FTCreateParams\n    );\n  }\n\n  protected override getNoteForKey(\n    key: string,\n    schemaDefaultValue: unknown,\n    actualValue: unknown\n  ): string | undefined {\n    if (key === 'decimals') {\n      return `The number of decimal places for your token was automatically set to '${actualValue}'.`;\n    }\n    if (key === 'supplyType') {\n      return `Your token's supply type was set to '${actualValue}' by default.`;\n    }\n    if (key === 'maxSupply') {\n      try {\n        const num = BigInt(String(actualValue));\n        return `A maximum supply of '${num.toLocaleString()}' for the token was set by default.`;\n      } catch {\n        return `The maximum supply for the token was set to '${actualValue}' by default.`;\n      }\n    }\n    if (key === 'freezeDefault') {\n      return `By default, accounts holding this token will ${\n        actualValue ? 'be frozen' : 'not be frozen'\n      }.`;\n    }\n    return undefined;\n  }\n}\n","import { z } from 'zod';\nimport { NFTCreateParams } from '../../../types';\nimport { TokenSupplyType as SDKTokenSupplyType } from '@hashgraph/sdk';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\nimport { SERIALIZED_KEY_DESCRIPTION, FEE_COLLECTOR_DESCRIPTION } from './hts-tool-utils';\n\n/**\n * Zod schema for a fixed fee input object.\n */\nconst FixedFeeInputSchema = z.object({\n  type: z.enum(['FIXED', 'FIXED_FEE']),\n  feeCollectorAccountId: z.string().optional().describe(FEE_COLLECTOR_DESCRIPTION),\n  denominatingTokenId: z\n    .string()\n    .optional()\n    .describe('Denominating token ID for the fee (if not HBAR).'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe('Fee amount (smallest unit for tokens, or tinybars for HBAR).'),\n});\n\n/**\n * Zod schema for a fractional fee input object.\n */\nconst FractionalFeeInputSchema = z.object({\n  type: z.enum(['FRACTIONAL', 'FRACTIONAL_FEE']),\n  feeCollectorAccountId: z.string().optional().describe(FEE_COLLECTOR_DESCRIPTION),\n  numerator: z.number().int().describe('Numerator of the fractional fee.'),\n  denominator: z\n    .number()\n    .int()\n    .positive()\n    .describe('Denominator of the fractional fee.'),\n  minAmount: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe('Minimum fractional fee amount.'),\n  maxAmount: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe('Maximum fractional fee amount (0 for no max).'),\n  assessmentMethodInclusive: z\n    .boolean()\n    .optional()\n    .describe('Fee is assessed on net amount (false) or gross (true).'),\n});\n\n/**\n * Zod schema for a royalty fee input object.\n */\nconst RoyaltyFeeInputSchema = z.object({\n  type: z.enum(['ROYALTY', 'ROYALTY_FEE']),\n  feeCollectorAccountId: z.string().optional().describe(FEE_COLLECTOR_DESCRIPTION),\n  numerator: z.number().int().describe('Numerator of the royalty fee.'),\n  denominator: z\n    .number()\n    .int()\n    .positive()\n    .describe('Denominator of the royalty fee.'),\n  fallbackFee: FixedFeeInputSchema.omit({ type: true })\n    .optional()\n    .describe('Fallback fixed fee if royalty is not applicable.'),\n});\n\n/**\n * Zod schema for a discriminated union of custom fee input types.\n */\nconst CustomFeeInputUnionSchema = z.discriminatedUnion('type', [\n  FixedFeeInputSchema,\n  FractionalFeeInputSchema,\n  RoyaltyFeeInputSchema,\n]);\n\nconst NFTCreateZodSchemaCore = z.object({\n  tokenName: z\n    .string()\n    .describe('The publicly visible name of the NFT collection.'),\n  tokenSymbol: z\n    .string()\n    .optional()\n    .describe('The publicly visible symbol of the NFT collection.'),\n  treasuryAccountId: z\n    .string()\n    .optional()\n    .describe('Treasury account ID (e.g., \"0.0.xxxx\").'),\n  adminKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Admin key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  kycKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. KYC key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  freezeKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Freeze key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  wipeKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Wipe key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  supplyKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Supply key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  feeScheduleKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Fee schedule key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  pauseKey: z\n    .string()\n    .optional()\n    .describe(\n      `Optional. Pause key (${SERIALIZED_KEY_DESCRIPTION}`\n    ),\n  autoRenewAccountId: z\n    .string()\n    .optional()\n    .describe('Optional. Auto-renew account ID (e.g., \"0.0.xxxx\").'),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe('Optional. Auto-renewal period in seconds.'),\n  memo: z\n    .string()\n    .optional()\n    .describe('Optional. Memo for the NFT collection.'),\n  freezeDefault: z\n    .boolean()\n    .optional()\n    .describe('Optional. Default freeze status for accounts.'),\n  customFees: z\n    .array(CustomFeeInputUnionSchema)\n    .optional()\n    .describe('Optional. Array of custom fee objects for the token.'),\n  supplyType: z\n    .enum([\n      SDKTokenSupplyType.Finite.toString(),\n      SDKTokenSupplyType.Infinite.toString(),\n    ])\n    .optional()\n    .default(SDKTokenSupplyType.Finite.toString())\n    .describe(\n      'Supply type: FINITE or INFINITE. NFTs typically use FINITE. Defaults to FINITE if not specified.'\n    ),\n  maxSupply: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe(\n      'Max supply if supplyType is FINITE. Builder handles validation.'\n    ),\n});\n\nexport class HederaCreateNftTool extends BaseHederaTransactionTool<\n  typeof NFTCreateZodSchemaCore\n> {\n  name = 'hedera-hts-create-nft';\n  description =\n    'Creates a new Hedera Non-Fungible Token (NFT) collection. Builder handles key parsing, fee construction, and supply validation.';\n  specificInputSchema = NFTCreateZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof NFTCreateZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).createNonFungibleToken(\n      specificArgs as unknown as NFTCreateParams\n    );\n  }\n\n  protected override getNoteForKey(key: string, schemaDefaultValue: unknown, actualValue: unknown): string | undefined {\n    if (key === 'supplyType') {\n      return `Your NFT collection's supply type was set to '${actualValue}' by default.`;\n    }\n    if (key === 'maxSupply' && actualValue !== undefined) {\n      try {\n        const num = BigInt(String(actualValue));\n        return `A maximum supply of '${num.toLocaleString()}' for the NFT collection was set (tool schema default).`;\n      } catch {\n        return `The maximum supply for the NFT collection was set to '${actualValue}' (tool schema default).`;\n      }\n    }\n    return undefined;\n  }\n}\n","import { z } from 'zod';\nimport { DeleteTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst DeleteTokenZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the token to delete (e.g., \"0.0.xxxx\").'),\n});\n\nexport class HederaDeleteTokenTool extends BaseHederaTransactionTool<\n  typeof DeleteTokenZodSchemaCore\n> {\n  name = 'hedera-hts-delete-token';\n  description =\n    'Deletes a token. Requires the tokenId. Use metaOptions for execution control.';\n  specificInputSchema = DeleteTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DeleteTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).deleteToken(\n      specificArgs as unknown as DeleteTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { DissociateTokensParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst DissociateTokensZodSchemaCore = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to dissociate tokens from (e.g., \"0.0.xxxx\").'),\n  tokenIds: z\n    .array(z.string().describe('A token ID (e.g., \"0.0.yyyy\").'))\n    .min(1)\n    .describe('An array of one or more token IDs to dissociate.'),\n});\n\nexport class HederaDissociateTokensTool extends BaseHederaTransactionTool<\n  typeof DissociateTokensZodSchemaCore\n> {\n  name = 'hedera-hts-dissociate-tokens';\n  description = 'Dissociates one or more Hedera tokens from an account.';\n  specificInputSchema = DissociateTokensZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DissociateTokensZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).dissociateTokens(\n      specificArgs as unknown as DissociateTokensParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { FreezeTokenAccountParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst FreezeTokenAccountZodSchemaCore = z.object({\n  tokenId: z.string().describe('The ID of the token (e.g., \"0.0.xxxx\").'),\n  accountId: z\n    .string()\n    .describe('The account ID to be frozen for the token (e.g., \"0.0.yyyy\").'),\n});\n\nexport class HederaFreezeTokenAccountTool extends BaseHederaTransactionTool<\n  typeof FreezeTokenAccountZodSchemaCore\n> {\n  name = 'hedera-hts-freeze-token-account';\n  description = 'Freezes an account for a specific token.';\n  specificInputSchema = FreezeTokenAccountZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof FreezeTokenAccountZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).freezeTokenAccount(\n      specificArgs as unknown as FreezeTokenAccountParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetTokenInfoZodSchema = z.object({\n  tokenId: z\n    .string()\n    .describe('The token ID to get information for (e.g., \"0.0.12345\")'),\n});\n\n/**\n * Tool for retrieving Hedera Token Service token information.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetTokenInfoTool extends BaseHederaQueryTool<\n  typeof GetTokenInfoZodSchema\n> {\n  name = 'hedera-get-token-info';\n  description =\n    'Retrieves comprehensive information about a Hedera token including name, symbol, supply, keys, and other metadata.';\n  specificInputSchema = GetTokenInfoZodSchema;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetTokenInfoZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting token info for token ID: ${args.tokenId}`);\n\n    const tokenInfo = await this.hederaKit.query().getTokenInfo(args.tokenId);\n\n    if (!tokenInfo) {\n      return {\n        success: false,\n        error: `Token ${args.tokenId} not found`,\n      };\n    }\n\n    return {\n      success: true,\n      tokenInfo,\n    };\n  }\n}\n\n ","import { z } from 'zod';\nimport { GrantKycTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst GrantKycTokenZodSchemaCore = z.object({\n  tokenId: z.string().describe('The ID of the token (e.g., \"0.0.xxxx\").'),\n  accountId: z\n    .string()\n    .describe(\n      'The account ID to be granted KYC for the token (e.g., \"0.0.yyyy\").'\n    ),\n});\n\nexport class HederaGrantKycTokenTool extends BaseHederaTransactionTool<\n  typeof GrantKycTokenZodSchemaCore\n> {\n  name = 'hedera-hts-grant-kyc-token';\n  description = 'Grants KYC to an account for a specific token.';\n  specificInputSchema = GrantKycTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof GrantKycTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).grantKycToken(\n      specificArgs as unknown as GrantKycTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { MintFTParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst MintFTZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the fungible token (e.g., \"0.0.xxxx\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'Amount to mint (smallest unit). Number or string for large values. Builder handles conversion.'\n    ),\n});\n\nexport class HederaMintFungibleTokenTool extends BaseHederaTransactionTool<\n  typeof MintFTZodSchemaCore\n> {\n  name = 'hedera-hts-mint-fungible-token';\n  description = 'Mints more fungible tokens. Requires tokenId and amount.';\n  specificInputSchema = MintFTZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof MintFTZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).mintFungibleToken(\n      specificArgs as unknown as MintFTParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { MintNFTParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders';\nimport { HtsBuilder } from '../../../builders';\nimport { Buffer } from \"buffer\";\n\nconst MintNFTZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the NFT collection (e.g., \"0.0.xxxx\").'),\n  metadata: z\n    .array(z.string())\n    .describe(\n      'Array of metadata for each NFT. Strings are treated as UTF-8, or base64 for binary. Builder handles decoding & validation.'\n    ),\n  batchSize: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe(\n      'Optional. Max NFTs per transaction if chunking. Builder handles default/limits.'\n    ),\n});\n\nexport class HederaMintNftTool extends BaseHederaTransactionTool<\n  typeof MintNFTZodSchemaCore\n> {\n  name = 'hedera-hts-mint-nft';\n  description =\n    'Mints new Non-Fungible Tokens (NFTs). Builder handles metadata decoding and batching.';\n  specificInputSchema = MintNFTZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof MintNFTZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).mintNonFungibleToken(\n      specificArgs as unknown as MintNFTParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { PauseTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst PauseTokenZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the token to pause (e.g., \"0.0.xxxx\").'),\n});\n\nexport class HederaPauseTokenTool extends BaseHederaTransactionTool<\n  typeof PauseTokenZodSchemaCore\n> {\n  name = 'hedera-hts-pause-token';\n  description =\n    'Pauses a token. Requires the tokenId. Use metaOptions for execution control.';\n  specificInputSchema = PauseTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof PauseTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).pauseToken(\n      specificArgs as unknown as PauseTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { RejectAirdropParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst RejectTokensZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe(\n      'The ID of the token type to reject future associations with (e.g., \"0.0.xxxx\").'\n    ),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaRejectTokensTool extends BaseHederaTransactionTool<\n  typeof RejectTokensZodSchemaCore\n> {\n  name = 'hedera-hts-reject-tokens';\n  description =\n    'Configures the operator to reject future auto-associations with a specific token type.';\n  specificInputSchema = RejectTokensZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof RejectTokensZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).rejectTokens(\n      specificArgs as unknown as RejectAirdropParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { RevokeKycTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst RevokeKycTokenZodSchemaCore = z.object({\n  tokenId: z.string().describe('The ID of the token (e.g., \"0.0.xxxx\").'),\n  accountId: z\n    .string()\n    .describe(\n      'The account ID to have KYC revoked for the token (e.g., \"0.0.yyyy\").'\n    ),\n});\n\nexport class HederaRevokeKycTokenTool extends BaseHederaTransactionTool<\n  typeof RevokeKycTokenZodSchemaCore\n> {\n  name = 'hedera-hts-revoke-kyc-token';\n  description = 'Revokes KYC from an account for a specific token.';\n  specificInputSchema = RevokeKycTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof RevokeKycTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).revokeKycToken(\n      specificArgs as RevokeKycTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { TokenFeeScheduleUpdateParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst FEE_COLLECTOR_DESCRIPTION = \"Fee collector's account ID.\";\n\n/**\n * Zod schema for a fixed fee input object.\n */\nconst FixedFeeInputSchema = z.object({\n  type: z.literal('FIXED'),\n  feeCollectorAccountId: z.string().describe(FEE_COLLECTOR_DESCRIPTION),\n  denominatingTokenId: z\n    .string()\n    .optional()\n    .describe('Denominating token ID for the fee (if not HBAR).'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe('Fee amount (smallest unit for tokens, or tinybars for HBAR).'),\n});\n\n/**\n * Zod schema for a fractional fee input object.\n */\nconst FractionalFeeInputSchema = z.object({\n  type: z.literal('FRACTIONAL'),\n  feeCollectorAccountId: z.string().describe(FEE_COLLECTOR_DESCRIPTION),\n  numerator: z.number().int().describe('Numerator of the fractional fee.'),\n  denominator: z\n    .number()\n    .int()\n    .positive()\n    .describe('Denominator of the fractional fee.'),\n  assessmentMethodInclusive: z\n    .boolean()\n    .optional()\n    .describe('Fee is assessed on net amount (false) or gross (true).'),\n});\n\n/**\n * Zod schema for a royalty fee input object.\n */\nconst RoyaltyFeeInputSchema = z.object({\n  type: z.literal('ROYALTY'),\n  feeCollectorAccountId: z.string().describe(FEE_COLLECTOR_DESCRIPTION),\n  numerator: z.number().int().describe('Numerator of the royalty fee.'),\n  denominator: z\n    .number()\n    .int()\n    .positive()\n    .describe('Denominator of the royalty fee.'),\n  fallbackFee: FixedFeeInputSchema.omit({ type: true })\n    .optional()\n    .describe('Fallback fixed fee if royalty is not applicable.'),\n});\n\n/**\n * Zod schema for a discriminated union of custom fee input types.\n */\nconst CustomFeeInputUnionSchema = z.discriminatedUnion('type', [\n  FixedFeeInputSchema,\n  FractionalFeeInputSchema,\n  RoyaltyFeeInputSchema,\n]);\n\nconst TokenFeeScheduleUpdateZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe(\n      'The ID of the token whose fee schedule is to be updated (e.g., \"0.0.xxxx\").'\n    ),\n  customFees: z\n    .array(CustomFeeInputUnionSchema)\n    .min(1)\n    .describe(\n      'An array of new custom fee objects. This will replace the existing fee schedule.'\n    ),\n});\n\nexport class HederaTokenFeeScheduleUpdateTool extends BaseHederaTransactionTool<\n  typeof TokenFeeScheduleUpdateZodSchemaCore\n> {\n  name = 'hedera-hts-token-fee-schedule-update';\n  description =\n    'Updates the fee schedule of a token. Requires tokenId and an array of custom fee objects.';\n  specificInputSchema = TokenFeeScheduleUpdateZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof TokenFeeScheduleUpdateZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).feeScheduleUpdate(\n      specificArgs as unknown as TokenFeeScheduleUpdateParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { TransferNFTParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders';\nimport { HtsBuilder } from '../../../builders';\n\nconst TransferNftZodSchemaCore = z.object({\n  tokenId: z.string().describe('The token ID of the NFT (e.g., \"0.0.xxxx\").'),\n  serial: z\n    .union([z.number().int().positive(), z.string()])\n    .describe('The serial number of the NFT.'),\n  senderAccountId: z\n    .string()\n    .describe('The sender account ID (e.g., \"0.0.xxxx\").'),\n  receiverAccountId: z\n    .string()\n    .describe('The receiver account ID (e.g., \"0.0.yyyy\").'),\n  isApproved: z\n    .boolean()\n    .optional()\n    .describe('Optional. True if sender is an approved operator for the NFT.'),\n  memo: z.string().optional().describe('Optional. Memo for the transaction.'),\n});\n\nexport class HederaTransferNftTool extends BaseHederaTransactionTool<\n  typeof TransferNftZodSchemaCore\n> {\n  name = 'hedera-hts-transfer-nft';\n  description = 'Transfers a single Non-Fungible Token (NFT).';\n  specificInputSchema = TransferNftZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof TransferNftZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).transferNft(\n      specificArgs as unknown as TransferNFTParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { TransferTokensParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst FungibleTokenTransferInputSchema = z.object({\n  type: z.literal('fungible'),\n  tokenId: z.string().describe('Token ID (e.g., \"0.0.xxxx\").'),\n  accountId: z\n    .string()\n    .describe('Account ID for the transfer (e.g., \"0.0.yyyy\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'Amount in smallest unit. Positive for credit, negative for debit. Builder handles conversion.'\n    ),\n});\n\nconst NftTransferInputSchema = z.object({\n  type: z.literal('nft'),\n  tokenId: z.string().describe('Token ID of the NFT (e.g., \"0.0.xxxx\").'),\n  serial: z\n    .union([z.number().int().positive(), z.string()])\n    .describe('Serial number of the NFT.'),\n  senderAccountId: z.string().describe('Sender account ID (e.g., \"0.0.ssss\").'),\n  receiverAccountId: z\n    .string()\n    .describe('Receiver account ID (e.g., \"0.0.rrrr\").'),\n  isApproved: z\n    .boolean()\n    .optional()\n    .describe('Optional. True if sender is an approved operator.'),\n});\n\nconst HbarTransferInputSchema = z.object({\n  accountId: z\n    .string()\n    .describe('Account ID for the HBAR transfer (e.g., \"0.0.zzzz\").'),\n  amount: z\n    .union([z.number(), z.string()])\n    .describe(\n      'HBAR amount in tinybars. Positive for credit, negative for debit. Builder handles Hbar unit conversion.'\n    ),\n});\n\nconst TransferTokensZodObjectSchema = z.object({\n  tokenTransfers: z\n    .array(\n      z.discriminatedUnion('type', [\n        FungibleTokenTransferInputSchema,\n        NftTransferInputSchema,\n      ])\n    )\n    .min(1)\n    .describe('Array of fungible token and/or NFT transfers.'),\n  hbarTransfers: z\n    .array(HbarTransferInputSchema)\n    .optional()\n    .describe(\n      'Optional. Array of HBAR transfers. Sum of amounts must be zero.'\n    ),\n  memo: z\n    .string()\n    .optional()\n    .describe('Optional. Memo for the entire transaction.'),\n});\n\nexport class HederaTransferTokensTool extends BaseHederaTransactionTool<\n  //@ts-ignore\n  typeof TransferTokensZodObjectSchema\n> {\n  name = 'hedera-hts-transfer-tokens';\n  description =\n    'Transfers multiple fungible tokens, NFTs, and/or HBAR in a single transaction. Builder handles parsing and validation.';\n  specificInputSchema = TransferTokensZodObjectSchema;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof TransferTokensZodObjectSchema>\n  ): Promise<void> {\n    await (builder as HtsBuilder).transferTokens(\n      specificArgs as unknown as TransferTokensParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { UnfreezeTokenAccountParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst UnfreezeTokenAccountZodSchemaCore = z.object({\n  tokenId: z.string().describe('The ID of the token (e.g., \"0.0.xxxx\").'),\n  accountId: z\n    .string()\n    .describe(\n      'The account ID to be unfrozen for the token (e.g., \"0.0.yyyy\").'\n    ),\n});\n\nexport class HederaUnfreezeTokenAccountTool extends BaseHederaTransactionTool<\n  typeof UnfreezeTokenAccountZodSchemaCore\n> {\n  name = 'hedera-hts-unfreeze-token-account';\n  description = 'Unfreezes an account for a specific token.';\n  specificInputSchema = UnfreezeTokenAccountZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof UnfreezeTokenAccountZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).unfreezeTokenAccount(\n      specificArgs as unknown as UnfreezeTokenAccountParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { UnpauseTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst UnpauseTokenZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the token to unpause (e.g., \"0.0.xxxx\").'),\n});\n\nexport class HederaUnpauseTokenTool extends BaseHederaTransactionTool<\n  typeof UnpauseTokenZodSchemaCore\n> {\n  name = 'hedera-hts-unpause-token';\n  description =\n    'Unpauses a token. Requires the tokenId. Use metaOptions for execution control.';\n  specificInputSchema = UnpauseTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof UnpauseTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).unpauseToken(\n      specificArgs as unknown as UnpauseTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { UpdateTokenParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder'; // Added HtsBuilder import\n\nconst UpdateTokenZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the token to update (e.g., \"0.0.xxxx\").'),\n  tokenName: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New token name. Pass null to clear.'),\n  tokenSymbol: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New token symbol. Pass null to clear.'),\n  treasuryAccountId: z\n    .string()\n    .optional()\n    .describe('Optional. New treasury account ID (e.g., \"0.0.yyyy\").'),\n  adminKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New admin key (serialized string). Pass null to clear.'\n    ),\n  kycKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New KYC key (serialized string). Pass null to clear.'),\n  freezeKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New freeze key (serialized string). Pass null to clear.'\n    ),\n  wipeKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New wipe key (serialized string). Pass null to clear.'\n    ),\n  supplyKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New supply key (serialized string). Pass null to clear.'\n    ),\n  feeScheduleKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New fee schedule key (serialized string). Pass null to clear.'\n    ),\n  pauseKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New pause key (serialized string). Pass null to clear.'\n    ),\n  autoRenewAccountId: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New auto-renew account ID. Pass null to clear.'),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe('Optional. New auto-renewal period in seconds.'),\n  memo: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New token memo. Pass null to clear.'),\n});\n\nexport class HederaUpdateTokenTool extends BaseHederaTransactionTool<\n  typeof UpdateTokenZodSchemaCore\n> {\n  name = 'hedera-hts-update-token';\n  description =\n    'Updates an existing Hedera token. Requires tokenId. Other fields are optional. Null can be used to clear certain fields.';\n  specificInputSchema = UpdateTokenZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof UpdateTokenZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).updateToken(\n      specificArgs as unknown as UpdateTokenParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst ValidateNftOwnershipZodSchema = z.object({\n  accountId: z\n    .string()\n    .describe('The account ID to check ownership for (e.g., \"0.0.12345\")'),\n  tokenId: z\n    .string()\n    .describe('The NFT token ID (e.g., \"0.0.67890\")'),\n  serialNumber: z\n    .number()\n    .int()\n    .positive()\n    .describe('The serial number of the NFT'),\n});\n\n/**\n * Tool for validating NFT ownership on Hedera.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaValidateNftOwnershipTool extends BaseHederaQueryTool<\n  typeof ValidateNftOwnershipZodSchema\n> {\n  name = 'hedera-validate-nft-ownership';\n  description =\n    'Validates whether a specific account owns a particular NFT by token ID and serial number.';\n  specificInputSchema = ValidateNftOwnershipZodSchema;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof ValidateNftOwnershipZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(\n      `Validating NFT ownership: account ${args.accountId}, token ${args.tokenId}, serial ${args.serialNumber}`\n    );\n    \n    const nftDetail = await this.hederaKit.query().validateNftOwnership(\n      args.accountId,\n      args.tokenId,\n      args.serialNumber\n    );\n    \n    const isOwned = nftDetail !== null;\n\n    return {\n      success: true,\n      accountId: args.accountId,\n      tokenId: args.tokenId,\n      serialNumber: args.serialNumber,\n      isOwned,\n      nftDetail: isOwned ? nftDetail : null,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport { WipeTokenAccountParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { HtsBuilder } from '../../../builders/hts/hts-builder';\n\nconst WipeTokenAccountZodSchemaCore = z.object({\n  tokenId: z\n    .string()\n    .describe('The ID of the token to wipe (e.g., \"0.0.xxxx\").'),\n  accountId: z\n    .string()\n    .describe(\n      'The account ID from which tokens will be wiped (e.g., \"0.0.yyyy\").'\n    ),\n  amount: z\n    .union([z.number(), z.string()])\n    .optional()\n    .describe(\n      'For Fungible Tokens: amount to wipe (smallest unit). Builder handles conversion and validation.'\n    ),\n  serials: z\n    .array(z.union([z.number().int().positive(), z.string()]))\n    .optional()\n    .describe(\n      'For Non-Fungible Tokens: array of serial numbers to wipe. Builder handles conversion and validation.'\n    ),\n});\n\nexport class HederaWipeTokenAccountTool extends BaseHederaTransactionTool<\n  typeof WipeTokenAccountZodSchemaCore\n> {\n  name = 'hedera-hts-wipe-token-account';\n  description =\n    \"Wipes tokens (fungible or non-fungible) from an account. Provide 'amount' for FTs or 'serials' for NFTs. Builder validates inputs.\";\n  specificInputSchema = WipeTokenAccountZodSchemaCore;\n  namespace = 'hts';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.hts();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof WipeTokenAccountZodSchemaCore>\n  ): Promise<void> {\n    await (builder as HtsBuilder).wipeTokenAccount(\n      specificArgs as unknown as WipeTokenAccountParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport { DeleteContractParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { ScsBuilder } from '../../../builders/scs/scs-builder';\n\nconst DeleteContractZodSchemaCore = z.object({\n  contractId: z\n    .string()\n    .describe('The ID of the contract to delete (e.g., \"0.0.xxxx\").'),\n  transferAccountId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Account ID to transfer balance to. Builder validates if needed.'\n    ),\n  transferContractId: z\n    .string()\n    .optional()\n    .describe(\n      'Optional. Contract ID to transfer balance to. Builder validates if needed.'\n    ),\n});\n\nexport class HederaDeleteContractTool extends BaseHederaTransactionTool<\n  typeof DeleteContractZodSchemaCore\n> {\n  name = 'hedera-scs-delete-contract';\n  description =\n    'Deletes a smart contract. Optionally specify a transfer target for any remaining balance.';\n  specificInputSchema = DeleteContractZodSchemaCore;\n  namespace = 'scs';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.scs();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof DeleteContractZodSchemaCore>\n  ): Promise<void> {\n    await (builder as ScsBuilder).deleteContract(\n      specificArgs as unknown as DeleteContractParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n  FieldProcessor,\n} from '../common/base-hedera-query-tool';\n\nconst GetContractZodSchema = z.object({\n  contractIdOrAddress: z.string().describe('The contract ID or EVM address'),\n  timestamp: z\n    .string()\n    .optional()\n    .describe('Optional timestamp for historical data'),\n  includeBytecode: z\n    .boolean()\n    .optional()\n    .default(false)\n    .describe(\n      'Whether to include full bytecode in response (may be very large)'\n    ),\n});\n\n/**\n * Tool for retrieving a specific contract by ID or address.\n */\nexport class HederaGetContractTool extends BaseHederaQueryTool<\n  typeof GetContractZodSchema\n> {\n  name = 'hedera-get-contract';\n  description =\n    'Retrieves a specific contract by ID or EVM address from the Hedera network. Use includeBytecode=true for full bytecode (may be large).';\n  specificInputSchema = GetContractZodSchema;\n  namespace = 'scs';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected override getLargeFieldProcessors(\n    args: z.infer<typeof GetContractZodSchema>\n  ): Record<string, FieldProcessor> {\n    if (args.includeBytecode) {\n      return {};\n    }\n\n    return {\n      'contract.bytecode': {\n        maxLength: 200,\n        truncateMessage: '[Use includeBytecode=true for full bytecode]',\n      },\n      'contract.runtime_bytecode': {\n        maxLength: 200,\n        truncateMessage: '[Use includeBytecode=true for full runtime bytecode]',\n      },\n      'contract.creation_bytecode': {\n        maxLength: 200,\n        truncateMessage:\n          '[Use includeBytecode=true for full creation bytecode]',\n      },\n      bytecode: {\n        maxLength: 200,\n        truncateMessage: '[Use includeBytecode=true for full bytecode]',\n      },\n      runtime_bytecode: {\n        maxLength: 200,\n        truncateMessage: '[Use includeBytecode=true for full runtime bytecode]',\n      },\n      creation_bytecode: {\n        maxLength: 200,\n        truncateMessage:\n          '[Use includeBytecode=true for full creation bytecode]',\n      },\n    };\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetContractZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(`Getting contract: ${args.contractIdOrAddress}`);\n\n    const contract = await this.hederaKit\n      .query()\n      .getContract(args.contractIdOrAddress, args.timestamp);\n\n    if (contract === null) {\n      return {\n        success: false,\n        error: `Contract ${args.contractIdOrAddress} not found`,\n      };\n    }\n\n    return {\n      success: true,\n      contract,\n      summary: {\n        contractId: contract.contract_id,\n        evmAddress: contract.evm_address,\n        created: contract.created_timestamp,\n        expiration: contract.expiration_timestamp,\n        deleted: contract.deleted,\n        memo: contract.memo || 'No memo',\n        autoRenewPeriod: contract.auto_renew_period,\n        maxAutomaticTokenAssociations:\n          contract.max_automatic_token_associations,\n        hasAdminKey: Boolean(contract.admin_key),\n        hasBytecode: Boolean(contract.bytecode),\n        hasRuntimeBytecode: Boolean(contract.runtime_bytecode),\n        bytecodeIncluded: args.includeBytecode,\n      },\n    };\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetContractsZodSchema = z.object({\n  contractId: z.string().optional().describe('Filter by specific contract ID'),\n  limit: z\n    .number()\n    .optional()\n    .describe('Maximum number of contracts to return'),\n  order: z.enum(['asc', 'desc']).optional().describe('Order of results'),\n});\n\n/**\n * Tool for retrieving contract entities from the network.\n */\nexport class HederaGetContractsTool extends BaseHederaQueryTool<\n  typeof GetContractsZodSchema\n> {\n  name = 'hedera-get-contracts';\n  description =\n    'Retrieves contract entities from the Hedera network with optional filtering.';\n  specificInputSchema = GetContractsZodSchema;\n  namespace = 'scs';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetContractsZodSchema>\n  ): Promise<unknown> {\n    this.logger.info('Getting contracts from the network');\n\n    const contracts = await this.hederaKit.query().getContracts(args);\n\n    if (contracts === null) {\n      return {\n        success: false,\n        error: 'Could not retrieve contracts from the network',\n      };\n    }\n\n    return {\n      success: true,\n      contracts,\n      count: contracts.length,\n    };\n  }\n}\n","import { z } from 'zod';\nimport { UpdateContractParams } from '../../../types';\nimport {\n  BaseHederaTransactionTool,\n  BaseHederaTransactionToolParams,\n} from '../common/base-hedera-transaction-tool';\nimport { BaseServiceBuilder } from '../../../builders/base-service-builder';\nimport { ScsBuilder } from '../../../builders/scs/scs-builder';\n\nconst UpdateContractZodSchemaCore = z.object({\n  contractId: z\n    .string()\n    .describe('The ID of the contract to update (e.g., \"0.0.xxxx\").'),\n  adminKey: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New admin key (serialized string). Pass null to clear.'\n    ),\n  autoRenewPeriod: z\n    .number()\n    .int()\n    .positive()\n    .optional()\n    .describe('Optional. New auto-renewal period in seconds.'),\n  memo: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New contract memo. Pass null or empty string to clear.'\n    ),\n  stakedAccountId: z\n    .string()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New account ID to stake to. Pass \"0.0.0\" or null to clear.'\n    ),\n  stakedNodeId: z\n    .number()\n    .int()\n    .nullable()\n    .optional()\n    .describe(\n      'Optional. New node ID to stake to. Pass -1 or null to clear. Builder handles Long conversion.'\n    ),\n  declineStakingReward: z\n    .boolean()\n    .optional()\n    .describe('Optional. If true, contract declines staking rewards.'),\n  maxAutomaticTokenAssociations: z\n    .number()\n    .int()\n    .optional()\n    .describe('Optional. New max automatic token associations.'),\n  proxyAccountId: z\n    .string()\n    .nullable()\n    .optional()\n    .describe('Optional. New proxy account ID. Pass \"0.0.0\" or null to clear.'),\n});\n\nexport class HederaUpdateContractTool extends BaseHederaTransactionTool<\n  typeof UpdateContractZodSchemaCore\n> {\n  name = 'hedera-scs-update-contract';\n  description =\n    'Updates an existing Hedera smart contract. Builder handles parsing and clearing logic.';\n  specificInputSchema = UpdateContractZodSchemaCore;\n  namespace = 'scs';\n\n  constructor(params: BaseHederaTransactionToolParams) {\n    super(params);\n  }\n\n  protected getServiceBuilder(): BaseServiceBuilder {\n    return this.hederaKit.scs();\n  }\n\n  protected async callBuilderMethod(\n    builder: BaseServiceBuilder,\n    specificArgs: z.infer<typeof UpdateContractZodSchemaCore>\n  ): Promise<void> {\n    await (builder as ScsBuilder).updateContract(\n      specificArgs as unknown as UpdateContractParams\n    );\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetHbarPriceZodSchema = z.object({\n  date: z\n    .string()\n    .optional()\n    .describe(\n      'Date to get HBAR price for in ISO format (e.g., \"2023-12-01T00:00:00Z\"). Defaults to current date.'\n    ),\n});\n\n/**\n * Tool for retrieving HBAR price from the Hedera network.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetHbarPriceTool extends BaseHederaQueryTool<\n  typeof GetHbarPriceZodSchema\n> {\n  name = 'hedera-get-hbar-price';\n  description =\n    'Retrieves the HBAR price in USD for a specific date. Defaults to current date if no date provided.';\n  specificInputSchema = GetHbarPriceZodSchema;\n  namespace = 'network';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetHbarPriceZodSchema>\n  ): Promise<unknown> {\n    const date = args.date ? new Date(args.date) : new Date();\n\n    this.logger.info(`Getting HBAR price for date: ${date.toISOString()}`);\n\n    const price = await this.hederaKit.query().getHbarPrice(date);\n\n    if (price === null) {\n      return {\n        success: false,\n        error: `Could not retrieve HBAR price for date ${date.toISOString()}`,\n      };\n    }\n\n    return {\n      success: true,\n      date: date.toISOString(),\n      priceUsd: price,\n      currency: 'USD',\n    };\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetNetworkInfoZodSchema = z.object({});\n\n/**\n * Tool for retrieving network information.\n */\nexport class HederaGetNetworkInfoTool extends BaseHederaQueryTool<\n  typeof GetNetworkInfoZodSchema\n> {\n  name = 'hedera-get-network-info';\n  description = 'Retrieves network information from the Hedera network.';\n  specificInputSchema = GetNetworkInfoZodSchema;\n  namespace = 'network';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(): Promise<unknown> {\n    this.logger.info('Getting network information');\n\n    const networkInfo = await this.hederaKit.query().getNetworkInfo();\n\n    if (networkInfo === null) {\n      return {\n        success: false,\n        error: 'Could not retrieve network information',\n      };\n    }\n\n    return {\n      success: true,\n      networkInfo,\n    };\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetNetworkFeesZodSchema = z.object({\n  timestamp: z\n    .string()\n    .optional()\n    .describe('Optional timestamp for historical fees'),\n});\n\n/**\n * Tool for retrieving network fees.\n */\nexport class HederaGetNetworkFeesTool extends BaseHederaQueryTool<\n  typeof GetNetworkFeesZodSchema\n> {\n  name = 'hedera-get-network-fees';\n  description = 'Retrieves network fees from the Hedera network.';\n  specificInputSchema = GetNetworkFeesZodSchema;\n  namespace = 'network';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetNetworkFeesZodSchema>\n  ): Promise<unknown> {\n    this.logger.info('Getting network fees');\n\n    const networkFees = await this.hederaKit\n      .query()\n      .getNetworkFees(args.timestamp);\n\n    if (networkFees === null) {\n      return {\n        success: false,\n        error: 'Could not retrieve network fees',\n      };\n    }\n\n    return {\n      success: true,\n      networkFees,\n    };\n  }\n}\n","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetBlocksZodSchema = z.object({\n  blockNumber: z\n    .string()\n    .optional()\n    .describe('Filter by block number'),\n  timestamp: z\n    .string()\n    .optional()\n    .describe('Filter by timestamp'),\n  limit: z\n    .number()\n    .optional()\n    .describe('Maximum number of blocks to return'),\n  order: z\n    .enum(['asc', 'desc'])\n    .optional()\n    .describe('Order of results'),\n});\n\n/**\n * Tool for retrieving blocks from the network.\n */\nexport class HederaGetBlocksTool extends BaseHederaQueryTool<\n  typeof GetBlocksZodSchema\n> {\n  name = 'hedera-get-blocks';\n  description = 'Retrieves blocks from the Hedera network with optional filtering.';\n  specificInputSchema = GetBlocksZodSchema;\n  namespace = 'network';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetBlocksZodSchema>\n  ): Promise<unknown> {\n    this.logger.info('Getting blocks from the network');\n\n    const blocks = await this.hederaKit.query().getBlocks(args);\n\n    if (blocks === null) {\n      return {\n        success: false,\n        error: 'Could not retrieve blocks from the network',\n      };\n    }\n\n    return {\n      success: true,\n      blocks,\n      count: blocks.length,\n    };\n  }\n} \n ","import { z } from 'zod';\nimport {\n  BaseHederaQueryTool,\n  BaseHederaQueryToolParams,\n} from '../common/base-hedera-query-tool';\n\nconst GetTransactionZodSchema = z.object({\n  transactionIdOrHash: z\n    .string()\n    .describe(\n      'The transaction ID (e.g., \"0.0.12345-1234567890-123456789\") or hash to get details for'\n    ),\n});\n\n/**\n * Tool for retrieving Hedera transaction details.\n * This is a read-only operation that queries the mirror node.\n */\nexport class HederaGetTransactionTool extends BaseHederaQueryTool<\n  typeof GetTransactionZodSchema\n> {\n  name = 'hedera-get-transaction';\n  description =\n    'Retrieves detailed information about a Hedera transaction by transaction ID or hash.';\n  specificInputSchema = GetTransactionZodSchema;\n  namespace = 'transaction';\n\n  constructor(params: BaseHederaQueryToolParams) {\n    super(params);\n  }\n\n  protected async executeQuery(\n    args: z.infer<typeof GetTransactionZodSchema>\n  ): Promise<unknown> {\n    this.logger.info(\n      `Getting transaction details for: ${args.transactionIdOrHash}`\n    );\n\n    const transaction = await this.hederaKit\n      .query()\n      .getTransaction(args.transactionIdOrHash);\n\n    if (!transaction) {\n      return {\n        success: false,\n        error: `Transaction ${args.transactionIdOrHash} not found`,\n      };\n    }\n\n    return {\n      success: true,\n      transactionIdOrHash: args.transactionIdOrHash,\n      transaction,\n    };\n  }\n}\n","import { IPlugin, BasePluginContext, HederaTool } from './PluginInterface';\n\n/**\n * Base class for plugins to simplify implementation\n */\nexport abstract class BasePlugin<T extends BasePluginContext = BasePluginContext> implements IPlugin<T> {\n  abstract id: string;\n  abstract name: string;\n  abstract description: string;\n  abstract version: string;\n  abstract author: string;\n\n  protected context!: T;\n\n  /**\n   * Initialize the plugin with the provided context\n   * @param context The context containing shared resources\n   */\n  async initialize(context: T): Promise<void> {\n    this.context = context;\n  }\n\n  /**\n   * Get the tools provided by this plugin\n   * @returns Array of tools provided by this plugin\n   */\n  abstract getTools(): HederaTool[];\n\n  /**\n   * Clean up resources when the plugin is unloaded\n   * Default implementation does nothing\n   */\n  async cleanup(): Promise<void> {\n\n  }\n}","import { BasePlugin } from '../BasePlugin';\nimport type { GenericPluginContext, HederaTool, IPlugin } from '../PluginInterface';\nimport {\n  HederaAirdropTokenTool,\n  HederaAssociateTokensTool,\n  HederaClaimAirdropTool,\n  HederaCreateFungibleTokenTool,\n  HederaCreateNftTool,\n  HederaMintFungibleTokenTool,\n  HederaMintNftTool,\n  HederaRejectTokensTool,\n  HederaTransferTokensTool,\n  HederaDissociateTokensTool,\n  HederaUpdateTokenTool,\n  HederaDeleteTokenTool,\n  HederaPauseTokenTool,\n  HederaUnpauseTokenTool,\n  HederaFreezeTokenAccountTool,\n  HederaUnfreezeTokenAccountTool,\n  HederaGrantKycTokenTool,\n  HederaRevokeKycTokenTool,\n  HederaWipeTokenAccountTool,\n  HederaTokenFeeScheduleUpdateTool,\n  HederaTransferNftTool,\n  HederaBurnFungibleTokenTool,\n  HederaBurnNftTool,\n  HederaGetTokenInfoTool,\n  HederaValidateNftOwnershipTool\n} from '../../langchain';\nimport { ModelCapability } from '../../types/model-capability';\n\nexport class HederaHTSPlugin extends BasePlugin<GenericPluginContext> implements IPlugin<GenericPluginContext> {\n  id = 'hedera-hts';\n  name = 'Hedera Token Service Plugin';\n  description = 'Provides tools for interacting with the Hedera Token Service (HTS).';\n  version = '1.0.0';\n  author = 'Auto-Generated';\n\n  private tools: HederaTool[] = [];\n\n  override async initialize(context: GenericPluginContext): Promise<void> {\n    await super.initialize(context);\n    const hederaKit = context.config.hederaKit as import('../../agent/agent').HederaAgentKit;\n    const logger = context.logger;\n    let modelCapability: ModelCapability = ModelCapability.MEDIUM;\n    if (\n      context.config.modelCapability &&\n      Object.values(ModelCapability).includes(context.config.modelCapability as ModelCapability)\n    ) {\n      modelCapability = context.config.modelCapability as ModelCapability;\n    }\n    const toolParams = { hederaKit, logger };\n    const queryToolParams = { hederaKit, logger, modelCapability };\n    this.tools = [\n      new HederaAirdropTokenTool(toolParams),\n      new HederaAssociateTokensTool(toolParams),\n      new HederaClaimAirdropTool(toolParams),\n      new HederaCreateFungibleTokenTool(toolParams),\n      new HederaCreateNftTool(toolParams),\n      new HederaMintFungibleTokenTool(toolParams),\n      new HederaMintNftTool(toolParams),\n      new HederaRejectTokensTool(toolParams),\n      new HederaTransferTokensTool(toolParams),\n      new HederaDissociateTokensTool(toolParams),\n      new HederaUpdateTokenTool(toolParams),\n      new HederaDeleteTokenTool(toolParams),\n      new HederaPauseTokenTool(toolParams),\n      new HederaUnpauseTokenTool(toolParams),\n      new HederaFreezeTokenAccountTool(toolParams),\n      new HederaUnfreezeTokenAccountTool(toolParams),\n      new HederaGrantKycTokenTool(toolParams),\n      new HederaRevokeKycTokenTool(toolParams),\n      new HederaWipeTokenAccountTool(toolParams),\n      new HederaTokenFeeScheduleUpdateTool(toolParams),\n      new HederaTransferNftTool(toolParams),\n      new HederaBurnFungibleTokenTool(toolParams),\n      new HederaBurnNftTool(toolParams),\n      new HederaGetTokenInfoTool(queryToolParams),\n      new HederaValidateNftOwnershipTool(queryToolParams)\n    ];\n  }\n\n  override getTools(): HederaTool[] {\n    return this.tools;\n  }\n}\n\nexport default HederaHTSPlugin; ","import { BasePlugin } from '../BasePlugin';\nimport type { GenericPluginContext, HederaTool, IPlugin } from '../PluginInterface';\nimport {\n  HederaCreateTopicTool,\n  HederaDeleteTopicTool,\n  HederaUpdateTopicTool,\n  HederaSubmitMessageTool,\n  HederaGetTopicInfoTool,\n  HederaGetTopicFeesTool,\n  HederaGetTopicMessages\n} from '../../langchain';\nimport { ModelCapability } from '../../types/model-capability';\n\nexport class HederaHCSPlugin extends BasePlugin<GenericPluginContext> implements IPlugin<GenericPluginContext> {\n  id = 'hedera-hcs';\n  name = 'Hedera Consensus Service Plugin';\n  description = 'Provides tools for interacting with the Hedera Consensus Service (HCS).';\n  version = '1.0.0';\n  author = 'Auto-Generated';\n\n  private tools: HederaTool[] = [];\n\n  override async initialize(context: GenericPluginContext): Promise<void> {\n    await super.initialize(context);\n    const hederaKit = context.config.hederaKit as import('../../agent/agent').HederaAgentKit;\n    const logger = context.logger;\n    let modelCapability: ModelCapability = ModelCapability.MEDIUM;\n    if (\n      context.config.modelCapability &&\n      Object.values(ModelCapability).includes(context.config.modelCapability as ModelCapability)\n    ) {\n      modelCapability = context.config.modelCapability as ModelCapability;\n    }\n    const toolParams = { hederaKit, logger };\n    const queryToolParams = { hederaKit, logger, modelCapability };\n    this.tools = [\n      new HederaCreateTopicTool(toolParams),\n      new HederaDeleteTopicTool(toolParams),\n      new HederaUpdateTopicTool(toolParams),\n      new HederaSubmitMessageTool(toolParams),\n      new HederaGetTopicInfoTool(queryToolParams),\n      new HederaGetTopicFeesTool(queryToolParams),\n      new HederaGetTopicMessages(queryToolParams)\n    ];\n  }\n\n  override getTools(): HederaTool[] {\n    return this.tools;\n  }\n}\n\nexport default HederaHCSPlugin; ","import { BasePlugin } from '../BasePlugin';\nimport type { GenericPluginContext, HederaTool, IPlugin } from '../PluginInterface';\nimport {\n  HederaApproveFungibleTokenAllowanceTool,\n  HederaApproveHbarAllowanceTool,\n  HederaApproveTokenNftAllowanceTool,\n  HederaCreateAccountTool,\n  HederaDeleteAccountTool,\n  HederaUpdateAccountTool,\n  HederaTransferHbarTool,\n  HederaRevokeHbarAllowanceTool,\n  HederaRevokeFungibleTokenAllowanceTool,\n  SignAndExecuteScheduledTransactionTool,\n  HederaDeleteNftSpenderAllowanceTool,\n  HederaDeleteNftSerialAllowancesTool,\n  HederaGetAccountBalanceTool,\n  HederaGetAccountPublicKeyTool,\n  HederaGetAccountInfoTool,\n  HederaGetAccountTokensTool,\n  HederaGetAccountNftsTool,\n  HederaGetOutstandingAirdropsTool,\n  HederaGetPendingAirdropsTool\n} from '../../langchain';\nimport { ModelCapability } from '../../types/model-capability';\n\nexport class HederaAccountPlugin extends BasePlugin<GenericPluginContext> implements IPlugin<GenericPluginContext> {\n  id = 'hedera-account';\n  name = 'Hedera Account Plugin';\n  description = 'Provides tools for interacting with Hedera accounts.';\n  version = '1.0.0';\n  author = 'Hedera Hashgraph';\n\n  private tools: HederaTool[] = [];\n\n  override async initialize(context: GenericPluginContext): Promise<void> {\n    await super.initialize(context);\n    const hederaKit = context.config.hederaKit as import('../../agent/agent').HederaAgentKit;\n    const logger = context.logger;\n    let modelCapability: ModelCapability = ModelCapability.MEDIUM;\n    if (\n      context.config.modelCapability &&\n      Object.values(ModelCapability).includes(context.config.modelCapability as ModelCapability)\n    ) {\n      modelCapability = context.config.modelCapability as ModelCapability;\n    }\n    const toolParams = { hederaKit, logger };\n    const queryToolParams = { hederaKit, logger, modelCapability };\n    this.tools = [\n      new HederaApproveFungibleTokenAllowanceTool(toolParams),\n      new HederaApproveHbarAllowanceTool(toolParams),\n      new HederaApproveTokenNftAllowanceTool(toolParams),\n      new HederaCreateAccountTool(toolParams),\n      new HederaDeleteAccountTool(toolParams),\n      new HederaUpdateAccountTool(toolParams),\n      new HederaTransferHbarTool(toolParams),\n      new HederaRevokeHbarAllowanceTool(toolParams),\n      new HederaRevokeFungibleTokenAllowanceTool(toolParams),\n      new SignAndExecuteScheduledTransactionTool(toolParams),\n      new HederaDeleteNftSpenderAllowanceTool(toolParams),\n      new HederaDeleteNftSerialAllowancesTool(toolParams),\n      new HederaGetAccountBalanceTool(queryToolParams),\n      new HederaGetAccountPublicKeyTool(queryToolParams),\n      new HederaGetAccountInfoTool(queryToolParams),\n      new HederaGetAccountTokensTool(queryToolParams),\n      new HederaGetAccountNftsTool(queryToolParams),\n      new HederaGetOutstandingAirdropsTool(queryToolParams),\n      new HederaGetPendingAirdropsTool(queryToolParams)\n    ];\n  }\n\n  override getTools(): HederaTool[] {\n    return this.tools;\n  }\n}\n\nexport default HederaAccountPlugin; ","import { BasePlugin } from '../BasePlugin';\nimport type { GenericPluginContext, HederaTool, IPlugin } from '../PluginInterface';\nimport {\n  HederaUpdateContractTool,\n  HederaDeleteContractTool,\n  HederaGetContractsTool,\n  HederaGetContractTool\n} from '../../langchain';\nimport { ModelCapability } from '../../types/model-capability';\n\nexport class HederaSCSPlugin extends BasePlugin<GenericPluginContext> implements IPlugin<GenericPluginContext> {\n  id = 'hedera-scs';\n  name = 'Hedera Smart Contract Service Plugin';\n  description = 'Provides tools for interacting with the Hedera Smart Contract Service (SCS).';\n  version = '1.0.0';\n  author = 'Auto-Generated';\n\n  private tools: HederaTool[] = [];\n\n  override async initialize(context: GenericPluginContext): Promise<void> {\n    await super.initialize(context);\n    const hederaKit = context.config.hederaKit as import('../../agent/agent').HederaAgentKit;\n    const logger = context.logger;\n    let modelCapability: ModelCapability = ModelCapability.MEDIUM;\n    if (\n      context.config.modelCapability &&\n      Object.values(ModelCapability).includes(context.config.modelCapability as ModelCapability)\n    ) {\n      modelCapability = context.config.modelCapability as ModelCapability;\n    }\n    const toolParams = { hederaKit, logger };\n    const queryToolParams = { hederaKit, logger, modelCapability };\n    this.tools = [\n      new HederaUpdateContractTool(toolParams),\n      new HederaDeleteContractTool(toolParams),\n      new HederaGetContractsTool(queryToolParams),\n      new HederaGetContractTool(queryToolParams)\n    ];\n  }\n\n  override getTools(): HederaTool[] {\n    return this.tools;\n  }\n}\n\nexport default HederaSCSPlugin; ","import { BasePlugin } from '../BasePlugin';\nimport type { GenericPluginContext, HederaTool, IPlugin } from '../PluginInterface';\nimport {\n  HederaGetHbarPriceTool,\n  HederaGetBlocksTool,\n  HederaGetNetworkInfoTool,\n  HederaGetNetworkFeesTool\n} from '../../langchain';\nimport { ModelCapability } from '../../types/model-capability';\n\nexport class HederaNetworkPlugin extends BasePlugin<GenericPluginContext> implements IPlugin<GenericPluginContext> {\n  id = 'hedera-network';\n  name = 'Hedera Network Plugin';\n  description = 'Provides tools for interacting with the Hedera network and mirror node.';\n  version = '1.0.0';\n  author = 'Auto-Generated';\n\n  private tools: HederaTool[] = [];\n\n  override async initialize(context: GenericPluginContext): Promise<void> {\n    await super.initialize(context);\n    const hederaKit = context.config.hederaKit as import('../../agent/agent').HederaAgentKit;\n    const logger = context.logger;\n    let modelCapability: ModelCapability = ModelCapability.MEDIUM;\n    if (\n      context.config.modelCapability &&\n      Object.values(ModelCapability).includes(context.config.modelCapability as ModelCapability)\n    ) {\n      modelCapability = context.config.modelCapability as ModelCapability;\n    }\n    const queryToolParams = { hederaKit, logger, modelCapability };\n    this.tools = [\n      new HederaGetHbarPriceTool(queryToolParams),\n      new HederaGetBlocksTool(queryToolParams),\n      new HederaGetNetworkInfoTool(queryToolParams),\n      new HederaGetNetworkFeesTool(queryToolParams)\n    ];\n  }\n\n  override getTools(): HederaTool[] {\n    return this.tools;\n  }\n}\n\nexport default HederaNetworkPlugin; ","import { AbstractSigner } from '../signer/abstract-signer';\nimport { HederaAgentKit, PluginConfig } from './agent';\nimport { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport { ChatOpenAI, ChatOpenAIFields } from '@langchain/openai';\nimport {\n  ChatPromptTemplate,\n  MessagesPlaceholder,\n} from '@langchain/core/prompts';\nimport { AIMessage, BaseMessage, HumanMessage } from '@langchain/core/messages';\nimport { TransactionReceipt } from '@hashgraph/sdk';\nimport { StructuredTool } from '@langchain/core/tools';\nimport { AgentOperationalMode, MirrorNodeConfig } from '../types';\nimport { ModelCapability } from '../types/model-capability';\nimport { ModelCapabilityDetector } from '../utils/model-capability-detector';\nimport {\n  TokenUsageCallbackHandler,\n  TokenUsage,\n  CostCalculation,\n  calculateTokenCostSync,\n} from '../utils/token-usage-tracker';\nimport { Logger } from '../utils/logger';\nimport { AgentExecutor, createOpenAIToolsAgent } from 'langchain/agents';\n\n/**\n * Configuration for the HederaConversationalAgent.\n */\nexport interface HederaConversationalAgentConfig {\n  operationalMode?: AgentOperationalMode;\n  pluginConfig?: PluginConfig;\n  userAccountId?: string | undefined;\n  customSystemMessagePreamble?: string;\n  customSystemMessagePostamble?: string;\n  verbose?: boolean;\n  llm?: BaseChatModel;\n  openAIApiKey?: string;\n  openAIModelName?: string;\n  scheduleUserTransactionsInBytesMode?: boolean;\n  modelCapability?: ModelCapability;\n  mirrorNodeConfig?: MirrorNodeConfig;\n  disableLogging?: boolean;\n}\n\n/**\n * Defines the structured response from the HederaConversationalAgent's processMessage method.\n */\nexport interface AgentResponse {\n  output: string;\n  message?: string;\n  transactionBytes?: string | undefined;\n  receipt?: TransactionReceipt | object | undefined;\n  scheduleId?: string | undefined;\n  transactionId?: string | undefined;\n  notes?: string[];\n  error?: string | undefined;\n  intermediateSteps?: unknown;\n  rawToolOutput?: unknown;\n  tokenUsage?: TokenUsage | undefined;\n  cost?: CostCalculation | undefined;\n  [key: string]: unknown;\n}\n\n/**\n * Expected structure of a successful JSON output from BaseHederaTransactionTool.\n */\ninterface SuccessfulToolOutput {\n  success: true;\n  transactionBytes?: string;\n  receipt?: TransactionReceipt | object;\n  scheduleId?: string;\n  transactionId?: string;\n  notes?: string[];\n  op?: string;\n  description?: string;\n  output?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Expected structure of a failed JSON output from BaseHederaTransactionTool.\n */\ninterface FailedToolOutput {\n  success: false;\n  error: string;\n  transactionId?: string;\n  notes?: string[];\n  output?: string;\n  [key: string]: unknown;\n}\n\ntype ParsedToolOutput = SuccessfulToolOutput | FailedToolOutput;\n\n/**\n * HederaConversationalAgent orchestrates interactions between an LLM, HederaAgentKit tools,\n * and the user to facilitate Hedera Network operations via a conversational interface.\n */\nexport class HederaConversationalAgent {\n  private hederaKit: HederaAgentKit;\n  private llm: BaseChatModel;\n  private agentExecutor!: AgentExecutor;\n  private logger: Logger;\n  private config: HederaConversationalAgentConfig;\n  private systemMessage!: string;\n  private tokenUsageHandler: TokenUsageCallbackHandler;\n\n  /**\n   * Creates an instance of HederaConversationalAgent.\n   * @param {AbstractSigner} signer - The signer implementation for Hedera transactions.\n   * @param {HederaConversationalAgentConfig} [config={}] - Configuration options for the agent.\n   */\n  constructor(\n    signer: AbstractSigner,\n    config: HederaConversationalAgentConfig = {}\n  ) {\n    this.config = {\n      operationalMode: 'returnBytes',\n      verbose: false,\n      scheduleUserTransactionsInBytesMode: true,\n      ...config,\n    };\n\n    const initialModelCapability =\n      this.config.modelCapability ||\n      ModelCapabilityDetector.getInstance().getModelCapabilitySync(\n        config.openAIModelName\n      );\n\n    const shouldDisableLogs =\n      this.config.disableLogging || process.env.DISABLE_LOGS === 'true';\n    const defaultLogLevel = this.config.verbose ? 'debug' : 'info';\n    const logLevel = shouldDisableLogs ? 'silent' : defaultLogLevel;\n\n    this.logger = new Logger({\n      level: logLevel,\n      module: 'HederaConversationalAgent',\n      silent: shouldDisableLogs,\n    });\n\n    this.hederaKit = new HederaAgentKit(\n      signer,\n      this.config.pluginConfig,\n      this.config.operationalMode,\n      this.config.userAccountId,\n      this.config.scheduleUserTransactionsInBytesMode,\n      initialModelCapability,\n      this.config.openAIModelName ||\n        process.env.OPENAI_MODEL_NAME ||\n        'gpt-4o-mini',\n      this.config.mirrorNodeConfig,\n      shouldDisableLogs\n    );\n\n    const modelName =\n      this.config.openAIModelName ||\n      process.env.OPENAI_MODEL_NAME ||\n      'gpt-4o-mini';\n\n    this.tokenUsageHandler = new TokenUsageCallbackHandler(\n      modelName,\n      this.logger\n    );\n\n    if (this.config.llm) {\n      this.llm = this.config.llm;\n    } else {\n      const apiKey = this.config.openAIApiKey || process.env.OPENAI_API_KEY;\n      if (!apiKey) {\n        throw new Error(\n          'OpenAI API key is required. Provide it in config or via OPENAI_API_KEY env variable.'\n        );\n      }\n      this.llm = new ChatOpenAI({\n        apiKey: apiKey,\n        modelName: modelName,\n        temperature: 0.1,\n        callbacks: [this.tokenUsageHandler],\n      } as ChatOpenAIFields);\n    }\n  }\n\n  /**\n   * Constructs the system message for the LLM based on configuration.\n   * @returns {string} The system message string.\n   */\n  private constructSystemMessage(): string {\n    let messageParts: string[] = [];\n    const agentOperatorId = this.hederaKit.signer.getAccountId().toString();\n    const userAccId = this.config.userAccountId;\n\n    if (this.config.customSystemMessagePreamble) {\n      messageParts.push(this.config.customSystemMessagePreamble);\n    }\n    messageParts.push(\n      `You are a helpful Hedera assistant. Your primary operator account is ${agentOperatorId}. ` +\n        `You have tools to interact with the Hedera network. ` +\n        `When using any tool, provide all necessary parameters as defined by that tool's schema and description.`\n    );\n    if (userAccId) {\n      messageParts.push(\n        `The user you are assisting has a personal Hedera account ID: ${userAccId}. ` +\n          `IMPORTANT: When the user says things like \"I want to send HBAR\" or \"transfer my tokens\", you MUST use ${userAccId} as the sender/from account. ` +\n          `For example, if user says \"I want to send 2 HBAR to 0.0.800\", you must set up a transfer where ${userAccId} sends the HBAR, not your operator account.`\n      );\n    }\n    if (this.hederaKit.operationalMode === 'autonomous') {\n      messageParts.push(\n        `\\nOPERATIONAL MODE: 'autonomous'. Your goal is to execute transactions directly using your tools. ` +\n          `Your account ${agentOperatorId} will be the payer for these transactions. ` +\n          `Even if the user's account (${\n            userAccId || 'a specified account'\n          }) is the actor in the transaction body (e.g., sender of HBAR), ` +\n          `you (the agent with operator ${agentOperatorId}) are still executing and paying. For HBAR transfers, ensure the amounts in the 'transfers' array sum to zero (as per tool schema), balancing with your operator account if necessary.`\n      );\n    } else {\n      if (this.config.scheduleUserTransactionsInBytesMode && userAccId) {\n        messageParts.push(\n          `\\nOPERATIONAL MODE: 'returnBytes' with scheduled transactions for user actions. ` +\n            `When a user asks for a transaction to be prepared (e.g., creating a token, topic, transferring assets for them to sign, etc), ` +\n            `you MUST default to creating a Scheduled Transaction using the appropriate tool with the metaOption 'schedule: true'. ` +\n            `The user (with account ID ${userAccId}) will be the one to ultimately pay for and (if needed) sign the inner transaction. ` +\n            `Your operator account (${agentOperatorId}) will pay for creating the schedule entity itself. ` +\n            `You MUST return the ScheduleId and details of the scheduled operation in a structured JSON format with these fields: success, op, schedule_id, description, payer_account_id_scheduled_tx, and scheduled_transaction_details.` +\n            `\\nOnce a transaction is scheduled and you\\'ve provided the Schedule ID, you should ask the user if they want to sign and execute it. If they agree, use the \\'hedera-sign-and-execute-scheduled-transaction\\' tool, providing the Schedule ID. This tool will prepare a ScheduleSignTransaction. If the agent is also configured for \\'returnBytes\\', this ScheduleSignTransaction will be returned as bytes for the user to sign and submit using their account ${userAccId}. If the agent is in \\'autonomous\\' mode for the ScheduleSign part (not typical for user-scheduled flows but possible), the agent would sign and submit it.`\n        );\n      } else {\n        messageParts.push(\n          `\\nOPERATIONAL MODE: 'returnBytes'. Your goal is to provide transaction bytes directly. ` +\n            `When a user asks for a transaction to be prepared (e.g., for them to sign, or for scheduling without the default scheduling flow), ` +\n            `you MUST call the appropriate tool. If you want raw bytes for the user to sign for their own account ${\n              userAccId || 'if specified'\n            }, ensure the tool constructs the transaction body accordingly and use metaOption 'returnBytes: true' if available, or ensure the builder is configured for the user. ` +\n            (userAccId\n              ? `If the transaction body was constructed to reflect the user's account ${userAccId} as the actor, also inform the user the application can adapt these bytes for their signing and payment using their account ${userAccId}.`\n              : '')\n        );\n      }\n    }\n    messageParts.push(\n      '\\nAlways be concise. If the tool provides a JSON string as its primary output (especially in returnBytes mode), make your accompanying text brief. If the tool does not provide JSON output or an error occurs, your narrative becomes primary; if notes were generated by the tool in such cases, append them to your textual response.'\n    );\n    if (this.config.customSystemMessagePostamble) {\n      messageParts.push(this.config.customSystemMessagePostamble);\n    }\n    return messageParts.join('\\n');\n  }\n\n  /**\n   * Initializes the conversational agent, including its internal HederaAgentKit and LangChain components.\n   * Must be called before `processMessage`.\n   */\n  public async initialize(): Promise<void> {\n    const detectedCapability =\n      await ModelCapabilityDetector.getInstance().getModelCapability(\n        this.config.openAIModelName\n      );\n    if (detectedCapability !== this.hederaKit.modelCapability) {\n      this.hederaKit.modelCapability = detectedCapability;\n      this.logger.info(\n        `Updated model capability to ${detectedCapability} after API fetch`\n      );\n    }\n\n    await this.hederaKit.initialize();\n    this.systemMessage = this.constructSystemMessage();\n    const toolsFromKit = this.hederaKit.getAggregatedLangChainTools();\n\n    if (toolsFromKit.length === 0) {\n      this.logger.warn(\n        'No tools were loaded into HederaAgentKit. The agent may not function correctly.'\n      );\n    }\n\n    this.logger.info(\n      `Loaded ${toolsFromKit.length} tools for model capability: ${this.hederaKit.modelCapability}`\n    );\n\n    const prompt = ChatPromptTemplate.fromMessages([\n      ['system', this.systemMessage],\n      new MessagesPlaceholder('chat_history'),\n      ['human', '{input}'],\n      new MessagesPlaceholder('agent_scratchpad'),\n    ]);\n    const agent = await createOpenAIToolsAgent({\n      llm: this.llm,\n      tools: toolsFromKit as unknown as StructuredTool[],\n      prompt,\n    });\n    this.agentExecutor = new AgentExecutor({\n      agent,\n      tools: toolsFromKit as unknown as StructuredTool[],\n      verbose: this.config.verbose ?? false,\n      returnIntermediateSteps: true,\n    });\n    this.logger.info('HederaConversationalAgent initialized.');\n  }\n\n  /**\n   * Processes a user's input message and returns the agent's response.\n   * @param {string} userInput - The user's input string.\n   * @param {Array<{ type: 'human' | 'ai'; content: string }>} [chatHistoryInput] - Optional existing chat history.\n   * @returns {Promise<AgentResponse>} The agent's structured response.\n   */\n  public async processMessage(\n    userInput: string,\n    chatHistoryInput?: Array<{ type: 'human' | 'ai'; content: string }>\n  ): Promise<AgentResponse> {\n    if (!this.agentExecutor) {\n      throw new Error(\n        'HederaConversationalAgent not initialized. Call await initialize() first.'\n      );\n    }\n\n    const langchainChatHistory: BaseMessage[] = (chatHistoryInput || []).map(\n      (msg) =>\n        msg.type === 'human'\n          ? new HumanMessage(msg.content)\n          : new AIMessage(msg.content)\n    );\n\n    let response: AgentResponse = {\n      output: '',\n      message: '',\n      notes: [],\n      transactionBytes: undefined,\n      receipt: undefined,\n      scheduleId: undefined,\n      transactionId: undefined,\n      error: undefined,\n      intermediateSteps: undefined,\n      rawToolOutput: undefined,\n      tokenUsage: undefined,\n      cost: undefined,\n    };\n\n    try {\n      const result = await this.agentExecutor.invoke({\n        input: userInput,\n        chat_history: langchainChatHistory,\n      });\n\n      response.message = result.output || '';\n      let parsedSteps = result?.intermediateSteps?.[0]\n        ?.observation as ParsedToolOutput[];\n      if (parsedSteps) {\n        try {\n          response = {\n            ...response,\n            ...JSON.parse(parsedSteps as unknown as string),\n          };\n        } catch (e) {\n          this.logger.error('Error parsing intermediate steps:', e);\n        }\n      }\n\n      if (!response.output || response.output.trim() === '') {\n        response.output = 'Agent action complete.';\n      }\n\n      const tokenUsage = this.tokenUsageHandler.getLatestTokenUsage();\n      if (tokenUsage) {\n        response.tokenUsage = tokenUsage;\n        response.cost = calculateTokenCostSync(tokenUsage);\n\n        this.logger.debug('Token usage for request:', {\n          promptTokens: tokenUsage.promptTokens,\n          completionTokens: tokenUsage.completionTokens,\n          totalTokens: tokenUsage.totalTokens,\n          cost: response.cost.totalCost,\n        });\n      }\n\n      return response;\n    } catch (error: unknown) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      this.logger.error(\n        `Error in HederaConversationalAgent.processMessage: ${errorMessage}`,\n        error\n      );\n\n      const tokenUsage = this.tokenUsageHandler.getLatestTokenUsage();\n      let cost: CostCalculation | undefined;\n      if (tokenUsage) {\n        cost = calculateTokenCostSync(tokenUsage);\n      }\n\n      return {\n        output: 'Sorry, I encountered an error processing your request.',\n        message: response.message || '',\n        notes: response.notes || [],\n        error: errorMessage,\n        transactionBytes: response?.transactionBytes,\n        receipt: response.receipt,\n        scheduleId: response.scheduleId,\n        transactionId: response.transactionId,\n        intermediateSteps: response.intermediateSteps,\n        rawToolOutput: response.rawToolOutput,\n        tokenUsage: tokenUsage || undefined,\n        cost,\n      };\n    }\n  }\n\n  /**\n   * Allows updating the operational mode of the agent after instantiation.\n   * This also updates the underlying HederaAgentKit's mode and reconstructs the system message for the LLM.\n   * Note: For the new system prompt to take full effect with the existing LangChain agent,\n   * re-initialization (calling `initialize()`) or recreation of the agent executor might be needed.\n   * @param {AgentOperationalMode} mode - The new operational mode.\n   */\n  public setOperationalMode(mode: AgentOperationalMode): void {\n    this.config.operationalMode = mode;\n    this.hederaKit.operationalMode = mode;\n    this.systemMessage = this.constructSystemMessage();\n    this.logger.info(\n      `Operational mode set to: ${mode}. System message and kit mode updated.`\n    );\n    if (this.agentExecutor) {\n      this.logger.warn(\n        'Operational mode changed. For the new system prompt to fully take effect, re-initialization (call initialize()) or recreation of the agent executor is needed.'\n      );\n    }\n  }\n\n  /**\n   * Get cumulative token usage across all requests\n   * @returns {TokenUsage & { cost: CostCalculation }} Total token usage and cost\n   */\n  public getTotalTokenUsage(): TokenUsage & { cost: CostCalculation } {\n    const totalUsage = this.tokenUsageHandler.getTotalTokenUsage();\n    const cost = calculateTokenCostSync(totalUsage);\n    return { ...totalUsage, cost };\n  }\n\n  /**\n   * Get token usage history for all requests\n   * @returns {Array<TokenUsage & { cost: CostCalculation }>} Array of token usage records with costs\n   */\n  public getTokenUsageHistory(): Array<TokenUsage & { cost: CostCalculation }> {\n    return this.tokenUsageHandler.getTokenUsageHistory().map((usage) => ({\n      ...usage,\n      cost: calculateTokenCostSync(usage),\n    }));\n  }\n\n  /**\n   * Reset token usage tracking\n   */\n  public resetTokenUsageTracking(): void {\n    this.tokenUsageHandler.reset();\n    this.logger.info('Token usage tracking has been reset');\n  }\n\n  public getKit(): HederaAgentKit {\n    return this.hederaKit;\n  }\n}\n","import { IPlugin, PluginContext, HederaTool } from './PluginInterface';\nimport { Logger } from '../utils/logger';\n\n/**\n * Registry for managing plugins in the Hedera Agent Kit\n */\nexport class PluginRegistry {\n  private plugins: Map<string, IPlugin> = new Map();\n  private context: PluginContext;\n  private logger: Logger;\n\n  /**\n   * Creates a new PluginRegistry instance\n   * @param context The context to provide to plugins during initialization\n   */\n  constructor(context: PluginContext) {\n    this.context = context;\n    this.logger = context.logger;\n  }\n\n  /**\n   * Register a plugin with the registry\n   * @param plugin The plugin to register\n   * @throws Error if a plugin with the same ID is already registered\n   */\n  async registerPlugin(plugin: IPlugin): Promise<void> {\n    if (this.plugins.has(plugin.id)) {\n      throw new Error(`Plugin with ID ${plugin.id} is already registered`);\n    }\n\n    await plugin.initialize(this.context);\n    this.plugins.set(plugin.id, plugin);\n    this.logger.info(`Plugin registered: ${plugin.name} (${plugin.id}) v${plugin.version}`);\n  }\n\n  /**\n   * Get a plugin by ID\n   * @param id The ID of the plugin to retrieve\n   * @returns The plugin, or undefined if not found\n   */\n  getPlugin(id: string): IPlugin | undefined {\n    return this.plugins.get(id);\n  }\n\n  /**\n   * Get all registered plugins\n   * @returns Array of all registered plugins\n   */\n  getAllPlugins(): IPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Get all tools from all registered plugins\n   * @returns Array of all tools provided by registered plugins\n   */\n  getAllTools(): HederaTool[] {\n    return this.getAllPlugins().flatMap(plugin => plugin.getTools());\n  }\n\n  /**\n   * Unregister a plugin\n   * @param id The ID of the plugin to unregister\n   * @returns true if the plugin was unregistered, false if it wasn't found\n   */\n  async unregisterPlugin(id: string): Promise<boolean> {\n    const plugin = this.plugins.get(id);\n    if (!plugin) {\n      return false;\n    }\n\n    if (plugin.cleanup) {\n      try {\n        await plugin.cleanup();\n      } catch (error) {\n        this.logger.error(`Error during plugin cleanup: ${error}`);\n      }\n    }\n\n    const result = this.plugins.delete(id);\n    if (result) {\n      this.logger.info(`Plugin unregistered: ${plugin.name} (${plugin.id})`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Unregister all plugins\n   */\n  async unregisterAllPlugins(): Promise<void> {\n    const pluginIds = Array.from(this.plugins.keys());\n    for (const id of pluginIds) {\n      await this.unregisterPlugin(id);\n    }\n  }\n}","import {\n  AccountId,\n  Client,\n  PrivateKey,\n  Transaction,\n  TransactionResponse,\n  TransactionReceipt,\n} from '@hashgraph/sdk';\nimport { AbstractSigner } from './abstract-signer';\nimport { HederaNetworkType } from '../types';\nimport { Logger } from '../utils/logger';\nimport { detectKeyTypeFromString } from '../utils/key-type-detector';\n\n/**\n * A signer implementation for server-side environments that uses a private key for signing.\n * It directly interacts with the Hedera network using an operator-configured client.\n */\nexport class ServerSigner extends AbstractSigner {\n  private client: Client;\n  private accountIdInternal: AccountId;\n  private privateKey: PrivateKey;\n  private networkInternal: HederaNetworkType;\n  private keyType: 'ed25519' | 'ecdsa' = 'ed25519';\n  private logger: Logger;\n  private privateKeyString: string;\n  private keyTypeVerified: boolean = false;\n\n  /**\n   * Constructs a ServerSigner instance.\n   * @param {string | AccountId} accountId - The Hedera account ID.\n   * @param {string | PrivateKey} privateKey - The private key for the account.\n   * @param {HederaNetworkType} network - The Hedera network to connect to ('mainnet' or 'testnet').\n   */\n  constructor(\n    accountId: string | AccountId,\n    privateKey: string | PrivateKey,\n    network: HederaNetworkType\n  ) {\n    super();\n    this.accountIdInternal = AccountId.fromString(accountId.toString());\n    this.networkInternal = network;\n    this.logger = new Logger({\n      module: 'ServerSigner',\n      level: process.env.DEBUG === 'true' ? 'debug' : 'warn',\n    });\n\n    this.initializeMirrorNode(this.networkInternal, 'ServerSigner');\n\n    if (network === 'mainnet') {\n      this.client = Client.forMainnet();\n    } else if (network === 'testnet') {\n      this.client = Client.forTestnet();\n    } else {\n      throw new Error(\n        `Unsupported Hedera network type specified: ${network}. Only 'mainnet' or 'testnet' are supported.`\n      );\n    }\n\n    if (typeof privateKey === 'string') {\n      this.privateKeyString = privateKey;\n      try {\n        const keyDetection = detectKeyTypeFromString(privateKey);\n        this.privateKey = keyDetection.privateKey;\n        this.keyType = keyDetection.detectedType;\n        this.initializeOperator();\n        this.logger.debug(`Detected key type from string: ${this.keyType}`);\n      } catch (error: unknown) {\n        this.logger.warn(\n          'Failed to detect key type from private key format, will query mirror node',\n          (error as Error).message\n        );\n        this.privateKey = PrivateKey.fromStringED25519(privateKey);\n        this.keyType = 'ed25519';\n      }\n    } else {\n      this.privateKey = privateKey;\n      this.privateKeyString = privateKey.toString();\n    }\n\n    this.client.setOperator(this.accountIdInternal, this.privateKey);\n  }\n\n  /**\n   * Initializes the operator by verifying the key type against the mirror node.\n   * This follows the pattern from standards-sdk to ensure the correct key type is used.\n   */\n  private async initializeOperator(): Promise<void> {\n    try {\n      const account = await this.mirrorNode.requestAccount(\n        this.accountIdInternal.toString()\n      );\n      const keyType = account?.key?._type;\n\n      let actualKeyType: 'ed25519' | 'ecdsa' = 'ed25519';\n\n      if (keyType?.includes('ECDSA')) {\n        actualKeyType = 'ecdsa';\n      } else if (keyType?.includes('ED25519')) {\n        actualKeyType = 'ed25519';\n      }\n\n      if (actualKeyType !== this.keyType) {\n        this.logger.debug(\n          `Key type mismatch detected. String detection: ${this.keyType}, Mirror node: ${actualKeyType}. Using mirror node result.`\n        );\n\n        this.keyType = actualKeyType;\n\n        if (this.privateKeyString) {\n          this.privateKey =\n            actualKeyType === 'ecdsa'\n              ? PrivateKey.fromStringECDSA(this.privateKeyString)\n              : PrivateKey.fromStringED25519(this.privateKeyString);\n\n          this.client.setOperator(this.accountIdInternal, this.privateKey);\n\n          this.logger.debug(\n            `Updated operator with verified key type: ${this.keyType}`\n          );\n        }\n      } else {\n        this.logger.debug(`Key type verification successful: ${this.keyType}`);\n      }\n      this.keyTypeVerified = true;\n    } catch (error) {\n      this.logger.error(\n        `Failed to verify key type from mirror node: ${\n          (error as Error).message\n        }`\n      );\n      this.keyTypeVerified = true;\n    }\n  }\n\n  /**\n   * Retrieves the Hedera account ID associated with this signer.\n   * @returns {AccountId} The Hedera AccountId object.\n   */\n  public getAccountId(): AccountId {\n    return this.accountIdInternal;\n  }\n\n  /**\n   * Signs and executes a Hedera transaction using the configured client and private key,\n   * and returns the transaction receipt.\n   * @param {Transaction} transaction - The transaction to sign and execute.\n   * @returns {Promise<TransactionReceipt>} A promise that resolves to the transaction receipt.\n   */\n  public async signAndExecuteTransaction(\n    transaction: Transaction\n  ): Promise<TransactionReceipt> {\n    if (!transaction.isFrozen()) {\n      if (transaction.transactionId) {\n        await transaction.freezeWith(this.client);\n      } else {\n        await transaction.freezeWith(this.client);\n      }\n    }\n    if (transaction.getSignatures().size === 0) {\n      await transaction.sign(this.privateKey);\n    }\n    const response: TransactionResponse = await transaction.execute(\n      this.client\n    );\n    return response.getReceipt(this.client);\n  }\n\n  /**\n   * Retrieves the Hedera network type this signer is configured for.\n   * @returns {HederaNetworkType} The configured Hedera network type ('mainnet' or 'testnet').\n   */\n  public getNetwork(): HederaNetworkType {\n    return this.networkInternal;\n  }\n\n  /**\n   * Retrieves the operator's private key associated with this signer.\n   * @returns {PrivateKey} The Hedera PrivateKey object.\n   */\n  public getOperatorPrivateKey(): PrivateKey {\n    return this.privateKey;\n  }\n\n  /**\n   * Retrieves the client instance configured for this ServerSigner.\n   * @returns {Client} The Hedera Client object.\n   */\n  public getClient(): Client {\n    return this.client;\n  }\n\n  /**\n   * Retrieves the key type of the operator's private key.\n   * @returns {Promise<'ed25519' | 'ecdsa'>} The key type.\n   */\n  public async getKeyType(): Promise<'ed25519' | 'ecdsa'> {\n    if (!this.keyTypeVerified && this.privateKeyString) {\n      await this.initializeOperator();\n    }\n    return this.keyType;\n  }\n\n  /**\n   * Retrieves the key type synchronously (without mirror node verification).\n   * @returns {'ed25519' | 'ecdsa'} The key type.\n   */\n  public getKeyTypeSync(): 'ed25519' | 'ecdsa' {\n    return this.keyType;\n  }\n}\n","export function convertStringToTimestamp(input: string): number {\n    const date = new Date(input);\n\n    if (isNaN(date.getTime())) {\n        throw new Error(\"Invalid date format\");\n    }\n\n    const timestamp = date.getTime();\n\n    return parseFloat((timestamp / 1000).toFixed(6));\n}","import { HederaNetworkType } from \"../types\";\n\nexport const createBaseMirrorNodeApiUrl = (networkType: HederaNetworkType): string => {\n    const networkBase = networkType === 'mainnet' ? `${networkType}-public` : networkType;\n    return `https://${networkBase}.mirrornode.hedera.com`\n}\n","import BigNumber from \"bignumber.js\";\r\n\r\nexport function fromDisplayToBaseUnit(\r\n  displayBalance: number,\r\n  decimals: number\r\n): number {\r\n  return displayBalance * 10 ** decimals;\r\n}\r\n\r\nexport function fromBaseToDisplayUnit(baseBalance: number, decimals: number): BigNumber {\r\n  const decimalsBigNumber = new BigNumber(decimals);\r\n  const divisor = new BigNumber(10).pow(decimalsBigNumber);\r\n\r\n  const bigValue = BigNumber.isBigNumber(baseBalance)\r\n    ? baseBalance\r\n    : new BigNumber(baseBalance);\r\n\r\n  return bigValue.dividedBy(divisor);\r\n}\r\n","import HederaHTSPlugin from './HederaHTSPlugin';\nimport HederaHCSPlugin from './HederaHCSPlugin';\nimport HederaAccountPlugin from './HederaAccountPlugin';\nimport HederaSCSPlugin from './HederaSCSPlugin';\nimport HederaNetworkPlugin from './HederaNetworkPlugin';\nimport { BasePlugin } from '../BasePlugin';\nimport { GenericPluginContext } from '../PluginInterface';\n\nexport function getAllHederaCorePlugins(): BasePlugin<GenericPluginContext>[] {\n  return [\n    new HederaHTSPlugin(),\n    new HederaHCSPlugin(),\n    new HederaAccountPlugin(),\n    new HederaSCSPlugin(),\n    new HederaNetworkPlugin(),\n  ];\n}\n\nexport {\n  HederaHTSPlugin,\n  HederaHCSPlugin,\n  HederaAccountPlugin,\n  HederaSCSPlugin,\n  HederaNetworkPlugin,\n};\n"],"names":["_Logger","constructor","options","globalDisable","process","env","DISABLE_LOGS","shouldSilence","silent","level","this","moduleContext","module","pinoOptions","enabled","transport","prettyPrint","target","colorize","translateTime","ignore","logger","pino","getInstance","moduleKey","instances","has","get","getLevel","delete","set","setLogLevel","setSilent","setModule","debug","args","info","warn","error","trace","Map","Logger","detectKeyTypeFromString","privateKeyString","detectedType","startsWith","length","privateKey","PrivateKey","fromStringECDSA","fromStringED25519","parseError","alternateType","secondError","Error","BaseServiceBuilder","hederaKit","currentTransaction","notes","kit","shouldDisableLogs","getEffectiveSenderAccountId","userAccountId","AccountId","fromString","signer","getAccountId","getTransferSourceAccount","isUserInitiated","setTransactionMemo","memo","setTransactionId","transactionId","setNodeAccountIds","nodeAccountIds","execute","innerTx","success","transactionToExecute","originalTransactionIdForReporting","toString","schedule","isFrozen","TransactionId","generate","scheduleCreateTx","ScheduleCreateTransaction","setScheduledTransaction","scheduleMemo","setScheduleMemo","setPayerAccountId","schedulePayerAccountId","payerForScheduleCreate","addNote","agentOperator","getOperator","adminKeyList","KeyList","setThreshold","publicKey","push","mirrorNode","userAccountInfo","requestAccount","key","PublicKey","e","message","Array","from","setAdminKey","freezeWith","client","receipt","signAndExecuteTransaction","result","scheduleId","console","log","getTransactionBytes","transactionForBytes","payerAccountId","scheduleAdminKey","Buffer","toBytes","executeWithSigner","newSigner","setCurrentTransaction","transaction","getCurrentTransaction","note","getNotes","clearNotes","parseKey","keyInput","toLowerCase","getPublicKey","e2","error2","substring","JSON","stringify","parseAmount","amount","Long","fromNumber","BigNumber","DEFAULT_AUTORENEW_PERIOD_SECONDS","HcsBuilder","super","createTopic","params","TopicCreateTransaction","setTopicMemo","adminKey","parsedAdminKey","feeScheduleKey","parsedFeeScheduleKey","setFeeScheduleKey","submitKey","parsedSubmitKey","setSubmitKey","autoRenewPeriod","setAutoRenewPeriod","autoRenewAccountId","setAutoRenewAccountId","customFees","setCustomFees","exemptAccountIds","publicKeys","accountIdStr","submitMessageToTopic","topicId","TopicId","messageContents","messageBytesLength","TopicMessageSubmitTransaction","setTopicId","setMessage","maxChunks","setMaxChunks","chunkSize","setChunkSize","deleteTopic","TopicDeleteTransaction","updateTopic","TopicUpdateTransaction","Object","prototype","hasOwnProperty","call","setFeeExemptKeys","generateDefaultSymbol","tokenName","symbol","replace","toUpperCase","mapToSdkCustomFees","fees","parseAmountFn","kitUserAccountId","kitOperationalMode","addNoteFn","map","feeData","feeCollectorSdkAccountId","feeCollectorStringToParse","feeCollectorAccountId","feeTypeForNote","type","fixedFee","CustomFixedFee","setFeeCollectorAccountId","setAmount","denominatingTokenId","setDenominatingTokenId","TokenId","fractionalFee","CustomFractionalFee","setNumerator","numerator","toNumber","setDenominator","denominator","minAmount","setMin","maxAmount","setMax","fractionalFeeData","assessmentMethodInclusive","setAssessmentMethod","FeeAssessmentMethod","Inclusive","Exclusive","royaltyFee","CustomRoyaltyFee","royaltyFeeData","fallbackFee","fallbackFeeCollectorSdkAccountId","fallbackFeeCollectorStringToParse","fallback","setFallbackFee","exhaustiveCheck","HtsBuilder","createFungibleToken","treasuryAccId","treasuryAccountId","operationalMode","sdkSupplyType","tokenSymbolToUse","tokenSymbol","supplyType","supplyTypeString","TokenSupplyType","Finite","Infinite","TokenCreateTransaction","setTokenName","setTokenSymbol","setTreasuryAccountId","setTokenType","TokenType","FungibleCommon","setSupplyType","setInitialSupply","initialSupply","setDecimals","decimals","maxSupply","setMaxSupply","parsedKey","kycKey","setKycKey","freezeKey","setFreezeKey","wipeKey","setWipeKey","supplyKey","setSupplyKey","pauseKey","setPauseKey","setTokenMemo","sdkCustomFees","bind","createNonFungibleToken","NonFungibleUnique","operator","query","getAccountInfo","mintFungibleToken","TokenMintTransaction","setTokenId","tokenId","burnFungibleToken","TokenBurnTransaction","mintNonFungibleToken","metadata","m","setMetadata","burnNonFungibleToken","serials","serialsAsLong","s","setSerials","transferNft","serialNum","serial","nftId","NftId","TransferTransaction","isApproved","addApprovedNftTransfer","senderAccountId","receiverAccountId","addNftTransfer","associateTokens","TokenAssociateTransaction","setAccountId","accountId","setTokenIds","tokenIds","id","dissociateTokens","TokenDissociateTransaction","transferTokens","tokenTransfers","transferInput","fungibleTransfer","addTokenTransfer","toolNftInput","sdkTokenId","serialValueForLong","parseInt","sdkSerial","fromValue","sdkNftId","hbarTransfers","hbarInput","sdkHbarAmount","Hbar","addHbarTransfer","wipeTokenAccount","TokenWipeTransaction","freezeTokenAccount","TokenFreezeTransaction","unfreezeTokenAccount","TokenUnfreezeTransaction","grantKycToken","TokenGrantKycTransaction","revokeKycToken","TokenRevokeKycTransaction","pauseToken","TokenPauseTransaction","unpauseToken","TokenUnpauseTransaction","updateToken","TokenUpdateTransaction","pk","autoRenewId","deleteToken","TokenDeleteTransaction","feeScheduleUpdate","TokenFeeScheduleUpdateTransaction","airdropToken","recipients","TokenAirdropTransaction","operatorAccountId","validTransfersMade","recipient","transferAmount","isZero","isNegative","negate","claimAirdrop","pendingAirdropIds","TokenClaimAirdropTransaction","pendingId","addPendingAirdropId","cancelAirdrop","TokenCancelAirdropTransaction","setPendingAirdropIds","rejectTokens","TokenRejectTransaction","setOwnerId","tokenToReject","addTokenId","DEFAULT_ACCOUNT_AUTORENEW_PERIOD_SECONDS","AccountBuilder","createAccount","AccountCreateTransaction","autoRenewPeriodSetByUser","keyDetection","setKeyWithoutAlias","initialBalance","setInitialBalance","receiverSignatureRequired","setReceiverSignatureRequired","seconds","setAccountMemo","maxAutomaticTokenAssociations","setMaxAutomaticTokenAssociations","stakedAccountId","setStakedAccountId","stakedNodeId","setStakedNodeId","declineStakingReward","setDeclineStakingReward","alias","setAlias","transferHbar","transfers","netZeroInTinybars","userTransferProcessedForScheduling","receiverTransfer","amountValue","isPositive","recipientAccountId","negated","tinybarsContribution","toTinybars","plus","updateAccount","accountIdToUpdate","AccountUpdateTransaction","setKey","saId","String","test","deleteAccount","deleteAccountId","transferAccountId","AccountDeleteTransaction","setTransferAccountId","approveHbarAllowance","AccountAllowanceApproveTransaction","ownerAccountId","spenderAccountId","approveTokenNftAllowance","owner","allSerials","approveTokenNftAllowanceAllSerials","serialLong","approveFungibleTokenAllowance","amountLong","approveTokenAllowance","deleteNftSpenderAllowance","AccountAllowanceDeleteTransaction","deleteAllTokenNftAllowances","revokeHbarAllowance","revokeFungibleTokenAllowance","deleteNftSerialAllowancesForAllSpenders","ownerAccId","parts","nftIdString","split","deleteTokenNftAllowanceForSpender","ownerAccIdToUse","sdkSerials","prepareSignScheduledTransaction","ScheduleId","ScheduleSignTransaction","setScheduleId","DEFAULT_CONTRACT_AUTORENEW_PERIOD_SECONDS","ScsBuilder","createContract","ContractCreateTransaction","bytecodeFileId","setBytecodeFileId","bytecode","setBytecode","gas","setGas","balance","fromTinybars","constructorParameters","setConstructorParameters","setContractMemo","executeContract","gasValue","ContractExecuteTransaction","setContractId","contractId","setFunction","functionName","functionParameters","payableAmount","hbarAmount","setPayableAmount","updateContract","ContractUpdateTransaction","proxyAccountId","setProxyAccountId","deleteContract","ContractDeleteTransaction","transferContractId","setTransferContractId","callContract","ContractCallQuery","maxQueryPayment","setQueryPayment","paymentTransactionId","setPaymentTransactionId","filterUndefined","obj","filtered","value","entries","QueryBuilder","getTopicInfo","topicIdString","getTopicMessages","getTopicMessagesByFilter","accountIdString","getAccountBalance","getAccountMemo","getTokenInfo","getAccountTokens","limit","getAccountNfts","validateNftOwnership","serialNumber","validateNFTOwnership","getTransaction","transactionIdOrHash","getTransactionByTimestamp","timestamp","getScheduleInfo","getScheduledTransactionStatus","getHbarPrice","date","getHBARPrice","readSmartContract","contractIdOrAddress","functionSelector","payerIdString","readSmartContractQuery","getTopicFees","checkKeyListAccess","keyBytes","userPublicKey","getOutstandingTokenAirdrops","accountIdOrArgs","finalOptions","order","receiverId","filteredOptions","hasFilters","keys","getPendingTokenAirdrops","senderId","getBlocks","getBlock","blockNumberOrHash","getContractResults","getContractResult","nonce","getContractLogs","getContractActions","getNftInfo","getNftsByToken","getNetworkStake","getNetworkSupply","getContracts","getContract","includeBytecode","response","getContractResultsByContract","getContractState","getContractLogsByContract","getNetworkInfo","getNetworkFees","getOpcodeTraces","ModelCapability","HederaMirrorNode","network","config","maxRetries","initialDelayMs","maxDelayMs","backoffFactor","apiKey","customHeaders","headers","baseUrl","customUrl","getMirrorNodeUrl","isServerEnvironment","window","configureRetry","configureMirrorNode","constructUrl","endpoint","includes","baseUrlWithKey","getBaseUrl","accountInfo","logMessage","_requestWithRetry","custom_fees","Timestamp","fromDate","Number","current_rate","cent_equivalent","hbar_equivalent","data","URLSearchParams","sequenceNumber","seqNum","match","append","queryString","messages","nextEndpoint","messageContent","messageJson","globalThis","TextDecoder","decode","Uint8Array","atob","c","charCodeAt","parse","sequence_number","consensus_timestamp","created","Date","links","next","proto","Key","evaluateKeyAccess","ed25519","compareEd25519Key","keyList","evaluateKeyList","thresholdKey","listKey","nestedKeyBytes","encode","finish","keyData","fromBytes","scheduleInfo","executed","Boolean","executed_timestamp","executedDate","deleted","transactions","axiosConfig","attempt","delay","url","Authorization","axios","isLastAttempt","statusCode","status","Promise","resolve","setTimeout","Math","min","_fetchWithRetry","fetchOptions","Headers","forEach","isArray","assign","request","fetch","ok","statusText","json","nextUrl","startTime","endTime","pagesFetched","raw_content","hcsMsg","payer_account_id","topic_id","running_hash","running_hash_version","chunk_info","payer","allTokens","i","tokens","concat","slice","allNfts","nfts","nftsWithUri","nft","tokenUri","token_id","serial_number","token_uri","find","toAddress","toSolidityAddress","fromAddress","body","block","estimate","to","gasPrice","K","method","airdrops","blockNumber","blocks","contracts","blockHash","internal","transactionIndex","results","slot","state","index","actions","topic0","topic1","topic2","topic3","transactionHash","logs","stack","memory","storage","NOT_INITIALIZED_ERROR","HederaAgentKit","pluginConfigInput","initialOperationalMode","scheduleUserTransactionsInBytesMode","modelCapability","MEDIUM","modelName","mirrorNodeConfig","disableLogging","isInitialized","getNetwork","Client","forMainnet","forTestnet","setOperator","getOperatorPrivateKey","pluginConfigInternal","loadedPlugins","aggregatedTools","initialize","contextForPlugins","appConfig","uniquePlugins","seenIds","Set","plugins","pluginInstance","add","name","pluginTools","flatMap","plugin","getTools","getAggregatedLangChainTools","hcs","hts","accounts","scs","getTransactionReceipt","transactionIdInput","getReceipt","signScheduledTransaction","transactionIdToReport","FALLBACK_MODEL_REGISTRY","capability","SMALL","contextWindow","description","LARGE","ModelCapabilityDetector","lastFetchTime","CACHE_DURATION","OPENROUTER_API_URL","registry","instance","determineCapability","model","modelId","contextLength","context_length","UNLIMITED","fetchModelsFromAPI","Accept","models","simplifiedId","getSimplifiedModelId","now","fullId","ensureModelsLoaded","registerModel","registerModels","getModelCapability","exactMatch","normalizedName","registeredName","getCapabilityFromHeuristics","getModelCapabilitySync","getModelConfig","getContextWindow","getContextWindowSync","getAllModels","isModelRegistered","getModelsByCapability","filter","refreshModels","getCacheStatus","isStale","lastFetch","modelCount","DEFAULT_MODEL","ModelPricingManager","pricingCache","initializeFallbackPricing","fallbackPricing","prompt","completion","pricing","fetchPricingFromAPI","promptPrice","parseFloat","completionPrice","isNaN","prefixes","prefix","ensurePricingLoaded","size","getPricing","getPricingSync","TokenUsageCallbackHandler","BaseCallbackHandler","tokenUsageHistory","currentTokenUsage","handleLLMEnd","output","llmOutput","tokenUsage","promptTokens","completionTokens","totalTokens","getLatestTokenUsage","getTokenUsageHistory","getTotalTokenUsage","reduce","acc","usage","reset","calculateTokenCostSync","promptCost","completionCost","totalCost","currency","AbstractSigner","accountIdToQuery","errorMessage","initializeMirrorNode","moduleName","AgentKitActionName","keyString","HederaTransactionMetaOptionsSchema","z","object","transactionMemo","string","optional","describe","array","boolean","BaseHederaTransactionTool","StructuredTool","rest","neverScheduleThisTool","requiresMultipleTransactions","schema","specificInputSchema","extend","metaOptions","_applyMetaOptions","builder","metaOpts","specificCallArgs","_substituteKeyFields","_applyTransactionOptions","keyFieldNames","keyField","pubKeyString","toStringDer","typedError","_handleAutonomous","allNotes","execOptions","_buildScheduleOptions","_handleReturnBytes","requiresAutonomous","_shouldScheduleTransaction","_handleScheduledTransaction","_handleUnscheduledTransaction","scheduleCreateResult","userInfo","op","payer_account_id_scheduled_tx","memo_scheduled_tx","bytes","transactionBytes","forceSchedule","getNoteForKey","schemaDefaultValue","actualValue","_call","runManager","llmProvidedMetaOptions","_extractSpecificArgsFromCombinedArgs","zodSchemaInfoNotes","shape","fieldSchema","_def","typeName","defaultValueOrFn","defaultValue","schemaDefinedDefaultValue","eDefaultFn","currentValue","noteMessage","getServiceBuilder","callBuilderMethod","builderAppliedDefaultNotes","builderNotesOnError","allNotesOnError","_handleError","combinedArgs","specificArgs","CreateAccountZodSchemaCore","union","number","int","positive","HederaCreateAccountTool","namespace","HbarTransferInputSchema","TransferHbarZodSchemaCore","HederaTransferHbarTool","UpdateAccountZodSchemaCore","nullable","HederaUpdateAccountTool","DeleteAccountZodSchemaCore","HederaDeleteAccountTool","ApproveHbarAllowanceZodSchemaCore","HederaApproveHbarAllowanceTool","ApproveFungibleTokenAllowanceZodSchemaCore","HederaApproveFungibleTokenAllowanceTool","ApproveTokenNftAllowanceZodSchemaCore","HederaApproveTokenNftAllowanceTool","RevokeHbarAllowanceZodSchemaCore","HederaRevokeHbarAllowanceTool","RevokeFungibleTokenAllowanceZodSchemaCore","HederaRevokeFungibleTokenAllowanceTool","DeleteNftSpenderAllowanceZodSchemaCore","HederaDeleteNftSpenderAllowanceTool","DeleteNftSerialAllowancesZodSchemaCore","HederaDeleteNftSerialAllowancesTool","MODEL_STRATEGIES","maxTokens","summarizeArrays","maxArrayLength","includeMetadata","Infinity","BaseHederaQueryTool","customStrategy","baseStrategy","responseStrategy","estimateTokens","text","ceil","matchesPattern","fieldPath","pattern","RegExp","processData","path","processors","getLargeFieldProcessors","processArray","processString","processObject","arr","processedArray","item","maxLength","takeFirst","floor","takeLast","_summary","_originalLength","_truncatedAt","matchingEntry","matchingProcessor","exclude","str","truncateMessage","formatResult","processedResult","processCustomResponse","jsonString","estimatedTokens","responseWithMeta","_meta","handleError","rawData","executeQuery","processed","processLargeFields","toolResponse","getModelCapabilityLimits","arrayLimit","detector","toolDefinitionsReserve","availableTokens","calculateArrayLimit","max","allModels","maxContextWindow","limits","processorConfig","getNestedValue","truncated","setNestedValue","userFriendlyMessage","processDataStructure","current","currentObj","arrayKey","indexStr","arrayValue","lastKey","pop","targetObj","GetOutstandingAirdropsZodSchema","enum","HederaGetOutstandingAirdropsTool","count","GetPendingAirdropsZodSchema","HederaGetPendingAirdropsTool","GetAccountBalanceZodSchema","HederaGetAccountBalanceTool","unit","GetAccountInfoZodSchema","HederaGetAccountInfoTool","GetAccountNftsZodSchema","default","HederaGetAccountNftsTool","nftCount","GetAccountPublicKeyZodSchema","HederaGetAccountPublicKeyTool","publicKeyDer","publicKeyRaw","toStringRaw","GetAccountTokensZodSchema","HederaGetAccountTokensTool","tokenCount","signAndExecuteScheduledTransactionSchema","SignAndExecuteScheduledTransactionTool","accountBuilder","trim","CustomFeeObjectSchema","CreateTopicZodSchemaCore","HederaCreateTopicTool","SubmitMessageZodSchemaCore","HederaSubmitMessageTool","DeleteTopicZodSchemaCore","HederaDeleteTopicTool","UpdateTopicZodSchemaCore","HederaUpdateTopicTool","GetTopicMessagesByFilterZodSchema","HederaGetTopicMessages","messageCount","filters","GetTopicInfoZodSchema","HederaGetTopicInfoTool","topicInfo","GetTopicFeesZodSchema","HederaGetTopicFeesTool","AirdropRecipientSchema","AirdropTokenZodSchemaCore","HederaAirdropTokenTool","AssociateTokensZodSchemaCore","HederaAssociateTokensTool","BurnFTZodSchemaCore","HederaBurnFungibleTokenTool","BurnNFTZodSchemaCore","HederaBurnNftTool","ClaimAirdropZodSchemaCore","pendingAirdrops","HederaClaimAirdropTool","claimParams","itemNumber","serialValue","tokId","PendingAirdropId","SERIALIZED_KEY_DESCRIPTION","FEE_COLLECTOR_DESCRIPTION","FixedFeeInputSchema","FractionalFeeInputSchema","RoyaltyFeeInputSchema","omit","CustomFeeInputUnionSchema","discriminatedUnion","FTCreateZodSchemaCore","freezeDefault","SDKTokenSupplyType","HederaCreateFungibleTokenTool","BigInt","toLocaleString","NFTCreateZodSchemaCore","HederaCreateNftTool","DeleteTokenZodSchemaCore","HederaDeleteTokenTool","DissociateTokensZodSchemaCore","HederaDissociateTokensTool","FreezeTokenAccountZodSchemaCore","HederaFreezeTokenAccountTool","GetTokenInfoZodSchema","HederaGetTokenInfoTool","tokenInfo","GrantKycTokenZodSchemaCore","HederaGrantKycTokenTool","MintFTZodSchemaCore","HederaMintFungibleTokenTool","MintNFTZodSchemaCore","batchSize","HederaMintNftTool","PauseTokenZodSchemaCore","HederaPauseTokenTool","RejectTokensZodSchemaCore","HederaRejectTokensTool","RevokeKycTokenZodSchemaCore","HederaRevokeKycTokenTool","literal","TokenFeeScheduleUpdateZodSchemaCore","HederaTokenFeeScheduleUpdateTool","TransferNftZodSchemaCore","HederaTransferNftTool","FungibleTokenTransferInputSchema","NftTransferInputSchema","TransferTokensZodObjectSchema","HederaTransferTokensTool","UnfreezeTokenAccountZodSchemaCore","HederaUnfreezeTokenAccountTool","UnpauseTokenZodSchemaCore","HederaUnpauseTokenTool","UpdateTokenZodSchemaCore","HederaUpdateTokenTool","ValidateNftOwnershipZodSchema","HederaValidateNftOwnershipTool","nftDetail","isOwned","WipeTokenAccountZodSchemaCore","HederaWipeTokenAccountTool","DeleteContractZodSchemaCore","HederaDeleteContractTool","GetContractZodSchema","HederaGetContractTool","runtime_bytecode","creation_bytecode","contract","summary","contract_id","evmAddress","evm_address","created_timestamp","expiration","expiration_timestamp","auto_renew_period","max_automatic_token_associations","hasAdminKey","admin_key","hasBytecode","hasRuntimeBytecode","bytecodeIncluded","GetContractsZodSchema","HederaGetContractsTool","UpdateContractZodSchemaCore","HederaUpdateContractTool","GetHbarPriceZodSchema","HederaGetHbarPriceTool","toISOString","price","priceUsd","GetNetworkInfoZodSchema","HederaGetNetworkInfoTool","networkInfo","GetNetworkFeesZodSchema","HederaGetNetworkFeesTool","networkFees","GetBlocksZodSchema","HederaGetBlocksTool","GetTransactionZodSchema","BasePlugin","context","cleanup","HederaHTSPlugin","arguments","version","author","tools","values","toolParams","queryToolParams","HederaHCSPlugin","HederaAccountPlugin","HederaSCSPlugin","HederaNetworkPlugin","verbose","initialModelCapability","openAIModelName","defaultLogLevel","logLevel","pluginConfig","OPENAI_MODEL_NAME","tokenUsageHandler","llm","openAIApiKey","OPENAI_API_KEY","ChatOpenAI","temperature","callbacks","constructSystemMessage","messageParts","agentOperatorId","userAccId","customSystemMessagePreamble","customSystemMessagePostamble","join","detectedCapability","systemMessage","toolsFromKit","ChatPromptTemplate","fromMessages","MessagesPlaceholder","agent","createOpenAIToolsAgent","agentExecutor","AgentExecutor","returnIntermediateSteps","processMessage","userInput","chatHistoryInput","langchainChatHistory","msg","HumanMessage","content","AIMessage","intermediateSteps","rawToolOutput","cost","invoke","input","chat_history","parsedSteps","observation","setOperationalMode","mode","totalUsage","resetTokenUsageTracking","getKit","registerPlugin","getPlugin","getAllPlugins","getAllTools","unregisterPlugin","unregisterAllPlugins","pluginIds","keyType","keyTypeVerified","accountIdInternal","networkInternal","DEBUG","initializeOperator","account","_type","actualKeyType","getSignatures","sign","getClient","getKeyType","getKeyTypeSync","async","pricingManager","getTime","toFixed","networkType","precision","baseBalance","decimalsBigNumber","divisor","pow","isBigNumber","dividedBy","displayBalance","customFeesJson","parsedFeesInput","feeCollectorAccountIdStr","newFee","feeType","minimumAmount","maximumAmount","assessmentMethod","netOfTransfers","allCollectorsAreExempt","setAllCollectorsAreExempt"],"mappings":"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"}