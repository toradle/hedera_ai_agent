"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("@hashgraph/sdk"),t=require("buffer"),n=require("pino"),r=require("bignumber.js"),o=require("axios"),i=require("@hashgraph/proto"),s=require("@langchain/openai"),a=require("@langchain/core/prompts"),c=require("@langchain/core/messages"),l=require("@langchain/core/callbacks/base"),d=require("langchain/agents"),u=require("zod"),h=require("@langchain/core/tools"),p=class e{constructor(e={}){const t="true"===process.env.DISABLE_LOGS,r=e.silent||t,o=r?"silent":e.level||"info";this.moduleContext=e.module||"app";const i={level:o,enabled:!r,transport:!r&&!1!==e.prettyPrint?{target:"pino-pretty",options:{colorize:!0,translateTime:"SYS:standard",ignore:"pid,hostname"}}:void 0};this.logger=n(i)}static getInstance(t={}){const n=t.module||"default";if("true"===process.env.DISABLE_LOGS&&e.instances.has(n)){"silent"!==e.instances.get(n).getLevel()&&e.instances.delete(n)}return e.instances.has(n)||e.instances.set(n,new e(t)),e.instances.get(n)}setLogLevel(e){this.logger.level=e}getLevel(){return this.logger.level}setSilent(e){e&&(this.logger.level="silent")}setModule(e){this.moduleContext=e}debug(...e){this.logger.debug({module:this.moduleContext},...e)}info(...e){this.logger.info({module:this.moduleContext},...e)}warn(...e){this.logger.warn({module:this.moduleContext},...e)}error(...e){this.logger.error({module:this.moduleContext},...e)}trace(...e){this.logger.trace({module:this.moduleContext},...e)}};p.instances=new Map;let g=p;function m(t){let n="ed25519";t.startsWith("0x")?n="ecdsa":t.startsWith("302e020100300506032b6570")?n="ed25519":t.startsWith("3030020100300706052b8104000a")?n="ecdsa":96===t.length?n="ed25519":88===t.length&&(n="ecdsa");try{return{detectedType:n,privateKey:"ecdsa"===n?e.PrivateKey.fromStringECDSA(t):e.PrivateKey.fromStringED25519(t)}}catch(r){const i="ecdsa"===n?"ed25519":"ecdsa";try{return{detectedType:i,privateKey:"ecdsa"===i?e.PrivateKey.fromStringECDSA(t):e.PrivateKey.fromStringED25519(t)}}catch(o){throw new Error(`Failed to parse private key as either ED25519 or ECDSA: ${r}`)}}}class f{constructor(e){this.hederaKit=e,this.currentTransaction=null,this.notes=[],this.kit=e;const t="true"===process.env.DISABLE_LOGS;this.logger=new g({module:"ServiceBuilder",level:t?"silent":"info",silent:t})}getEffectiveSenderAccountId(){return this.kit.userAccountId?e.AccountId.fromString(this.kit.userAccountId):this.kit.signer.getAccountId()}getTransferSourceAccount(t=!0){return t&&this.kit.userAccountId?e.AccountId.fromString(this.kit.userAccountId):this.kit.signer.getAccountId()}setTransactionMemo(e){if(!this.currentTransaction)throw new Error("No transaction is currently being built. Call a specific transaction method first (e.g., createTopic).");return this.currentTransaction.setTransactionMemo(e),this}setTransactionId(e){if(!this.currentTransaction)throw new Error("No transaction is currently being built. Call a specific transaction method first.");return this.currentTransaction.setTransactionId(e),this}setNodeAccountIds(e){if(!this.currentTransaction)throw new Error("No transaction is currently being built. Call a specific transaction method first.");return this.currentTransaction.setNodeAccountIds(e),this}async execute(t){const n=this.currentTransaction;if(!n)return{success:!1,error:"No transaction to execute."};let r=n,o=n.transactionId?.toString();if(t?.schedule){!n.isFrozen()&&this.kit.userAccountId&&n.setTransactionId(e.TransactionId.generate(this.kit.userAccountId));const o=(new e.ScheduleCreateTransaction).setScheduledTransaction(n);if(t.scheduleMemo&&o.setScheduleMemo(t.scheduleMemo),this.kit.userAccountId)o.setPayerAccountId(e.AccountId.fromString(this.kit.userAccountId));else if(t.schedulePayerAccountId){const n="string"==typeof t.schedulePayerAccountId?e.AccountId.fromString(t.schedulePayerAccountId):t.schedulePayerAccountId;o.setPayerAccountId(n)}else o.setPayerAccountId(this.kit.signer.getAccountId()),this.addNote(`Your agent account (${this.kit.signer.getAccountId().toString()}) will pay the fee to create this schedule.`);const s=await this.kit.getOperator(),a=(new e.KeyList).setThreshold(1);if(s.publicKey&&(a.push(s.publicKey),this.addNote(`The schedule admin key allows both your agent and user (${this.kit.userAccountId}) to manage the schedule.`)),this.kit.userAccountId)try{const t=this.kit.mirrorNode,n=await t.requestAccount(this.kit.userAccountId);n?.key?.key?(a.push(e.PublicKey.fromString(n.key.key)),this.addNote(`The schedule admin key allows both your agent and user (${this.kit.userAccountId}) to manage the schedule.`)):this.addNote(`The schedule admin key is set to your agent. User (${this.kit.userAccountId}) key not found or not a single key.`)}catch(i){this.logger.warn(`Failed to get user key for schedule admin key for ${this.kit.userAccountId}: ${i.message}`),this.addNote(`The schedule admin key is set to your agent. Could not retrieve user (${this.kit.userAccountId}) key.`)}Array.from(a).length>0?o.setAdminKey(a):this.addNote("No admin key could be set for the schedule (agent key missing and user key not found/retrieved)."),r=o}try{r.isFrozen()||r.transactionId||await r.freezeWith(this.kit.client),t?.schedule&&r.transactionId&&(o=r.transactionId.toString());const e=await this.kit.signer.signAndExecuteTransaction(r),n={success:!0,receipt:e,transactionId:r.transactionId?.toString()||o};return t?.schedule&&e.scheduleId&&(n.scheduleId=e.scheduleId.toString()),n}catch(i){console.log("error is:",i);const e=i;this.logger.error(`Transaction execution failed: ${e.message}`,e);return{success:!1,error:e.message||"An unknown error occurred during transaction execution.",transactionId:o}}}async getTransactionBytes(n){if(!this.currentTransaction)throw new Error("No transaction to get bytes for. Call a specific transaction method first.");let r=this.currentTransaction;if(n?.schedule){const t=(new e.ScheduleCreateTransaction).setScheduledTransaction(this.currentTransaction);if(n.scheduleMemo&&t.setScheduleMemo(n.scheduleMemo),n.schedulePayerAccountId){const r="string"==typeof n.schedulePayerAccountId?e.AccountId.fromString(n.schedulePayerAccountId):n.schedulePayerAccountId;t.setPayerAccountId(r)}n.scheduleAdminKey&&t.setAdminKey(n.scheduleAdminKey),r=t}return t.Buffer.from(r.toBytes()).toString("base64")}async executeWithSigner(e){if(!this.currentTransaction)return{success:!1,error:"No transaction to execute. Call a specific transaction method first."};let t=this.currentTransaction;if(t.isFrozen())throw new Error("Transaction is frozen, try to call the builder method again and then executeWithSigner.");try{const n=await e.signAndExecuteTransaction(t),r=t.transactionId?.toString();return{success:!0,receipt:n,transactionId:r}}catch(n){const e=n;return this.logger.error(`Transaction execution with new signer failed: ${e.message}`),{success:!1,error:e.message||"An unknown error occurred during transaction execution with new signer."}}}setCurrentTransaction(e){this.currentTransaction=e}getCurrentTransaction(){return this.currentTransaction}addNote(e){this.notes.push(e)}getNotes(){return this.notes}clearNotes(){this.notes=[]}async parseKey(t){if(null!=t){if("object"==typeof t&&("_key"in t||t instanceof e.PublicKey||t instanceof e.PrivateKey||t instanceof e.KeyList))return t;if("string"==typeof t){if("current_signer"===t.toLowerCase()){if(this.kit.signer)return this.logger.info('[BaseServiceBuilder.parseKey] Substituting "current_signer" with signer\'s public key.'),await this.kit.signer.getPublicKey();throw new Error('[BaseServiceBuilder.parseKey] Signer is not available to resolve "current_signer".')}try{return e.PublicKey.fromString(t)}catch(n){const e=n;try{this.logger.warn("[BaseServiceBuilder.parseKey] Attempting to parse key string as PrivateKey to derive PublicKey. This is generally not recommended for public-facing keys.",{error:e.message});return m(t).privateKey}catch(r){const e=r;throw this.logger.error(`[BaseServiceBuilder.parseKey] Failed to parse key string as PublicKey or PrivateKey: ${t.substring(0,30)}...`,{error:e.message}),new Error(`[BaseServiceBuilder.parseKey] Invalid key string format: ${t.substring(0,30)}...`)}}}this.logger.warn(`[BaseServiceBuilder.parseKey] Received an object that is not an SDK Key instance or a recognized string format: ${JSON.stringify(t)}`)}}parseAmount(t){return void 0===t?e.Long.fromNumber(0):"number"==typeof t?e.Long.fromNumber(t):"string"==typeof t?e.Long.fromString(t):t instanceof BigNumber?e.Long.fromString(t.toString()):t}}const y=7776e3;class b extends f{constructor(e){super(e)}async createTopic(t){this.clearNotes();const n=new e.TopicCreateTransaction;if(t.memo&&n.setTopicMemo(t.memo),t.adminKey){const e=await this.parseKey(t.adminKey);e&&n.setAdminKey(e)}if(t.feeScheduleKey){const e=await this.parseKey(t.feeScheduleKey);e&&n.setFeeScheduleKey(e)}if(t.submitKey){const e=await this.parseKey(t.submitKey);e&&n.setSubmitKey(e)}if(t.autoRenewPeriod?n.setAutoRenewPeriod(t.autoRenewPeriod):(n.setAutoRenewPeriod(y),this.addNote("Default auto-renew period of 7776000 seconds applied for topic.")),t.autoRenewAccountId?n.setAutoRenewAccountId(t.autoRenewAccountId):(this.logger.warn("MirrorNode client is not available on the signer, cannot set fee exempt keys by account ID for createTopic."),this.addNote("Could not set fee exempt accounts for topic creation: MirrorNode client not available on signer.")),t.customFees&&t.customFees.length>0&&n.setCustomFees(t.customFees),t.exemptAccountIds&&t.exemptAccountIds.length>0)if(this.kit.signer.mirrorNode)try{const e=[];for(const n of t.exemptAccountIds){const t=await this.kit.signer.mirrorNode.getPublicKey(n);e.push(t)}e.length>0&&this.logger.warn("TopicCreateTransaction does not support setFeeExemptKeys. This parameter will be ignored for topic creation.")}catch(r){const e=r;this.logger.error(`Failed to process exemptAccountIds for createTopic: ${e.message}`),this.addNote(`Error processing fee exempt accounts for topic creation: ${e.message}. They may not be set.`)}else this.logger.warn("MirrorNode client is not available on the signer, cannot set fee exempt keys by account ID for createTopic."),this.addNote("Could not attempt to set fee exempt accounts for topic creation: MirrorNode client not available on signer.");return this.setCurrentTransaction(n),this}submitMessageToTopic(n){const r="string"==typeof n.topicId?e.TopicId.fromString(n.topicId):n.topicId,o=n.message,i="string"==typeof o?t.Buffer.from(o,"utf8").length:o.length;i>1e3&&this.logger.warn(`HcsBuilder: Message size (${i} bytes) exceeds recommended single transaction limit (1000 bytes). The transaction will likely fail if not accepted by the network.`);let s=(new e.TopicMessageSubmitTransaction).setTopicId(r).setMessage(o);return n.maxChunks&&s.setMaxChunks(n.maxChunks),n.chunkSize&&s.setChunkSize(n.chunkSize),this.setCurrentTransaction(s),this}deleteTopic(t){if(void 0===t.topicId)throw new Error("Topic ID is required to delete a topic.");const n=(new e.TopicDeleteTransaction).setTopicId(t.topicId);return this.setCurrentTransaction(n),this}async updateTopic(t){if(this.clearNotes(),!t.topicId)throw new Error("Topic ID is required to update a topic.");const n=(new e.TopicUpdateTransaction).setTopicId(t.topicId);if(Object.prototype.hasOwnProperty.call(t,"memo")&&n.setTopicMemo(null===t.memo?"":t.memo),Object.prototype.hasOwnProperty.call(t,"adminKey"))if(null===t.adminKey)n.setAdminKey(new e.KeyList);else if(t.adminKey){const e=await this.parseKey(t.adminKey);e&&n.setAdminKey(e)}if(Object.prototype.hasOwnProperty.call(t,"submitKey"))if(null===t.submitKey)n.setSubmitKey(new e.KeyList);else if(t.submitKey){const e=await this.parseKey(t.submitKey);e&&n.setSubmitKey(e)}if(t.autoRenewPeriod&&n.setAutoRenewPeriod(t.autoRenewPeriod),Object.prototype.hasOwnProperty.call(t,"autoRenewAccountId")&&(null===t.autoRenewAccountId?n.setAutoRenewAccountId(e.AccountId.fromString("0.0.0")):t.autoRenewAccountId&&n.setAutoRenewAccountId(t.autoRenewAccountId)),Object.prototype.hasOwnProperty.call(t,"exemptAccountIds"))if(t.exemptAccountIds&&t.exemptAccountIds.length>0&&!this.kit.signer.mirrorNode)this.logger.warn("MirrorNode client is not available on the signer, cannot set fee exempt keys by account ID for updateTopic if account IDs are provided and not empty."),this.addNote("Could not set fee exempt accounts for topic update: MirrorNode client not available on signer.");else if(t.exemptAccountIds)if(0===t.exemptAccountIds.length)n.setFeeExemptKeys([]);else try{const e=[];for(const n of t.exemptAccountIds){const t=await this.kit.signer.mirrorNode.getPublicKey(n);e.push(t)}e.length>0?n.setFeeExemptKeys(e):this.addNote("Fee exempt accounts were provided, but no valid public keys could be resolved for them.")}catch(r){const e=r;this.logger.error(`Failed to process exemptAccountIds for updateTopic: ${e.message}`),this.addNote(`Error processing fee exempt accounts for topic update: ${e.message}. They may not be set.`)}return this.setCurrentTransaction(n),this}}const I=7776e3;function k(e){if(!e)return"TOKEN";const t=e.replace(/[^a-zA-Z0-9]/g,"").substring(0,5).toUpperCase();return t||"TOKEN"}function T(t,n,r,o,i,s){return t&&0!==t.length?t.map(t=>{let a,c=t.feeCollectorAccountId;if(!c&&o&&"returnBytes"===i&&(c=o,s)){let e="custom";"FIXED"===t.type||"FIXED_FEE"===t.type?e="fixed":"FRACTIONAL"===t.type||"FRACTIONAL_FEE"===t.type?e="fractional":"ROYALTY"!==t.type&&"ROYALTY_FEE"!==t.type||(e="royalty"),s(`Fee collector for a ${e} fee was defaulted to your account (${o}).`)}if(!c)throw new Error(`Fee collector account ID is required for custom fee type ${t.type} but was not provided or defaulted.`);try{a=e.AccountId.fromString(c)}catch(l){throw r.error(`Invalid feeCollectorAccountId: ${c}`,l),new Error(`Invalid feeCollectorAccountId: ${c}`)}switch(t.type){case"FIXED":case"FIXED_FEE":{const o=(new e.CustomFixedFee).setFeeCollectorAccountId(a).setAmount(n(t.amount));if(t.denominatingTokenId)try{o.setDenominatingTokenId(e.TokenId.fromString(t.denominatingTokenId))}catch(l){throw r.error(`Invalid denominatingTokenId for fixed fee: ${t.denominatingTokenId}`,l),new Error(`Invalid denominatingTokenId for fixed fee: ${t.denominatingTokenId}`)}return o}case"FRACTIONAL":case"FRACTIONAL_FEE":{const r=(new e.CustomFractionalFee).setFeeCollectorAccountId(a).setNumerator(n(t.numerator).toNumber()).setDenominator(n(t.denominator).toNumber());void 0!==t.minAmount&&r.setMin(n(t.minAmount)),void 0!==t.maxAmount&&r.setMax(n(t.maxAmount));const o=t;return void 0!==o.assessmentMethodInclusive&&(o.assessmentMethodInclusive?r.setAssessmentMethod(e.FeeAssessmentMethod.Inclusive):r.setAssessmentMethod(e.FeeAssessmentMethod.Exclusive)),r}case"ROYALTY":case"ROYALTY_FEE":{const c=(new e.CustomRoyaltyFee).setFeeCollectorAccountId(a).setNumerator(n(t.numerator).toNumber()).setDenominator(n(t.denominator).toNumber()),d=t;if(d.fallbackFee){let t,a=d.fallbackFee.feeCollectorAccountId;if(!a&&o&&"returnBytes"===i&&(a=o,s&&s(`Fallback fee collector for a royalty fee was also defaulted to your account (${o}).`)),!a)throw new Error("Fallback fee collector account ID is required for royalty fee but was not provided or defaulted.");try{t=e.AccountId.fromString(a)}catch(l){throw r.error(`Invalid feeCollectorAccountId in fallbackFee: ${a}`,l),new Error(`Invalid feeCollectorAccountId in fallbackFee: ${a}`)}const u=(new e.CustomFixedFee).setFeeCollectorAccountId(t).setAmount(n(d.fallbackFee.amount));if(d.fallbackFee.denominatingTokenId)try{u.setDenominatingTokenId(e.TokenId.fromString(d.fallbackFee.denominatingTokenId))}catch(l){throw r.error(`Invalid denominatingTokenId in fallbackFee: ${d.fallbackFee.denominatingTokenId}`,l),new Error(`Invalid denominatingTokenId in fallbackFee: ${d.fallbackFee.denominatingTokenId}`)}c.setFallbackFee(u)}return c}default:{const e=t;throw r.warn(`Unsupported custom fee type encountered: ${e.type}`),new Error(`Unsupported custom fee type: ${e.type}`)}}}):[]}class w extends f{constructor(e){super(e)}async createFungibleToken(t){this.clearNotes();let n=t.treasuryAccountId;if(!n&&this.kit.userAccountId&&"returnBytes"===this.kit.operationalMode&&(this.logger.info(`[HtsBuilder.createFungibleToken] Using userAccountId ${this.kit.userAccountId} as treasury for FT creation in returnBytes mode.`),n=e.AccountId.fromString(this.kit.userAccountId),this.addNote(`Since no treasury was specified, your account (${this.kit.userAccountId}) has been set as the token's treasury.`)),!n)throw new Error("[HtsBuilder.createFungibleToken] Treasury Account ID is required (e.g., explicitly, via userAccountId for returnBytes mode, or via agent operator for autonomous if applicable).");let r,o=t.tokenSymbol;if(o||(o=k(t.tokenName),this.addNote(`We've generated a token symbol '${o}' for you, based on the token name '${t.tokenName}'.`)),"string"==typeof t.supplyType){const n=t.supplyType;n.toUpperCase()===e.TokenSupplyType.Finite.toString().toUpperCase()?r=e.TokenSupplyType.Finite:(n.toUpperCase()===e.TokenSupplyType.Infinite.toString().toUpperCase()||(this.logger.warn(`Invalid string for supplyType: ${n}. Defaulting to INFINITE.`),this.addNote(`Invalid supplyType string '${n}' received, defaulted to INFINITE.`)),r=e.TokenSupplyType.Infinite)}else r=t.supplyType;const i=(new e.TokenCreateTransaction).setTokenName(t.tokenName).setTokenSymbol(o).setTreasuryAccountId(n).setTokenType(e.TokenType.FungibleCommon).setSupplyType(r).setInitialSupply(this.parseAmount(t.initialSupply)).setDecimals(t.decimals);if(r===e.TokenSupplyType.Finite&&t.maxSupply&&i.setMaxSupply(this.parseAmount(t.maxSupply)),t.adminKey){const e=await this.parseKey(t.adminKey);e&&i.setAdminKey(e)}if(t.kycKey){const e=await this.parseKey(t.kycKey);e&&i.setKycKey(e)}if(t.freezeKey){const e=await this.parseKey(t.freezeKey);e&&i.setFreezeKey(e)}if(t.wipeKey){const e=await this.parseKey(t.wipeKey);e&&i.setWipeKey(e)}if(t.supplyKey){const e=await this.parseKey(t.supplyKey);e&&i.setSupplyKey(e)}if(t.feeScheduleKey){const e=await this.parseKey(t.feeScheduleKey);e&&i.setFeeScheduleKey(e)}if(t.pauseKey){const e=await this.parseKey(t.pauseKey);e&&i.setPauseKey(e)}if(t.memo&&i.setTokenMemo(t.memo),t.customFees&&t.customFees.length>0){const e=T(t.customFees,this.parseAmount.bind(this),this.logger,this.kit.userAccountId,this.kit.operationalMode,this.addNote.bind(this));i.setCustomFees(e)}return t.autoRenewAccountId&&i.setAutoRenewAccountId(t.autoRenewAccountId),t.autoRenewPeriod?i.setAutoRenewPeriod(t.autoRenewPeriod):t.autoRenewAccountId&&(i.setAutoRenewPeriod(I),this.addNote("A standard auto-renew period of 90 days has been set for this token.")),this.setCurrentTransaction(i),this}async createNonFungibleToken(t){this.clearNotes();let n=t.treasuryAccountId;if(!n&&this.kit.userAccountId&&"returnBytes"===this.kit.operationalMode&&(this.logger.info(`[HtsBuilder.createNonFungibleToken] Using userAccountId ${this.kit.userAccountId} as treasury for NFT creation in returnBytes mode.`),n=e.AccountId.fromString(this.kit.userAccountId),this.addNote(`Since no treasury was specified, your account (${this.kit.userAccountId}) has been set as the NFT collection's treasury.`)),!n)throw new Error("[HtsBuilder.createNonFungibleToken] Treasury Account ID is required (e.g., explicitly, via userAccountId for returnBytes mode, or via agent operator for autonomous if applicable).");let r,o=t.tokenSymbol;if(o||(o=k(t.tokenName),this.addNote(`We've generated an NFT collection symbol '${o}' for you, based on the collection name '${t.tokenName}'.`)),"string"==typeof t.supplyType){const n=t.supplyType;n.toUpperCase()===e.TokenSupplyType.Finite.toString().toUpperCase()?r=e.TokenSupplyType.Finite:n.toUpperCase()===e.TokenSupplyType.Infinite.toString().toUpperCase()?r=e.TokenSupplyType.Infinite:(this.logger.warn(`Invalid string for NFT supplyType: ${n}. Defaulting to FINITE as per NFT common practice.`),this.addNote(`Invalid supplyType string '${n}' received for NFT, defaulted to FINITE.`),r=e.TokenSupplyType.Finite)}else r=t.supplyType;const i=(new e.TokenCreateTransaction).setTokenName(t.tokenName).setTokenSymbol(o).setTreasuryAccountId(n).setTokenType(e.TokenType.NonFungibleUnique).setSupplyType(r).setInitialSupply(0).setDecimals(0);if(r===e.TokenSupplyType.Finite&&t.maxSupply?i.setMaxSupply(this.parseAmount(t.maxSupply)):r!==e.TokenSupplyType.Finite||t.maxSupply||(this.logger.warn("NFT supplyType is FINITE but no maxSupply was provided. This might lead to an unmintable token or undesired SDK default. Consider prompting user for maxSupply or setting a builder default."),this.addNote("For this FINITE NFT collection, a specific maximum supply was not provided. The Hedera network might apply its own default or limit minting.")),t.adminKey){const e=await this.parseKey(t.adminKey);e&&i.setAdminKey(e)}if(t.kycKey){const e=await this.parseKey(t.kycKey);e&&i.setKycKey(e)}if(t.freezeKey){const e=await this.parseKey(t.freezeKey);e&&i.setFreezeKey(e)}if(t.wipeKey){const e=await this.parseKey(t.wipeKey);e&&i.setWipeKey(e)}if(t.supplyKey){const e=await this.parseKey(t.supplyKey);e&&i.setSupplyKey(e)}else{const t=await this.kit.query().getAccountInfo(n),r=t?.key?.key;r&&i.setSupplyKey(e.PublicKey.fromString(r))}if(t.feeScheduleKey){const e=await this.parseKey(t.feeScheduleKey);e&&i.setFeeScheduleKey(e)}if(t.pauseKey){const e=await this.parseKey(t.pauseKey);e&&i.setPauseKey(e)}if(t.memo&&i.setTokenMemo(t.memo),t.customFees&&t.customFees.length>0){const e=T(t.customFees,this.parseAmount.bind(this),this.logger,this.kit.userAccountId,this.kit.operationalMode,this.addNote.bind(this));i.setCustomFees(e)}return t.autoRenewAccountId&&i.setAutoRenewAccountId(t.autoRenewAccountId),t.autoRenewPeriod?i.setAutoRenewPeriod(t.autoRenewPeriod):t.autoRenewAccountId&&(i.setAutoRenewPeriod(I),this.addNote("A standard auto-renew period of 90 days has been set for this NFT collection.")),this.setCurrentTransaction(i),this}mintFungibleToken(t){const n=(new e.TokenMintTransaction).setTokenId(t.tokenId).setAmount(this.parseAmount(t.amount));return this.setCurrentTransaction(n),this}burnFungibleToken(t){const n=(new e.TokenBurnTransaction).setTokenId(t.tokenId).setAmount(this.parseAmount(t.amount));return this.setCurrentTransaction(n),this}mintNonFungibleToken(n){const r=n.metadata.map(e=>t.Buffer.from(e,"utf8")),o=(new e.TokenMintTransaction).setTokenId(n.tokenId).setMetadata(r);return this.setCurrentTransaction(o),this}burnNonFungibleToken(t){if(!t.serials||0===t.serials.length)throw new Error("Serial numbers are required to burn NFTs.");const n=t.serials.map(e=>this.parseAmount(e)),r=(new e.TokenBurnTransaction).setTokenId(t.tokenId).setSerials(n);return this.setCurrentTransaction(r),this}transferNft(t){const n="string"==typeof t.serial?e.Long.fromString(t.serial):t.serial,r=new e.NftId(e.TokenId.fromString(t.tokenId),n);let o=new e.TransferTransaction;return o=t.isApproved?o.addApprovedNftTransfer(r,t.senderAccountId,t.receiverAccountId):o.addNftTransfer(r,t.senderAccountId,t.receiverAccountId),t.memo&&o.setTransactionMemo(t.memo),this.setCurrentTransaction(o),this}associateTokens(t){const n=(new e.TokenAssociateTransaction).setAccountId(t.accountId).setTokenIds(t.tokenIds.map(t=>"string"==typeof t?e.TokenId.fromString(t):t));return this.setCurrentTransaction(n),this}dissociateTokens(t){const n=(new e.TokenDissociateTransaction).setAccountId(t.accountId).setTokenIds(t.tokenIds.map(t=>"string"==typeof t?e.TokenId.fromString(t):t));return this.setCurrentTransaction(n),this}transferTokens(t){const n=new e.TransferTransaction;if(t.tokenTransfers&&t.tokenTransfers.length>0)for(const r of t.tokenTransfers)if("fungible"===r.type){const t=r;n.addTokenTransfer("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId,"string"==typeof t.accountId?e.AccountId.fromString(t.accountId):t.accountId,this.parseAmount(t.amount))}else if("nft"===r.type){const t=r,o=e.TokenId.fromString(t.tokenId);let i;i="string"==typeof t.serial?parseInt(t.serial,10):t.serial;const s=e.Long.fromValue(i),a=new e.NftId(o,s),c=e.AccountId.fromString(t.senderAccountId),l=e.AccountId.fromString(t.receiverAccountId);t.isApproved?n.addApprovedNftTransfer(a,c,l):n.addNftTransfer(a,c,l)}if(t.hbarTransfers&&t.hbarTransfers.length>0)for(const r of t.hbarTransfers){const t=e.Hbar.fromString(r.amount.toString());n.addHbarTransfer("string"==typeof r.accountId?e.AccountId.fromString(r.accountId):r.accountId,t)}return t.memo&&n.setTransactionMemo(t.memo),this.setCurrentTransaction(n),this}wipeTokenAccount(t){const n=(new e.TokenWipeTransaction).setAccountId(t.accountId).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return t.amount&&n.setAmount(this.parseAmount(t.amount)),t.serials&&t.serials.length>0&&n.setSerials(t.serials.map(e=>this.parseAmount(e))),this.setCurrentTransaction(n),this}freezeTokenAccount(t){const n=(new e.TokenFreezeTransaction).setAccountId(t.accountId).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}unfreezeTokenAccount(t){const n=(new e.TokenUnfreezeTransaction).setAccountId(t.accountId).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}grantKycToken(t){const n=(new e.TokenGrantKycTransaction).setAccountId(t.accountId).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}revokeKycToken(t){const n=(new e.TokenRevokeKycTransaction).setAccountId(t.accountId).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}pauseToken(t){const n=(new e.TokenPauseTransaction).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}unpauseToken(t){const n=(new e.TokenUnpauseTransaction).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}async updateToken(t){if(!t.tokenId)throw new Error("Token ID is required to update a token.");this.logger.info(`[HtsBuilder.updateToken] Starting update for token ID: ${t.tokenId.toString()}`);const n=(new e.TokenUpdateTransaction).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);if(Object.prototype.hasOwnProperty.call(t,"tokenName")&&n.setTokenName(null===t.tokenName?"":t.tokenName),Object.prototype.hasOwnProperty.call(t,"tokenSymbol")&&n.setTokenSymbol(null===t.tokenSymbol?"":t.tokenSymbol),t.treasuryAccountId&&n.setTreasuryAccountId(t.treasuryAccountId),Object.prototype.hasOwnProperty.call(t,"adminKey"))if(null===t.adminKey)n.setAdminKey(new e.KeyList);else if(t.adminKey){const e=await this.parseKey(t.adminKey);e&&n.setAdminKey(e)}if(Object.prototype.hasOwnProperty.call(t,"kycKey"))if(null===t.kycKey)n.setKycKey(new e.KeyList);else if(t.kycKey){const e=await this.parseKey(t.kycKey);e&&n.setKycKey(e)}if(Object.prototype.hasOwnProperty.call(t,"freezeKey"))if(null===t.freezeKey)n.setFreezeKey(new e.KeyList);else if(t.freezeKey){const e=await this.parseKey(t.freezeKey);e&&n.setFreezeKey(e)}if(Object.prototype.hasOwnProperty.call(t,"wipeKey"))if(null===t.wipeKey)n.setWipeKey(new e.KeyList);else if(t.wipeKey){const e=await this.parseKey(t.wipeKey);e&&n.setWipeKey(e)}if(Object.prototype.hasOwnProperty.call(t,"supplyKey"))if(null===t.supplyKey)n.setSupplyKey(new e.KeyList);else if(t.supplyKey){const e=await this.parseKey(t.supplyKey);e&&n.setSupplyKey(e)}if(Object.prototype.hasOwnProperty.call(t,"feeScheduleKey"))if(null===t.feeScheduleKey)n.setFeeScheduleKey(new e.KeyList);else if(t.feeScheduleKey){const e=await this.parseKey(t.feeScheduleKey);e&&n.setFeeScheduleKey(e)}if(Object.prototype.hasOwnProperty.call(t,"pauseKey"))if(null===t.pauseKey)n.setPauseKey(new e.KeyList);else if(t.pauseKey){const e=await this.parseKey(t.pauseKey);e&&n.setPauseKey(e)}if(Object.prototype.hasOwnProperty.call(t,"memo")&&n.setTokenMemo(null===t.memo?"":t.memo),Object.prototype.hasOwnProperty.call(t,"autoRenewAccountId")){const r=t.autoRenewAccountId;null===r?n.setAutoRenewAccountId(e.AccountId.fromString("0.0.0")):r&&n.setAutoRenewAccountId(r)}return t.autoRenewPeriod&&n.setAutoRenewPeriod(t.autoRenewPeriod),this.logger.info("[HtsBuilder.updateToken] Transaction object populated. Setting current transaction.",n),this.setCurrentTransaction(n),this.logger.info("[HtsBuilder.updateToken] Current transaction set. Value:",this.currentTransaction),this}deleteToken(t){if(!t.tokenId)throw new Error("Token ID is required to delete a token.");const n=(new e.TokenDeleteTransaction).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId);return this.setCurrentTransaction(n),this}async feeScheduleUpdate(t){if(this.clearNotes(),!t.tokenId)throw new Error("Token ID is required to update fee schedule.");const n=T(t.customFees,this.parseAmount.bind(this),this.logger,this.kit.userAccountId,this.kit.operationalMode,this.addNote.bind(this)),r=(new e.TokenFeeScheduleUpdateTransaction).setTokenId("string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId).setCustomFees(n);return this.setCurrentTransaction(r),this}airdropToken(t){if(!t.recipients||0===t.recipients.length)throw new Error("Recipients are required for an airdrop.");const n=new e.TokenAirdropTransaction,r=this.kit.signer.getAccountId(),o="string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId;let i=!1;for(const e of t.recipients){const t=this.parseAmount(e.amount);t.isZero()||t.isNegative()?this.logger.warn(`Skipping airdrop to ${e.accountId.toString()} with zero or negative amount.`):(n.addTokenTransfer(o,r,t.negate()),n.addTokenTransfer(o,e.accountId,t),i=!0)}if(!i)throw new Error("No valid transfers generated for the airdrop. Check recipient amounts.");return t.memo&&n.setTransactionMemo(t.memo),this.setCurrentTransaction(n),this}claimAirdrop(t){if(!t.pendingAirdropIds||0===t.pendingAirdropIds.length)throw new Error("pendingAirdropIds must be provided and non-empty for claimAirdrop.");const n=new e.TokenClaimAirdropTransaction;for(const e of t.pendingAirdropIds)n.addPendingAirdropId(e);return t.memo&&n.setTransactionMemo(t.memo),this.setCurrentTransaction(n),this}cancelAirdrop(t){if(!t.pendingAirdropIds||0===t.pendingAirdropIds.length)throw new Error("pendingAirdropIds must be provided and non-empty for cancelAirdrop.");const n=new e.TokenCancelAirdropTransaction;return n.setPendingAirdropIds(t.pendingAirdropIds),t.memo&&n.setTransactionMemo(t.memo),this.setCurrentTransaction(n),this}rejectTokens(t){const n=(new e.TokenRejectTransaction).setOwnerId(this.kit.signer.getAccountId()),r="string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId;return n.addTokenId(r),t.memo&&n.setTransactionMemo(t.memo),this.setCurrentTransaction(n),this}}const A=7776e3;class S extends f{constructor(e){super(e)}createAccount(t){this.clearNotes();const n=new e.AccountCreateTransaction;let r=!1;if(void 0!==t.key)if(null===t.key)this.logger.warn("Received null for key in createAccount. A key or alias is typically required.");else if("string"==typeof t.key){const e=m(t.key);n.setKeyWithoutAlias(e.privateKey)}else n.setKeyWithoutAlias(t.key);return void 0!==t.initialBalance&&(null===t.initialBalance?this.logger.warn("Received null for initialBalance in createAccount."):"string"==typeof t.initialBalance?n.setInitialBalance(e.Hbar.fromString(t.initialBalance)):"number"==typeof t.initialBalance?n.setInitialBalance(new e.Hbar(t.initialBalance)):n.setInitialBalance(t.initialBalance)),void 0!==t.receiverSignatureRequired&&(null===t.receiverSignatureRequired?this.logger.warn("Received null for receiverSignatureRequired in createAccount."):n.setReceiverSignatureRequired(t.receiverSignatureRequired)),void 0!==t.autoRenewPeriod?null===t.autoRenewPeriod?this.logger.warn("Received null for autoRenewPeriod in createAccount."):"number"==typeof t.autoRenewPeriod||t.autoRenewPeriod instanceof e.Long?(n.setAutoRenewPeriod(t.autoRenewPeriod),r=!0):"object"==typeof t.autoRenewPeriod&&"number"==typeof t.autoRenewPeriod.seconds?(n.setAutoRenewPeriod(t.autoRenewPeriod.seconds),r=!0):(this.logger.warn("Invalid autoRenewPeriod in createAccount, using default."),n.setAutoRenewPeriod(A)):n.setAutoRenewPeriod(A),r||this.addNote("Default auto-renew period of 7776000 seconds applied."),void 0!==t.memo&&(null===t.memo?this.logger.warn("Received null for memo in createAccount."):n.setAccountMemo(t.memo)),void 0!==t.maxAutomaticTokenAssociations&&(null===t.maxAutomaticTokenAssociations?this.logger.warn("Received null for maxAutomaticTokenAssociations in createAccount."):n.setMaxAutomaticTokenAssociations(t.maxAutomaticTokenAssociations)),void 0!==t.stakedAccountId&&(null===t.stakedAccountId?this.logger.warn("Received null for stakedAccountId in createAccount."):n.setStakedAccountId(t.stakedAccountId)),void 0!==t.stakedNodeId&&(null===t.stakedNodeId?this.logger.warn("Received null for stakedNodeId in createAccount."):n.setStakedNodeId(t.stakedNodeId)),void 0!==t.declineStakingReward&&(null===t.declineStakingReward?this.logger.warn("Received null for declineStakingReward in createAccount."):n.setDeclineStakingReward(t.declineStakingReward)),void 0!==t.alias&&(null===t.alias?this.logger.warn("Received null for alias in createAccount."):n.setAlias(t.alias)),t.key||t.alias||this.logger.warn("AccountCreateTransaction: Neither key nor a usable alias (PublicKey/EvmAddress) was provided. Transaction might fail."),this.setCurrentTransaction(n),this}transferHbar(t,n=!0){this.clearNotes();const o=new e.TransferTransaction;if(!t.transfers||0===t.transfers.length)throw new Error("HbarTransferParams must include at least one transfer.");let i=new r(0),s=!1;if(n&&this.kit.userAccountId&&"returnBytes"===this.kit.operationalMode&&1===t.transfers.length){const n=t.transfers[0],i="string"==typeof n.amount||"number"==typeof n.amount?n.amount:n.amount.toString();if(new r(i).isPositive()){const t="string"==typeof n.accountId?e.AccountId.fromString(n.accountId):n.accountId,r=e.Hbar.fromString(i.toString());this.logger.info(`[AccountBuilder.transferHbar] Configuring user-initiated scheduled transfer: ${r.toString()} from ${this.kit.userAccountId} to ${t.toString()}`),this.addNote(`Configured HBAR transfer from your account (${this.kit.userAccountId}) to ${t.toString()} for ${r.toString()}.`),o.addHbarTransfer(t,r),o.addHbarTransfer(e.AccountId.fromString(this.kit.userAccountId),r.negated()),s=!0}}if(!s){for(const n of t.transfers){const t="string"==typeof n.accountId?e.AccountId.fromString(n.accountId):n.accountId,r="string"==typeof n.amount||"number"==typeof n.amount?n.amount:n.amount.toString(),s=e.Hbar.fromString(r.toString());o.addHbarTransfer(t,s);const a=s.toTinybars();i=i.plus(a.toString())}if(!i.isZero())throw new Error("The sum of all HBAR transfers must be zero.")}return void 0!==t.memo&&(null===t.memo?this.logger.warn("Received null for memo in transferHbar."):o.setTransactionMemo(t.memo)),this.setCurrentTransaction(o),this}updateAccount(t){if(!t.accountIdToUpdate)throw new Error("accountIdToUpdate is required for updating an account.");const n=(new e.AccountUpdateTransaction).setAccountId(t.accountIdToUpdate);if(void 0!==t.key)if(null===t.key)this.logger.warn("Received null for key, skipping update for key.");else if("string"==typeof t.key)try{const e=m(t.key);n.setKey(e.privateKey)}catch(r){throw this.logger.error(`Failed to parse key string: ${t.key}`,r),new Error(`Invalid key string provided: ${t.key}`)}else n.setKey(t.key);if(void 0!==t.autoRenewPeriod&&(null===t.autoRenewPeriod?this.logger.warn("Received null for autoRenewPeriod, skipping update."):"number"==typeof t.autoRenewPeriod?n.setAutoRenewPeriod(t.autoRenewPeriod):this.logger.warn(`Invalid autoRenewPeriod format: ${JSON.stringify(t.autoRenewPeriod)}. Skipping.`)),void 0!==t.receiverSignatureRequired&&(null===t.receiverSignatureRequired?this.logger.warn("Received null for receiverSignatureRequired, skipping update."):n.setReceiverSignatureRequired(t.receiverSignatureRequired)),void 0!==t.stakedAccountId)if(null===t.stakedAccountId)this.logger.warn("Received null for stakedAccountId, skipping update.");else{const e=String(t.stakedAccountId);"0.0.0"===e||/^\d+\.\d+\.\d+$/.test(e)?n.setStakedAccountId(e):this.logger.warn(`Invalid stakedAccountId format: ${e}. Skipping.`)}return void 0!==t.stakedNodeId&&(null===t.stakedNodeId?this.logger.warn("Received null for stakedNodeId, skipping update."):n.setStakedNodeId(t.stakedNodeId)),void 0!==t.declineStakingReward&&(null===t.declineStakingReward?this.logger.warn("Received null for declineStakingReward, skipping update."):n.setDeclineStakingReward(t.declineStakingReward)),void 0!==t.memo&&(null===t.memo?this.logger.warn("Received null for memo, skipping update."):n.setAccountMemo(t.memo)),void 0!==t.maxAutomaticTokenAssociations&&(null===t.maxAutomaticTokenAssociations?this.logger.warn("Received null for maxAutomaticTokenAssociations, skipping update."):"number"==typeof t.maxAutomaticTokenAssociations?n.setMaxAutomaticTokenAssociations(t.maxAutomaticTokenAssociations):this.logger.warn(`Invalid type for maxAutomaticTokenAssociations: ${typeof t.maxAutomaticTokenAssociations}. Skipping.`)),this.setCurrentTransaction(n),this}deleteAccount(t){if(!t.deleteAccountId)throw new Error("deleteAccountId is required for deleting an account.");if(!t.transferAccountId)throw new Error("transferAccountId is required for deleting an account.");const n=(new e.AccountDeleteTransaction).setAccountId(t.deleteAccountId).setTransferAccountId(t.transferAccountId);return this.setCurrentTransaction(n),this}approveHbarAllowance(t){const n=(new e.AccountAllowanceApproveTransaction).approveHbarAllowance(t.ownerAccountId||this.kit.signer.getAccountId(),t.spenderAccountId,t.amount);return this.setCurrentTransaction(n),this}approveTokenNftAllowance(t){const n=new e.AccountAllowanceApproveTransaction,o=t.ownerAccountId||this.kit.signer.getAccountId(),i="string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId;if(t.allSerials)n.approveTokenNftAllowanceAllSerials(i,o,t.spenderAccountId);else{if(!(t.serials&&t.serials.length>0))throw new Error("Either allSerials must be true or 'serials' (with serial numbers) must be provided for NFT allowance.");for(const s of t.serials){let a;a="number"==typeof s?e.Long.fromNumber(s):s instanceof r?e.Long.fromString(s.toString()):s,n.approveTokenNftAllowance(new e.NftId(i,a),o,t.spenderAccountId)}}return void 0!==t.memo&&(null===t.memo?this.logger.warn("Received null for memo in approveTokenNftAllowance."):n.setTransactionMemo(t.memo)),this.setCurrentTransaction(n),this}approveFungibleTokenAllowance(t){const n="string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId;let o;o="string"==typeof t.amount?e.Long.fromString(t.amount):"number"==typeof t.amount?e.Long.fromNumber(t.amount):t.amount instanceof r?e.Long.fromString(t.amount.toString()):t.amount;const i=(new e.AccountAllowanceApproveTransaction).approveTokenAllowance(n,t.ownerAccountId||this.kit.signer.getAccountId(),t.spenderAccountId,o);return this.setCurrentTransaction(i),this}deleteNftSpenderAllowance(t){const n="string"==typeof t.nftId?e.NftId.fromString(t.nftId):t.nftId,r=t.ownerAccountId||this.kit.signer.getAccountId(),o=(new e.AccountAllowanceDeleteTransaction).deleteAllTokenNftAllowances(n,r);return void 0!==t.memo&&(null===t.memo?this.logger.warn("Received null for memo in deleteNftSpenderAllowance."):o.setTransactionMemo(t.memo)),this.setCurrentTransaction(o),this}revokeHbarAllowance(t){const n=(new e.AccountAllowanceApproveTransaction).approveHbarAllowance(t.ownerAccountId||this.kit.signer.getAccountId(),t.spenderAccountId,new e.Hbar(0));return this.setCurrentTransaction(n),this}revokeFungibleTokenAllowance(t){const n="string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId,r=(new e.AccountAllowanceApproveTransaction).approveTokenAllowance(n,t.ownerAccountId||this.kit.signer.getAccountId(),t.spenderAccountId,0);return this.setCurrentTransaction(r),this}deleteNftSerialAllowancesForAllSpenders(t){let n;n=t.ownerAccountId?"string"==typeof t.ownerAccountId?e.AccountId.fromString(t.ownerAccountId):t.ownerAccountId:this.kit.signer.getAccountId();const r=t.nftIdString.split(".");if(4!==r.length)throw new Error(`Invalid nftIdString format: ${t.nftIdString}. Expected format like "0.0.token.serial".`);const o=e.TokenId.fromString(`${r[0]}.${r[1]}.${r[2]}`),i=e.Long.fromString(r[3]),s=new e.NftId(o,i),a=(new e.AccountAllowanceDeleteTransaction).deleteAllTokenNftAllowances(s,n);return t.memo&&a.setTransactionMemo(t.memo),this.setCurrentTransaction(a),this}deleteTokenNftAllowanceForSpender(t){let n;n=t.ownerAccountId?"string"==typeof t.ownerAccountId?e.AccountId.fromString(t.ownerAccountId):t.ownerAccountId:this.kit.signer.getAccountId();const r="string"==typeof t.tokenId?e.TokenId.fromString(t.tokenId):t.tokenId,o=t.serials.map(t=>"string"==typeof t?e.Long.fromString(t):"number"==typeof t?e.Long.fromNumber(t):t),i=(new e.AccountAllowanceDeleteTransaction).deleteAllTokenNftAllowances(new e.NftId(r,o[0]),n);return t.memo&&i.setTransactionMemo(t.memo),this.setCurrentTransaction(i),this}prepareSignScheduledTransaction(t){if(!t.scheduleId)throw new Error("scheduleId is required to prepare a ScheduleSignTransaction.");const n="string"==typeof t.scheduleId?e.ScheduleId.fromString(t.scheduleId):t.scheduleId,r=(new e.ScheduleSignTransaction).setScheduleId(n);return t.memo&&r.setTransactionMemo(t.memo),this.setCurrentTransaction(r),this}}const x=7776e3;class N extends f{constructor(e){super(e)}createContract(n){this.clearNotes();const r=new e.ContractCreateTransaction;if(n.bytecodeFileId)r.setBytecodeFileId(n.bytecodeFileId);else{if(!n.bytecode)throw new Error("Either bytecodeFileId or bytecode must be provided to create a contract.");"string"==typeof n.bytecode?r.setBytecode(t.Buffer.from(n.bytecode,"hex")):r.setBytecode(n.bytecode)}if(n.adminKey)if("string"==typeof n.adminKey){const e=m(n.adminKey);r.setAdminKey(e.privateKey)}else r.setAdminKey(n.adminKey);if("number"==typeof n.gas?r.setGas(n.gas):r.setGas(e.Long.fromValue(n.gas)),n.initialBalance){let t;t="number"==typeof n.initialBalance?new e.Hbar(n.initialBalance):e.Hbar.fromTinybars(e.Long.fromString(n.initialBalance.toString())),r.setInitialBalance(t)}return n.constructorParameters&&r.setConstructorParameters(n.constructorParameters),n.memo&&r.setContractMemo(n.memo),n.autoRenewPeriod?r.setAutoRenewPeriod(n.autoRenewPeriod):(r.setAutoRenewPeriod(x),this.addNote("Default auto-renew period of 7776000 seconds applied for contract.")),n.stakedAccountId&&r.setStakedAccountId(n.stakedAccountId),n.stakedNodeId&&r.setStakedNodeId(n.stakedNodeId),n.declineStakingReward&&r.setDeclineStakingReward(n.declineStakingReward),n.maxAutomaticTokenAssociations&&r.setMaxAutomaticTokenAssociations(n.maxAutomaticTokenAssociations),this.setCurrentTransaction(r),this}executeContract(t){let n;this.clearNotes(),n="number"==typeof t.gas?t.gas:e.Long.fromValue(t.gas);const r=(new e.ContractExecuteTransaction).setContractId(t.contractId).setGas(n).setFunction(t.functionName,t.functionParameters);if(t.payableAmount){let n;n=t.payableAmount instanceof e.Hbar?t.payableAmount:"number"==typeof t.payableAmount?new e.Hbar(t.payableAmount):e.Hbar.fromTinybars(e.Long.fromString(t.payableAmount.toString())),r.setPayableAmount(n)}return t.memo&&r.setTransactionMemo(t.memo),this.setCurrentTransaction(r),this}updateContract(t){if(this.clearNotes(),void 0===t.contractId)throw new Error("Contract ID is required to update a contract.");const n=(new e.ContractUpdateTransaction).setContractId(t.contractId);if(t.adminKey)if("string"==typeof t.adminKey){const e=m(t.adminKey);n.setAdminKey(e.privateKey)}else n.setAdminKey(t.adminKey);return t.autoRenewPeriod&&n.setAutoRenewPeriod(t.autoRenewPeriod),t.memo&&n.setContractMemo(t.memo),t.stakedAccountId&&n.setStakedAccountId(t.stakedAccountId),t.stakedNodeId&&n.setStakedNodeId(t.stakedNodeId),t.declineStakingReward&&n.setDeclineStakingReward(t.declineStakingReward),t.maxAutomaticTokenAssociations&&n.setMaxAutomaticTokenAssociations(t.maxAutomaticTokenAssociations),t.proxyAccountId&&n.setProxyAccountId(t.proxyAccountId),this.setCurrentTransaction(n),this}deleteContract(t){if(this.clearNotes(),void 0===t.contractId)throw new Error("Contract ID is required to delete a contract.");const n=(new e.ContractDeleteTransaction).setContractId(t.contractId);return t.transferAccountId?n.setTransferAccountId(t.transferAccountId):t.transferContractId&&n.setTransferContractId(t.transferContractId),this.setCurrentTransaction(n),this}async callContract(t){const n=(new e.ContractCallQuery).setContractId(t.contractId);t.gas&&("number"==typeof t.gas?n.setGas(t.gas):n.setGas(e.Long.fromValue(t.gas))),t.functionName&&(t.functionParameters?n.setFunction(t.functionName,t.functionParameters):n.setFunction(t.functionName)),t.maxQueryPayment&&n.setQueryPayment(t.maxQueryPayment),t.paymentTransactionId&&("string"==typeof t.paymentTransactionId?n.setPaymentTransactionId(e.TransactionId.fromString(t.paymentTransactionId)):n.setPaymentTransactionId(t.paymentTransactionId));try{return this.logger.info(`Executing ContractCallQuery for contract ${t.contractId.toString()}`),await n.execute(this.kit.client)}catch(r){throw this.logger.error(`ContractCallQuery failed for contract ${t.contractId.toString()}: ${r instanceof Error?r.message:JSON.stringify(r)}`),r}}}function v(e){const t={};for(const[n,r]of Object.entries(e))void 0!==r&&(t[n]=r);return t}class z{constructor(e){this.hederaKit=e,this.mirrorNode=e.mirrorNode}async getTopicInfo(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.getTopicInfo(t)}async getTopicMessages(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.getTopicMessages(t)}async getTopicMessagesByFilter(e,t){const n="string"==typeof e?e:e.toString();return await this.mirrorNode.getTopicMessagesByFilter(n,t)}async getAccountInfo(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.requestAccount(t)}async getAccountBalance(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.getAccountBalance(t)}async getAccountMemo(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.getAccountMemo(t)}async getTokenInfo(e){return await this.mirrorNode.getTokenInfo(e)}async getAccountTokens(e,t=100){const n="string"==typeof e?e:e.toString();return await this.mirrorNode.getAccountTokens(n,t)}async getAccountNfts(e,t,n=100){const r="string"==typeof e?e:e.toString();return await this.mirrorNode.getAccountNfts(r,t,n)}async validateNftOwnership(e,t,n){const r="string"==typeof e?e:e.toString();return await this.mirrorNode.validateNFTOwnership(r,t,n)}async getTransaction(e){return await this.mirrorNode.getTransaction(e)}async getTransactionByTimestamp(e){return await this.mirrorNode.getTransactionByTimestamp(e)}async getScheduleInfo(e){return await this.mirrorNode.getScheduleInfo(e)}async getScheduledTransactionStatus(e){return await this.mirrorNode.getScheduledTransactionStatus(e)}async getHbarPrice(e){return await this.mirrorNode.getHBARPrice(e)}async readSmartContract(e,t,n,r){const o="string"==typeof n?n:n.toString();return await this.mirrorNode.readSmartContractQuery(e,t,o,r)}async getPublicKey(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.getPublicKey(t)}async getTopicFees(e){const t="string"==typeof e?e:e.toString();return await this.mirrorNode.getTopicFees(t)}async checkKeyListAccess(e,t){return await this.mirrorNode.checkKeyListAccess(e,t)}async getOutstandingTokenAirdrops(e,t){let n,r;if("object"==typeof e&&"accountId"in e?(n=e.accountId,r=v({limit:e.limit,order:e.order,receiverId:e.receiverId,serialNumber:e.serialNumber,tokenId:e.tokenId})):(n="string"==typeof e?e:e.toString(),r=t),!r)return await this.mirrorNode.getOutstandingTokenAirdrops(n);const o=v(r),i=Object.keys(o).length>0;return await this.mirrorNode.getOutstandingTokenAirdrops(n,i?o:void 0)}async getPendingTokenAirdrops(e,t){let n,r;if("object"==typeof e&&"accountId"in e?(n=e.accountId,r=v({limit:e.limit,order:e.order,senderId:e.senderId,serialNumber:e.serialNumber,tokenId:e.tokenId})):(n="string"==typeof e?e:e.toString(),r=t),!r)return await this.mirrorNode.getPendingTokenAirdrops(n);const o=v(r),i=Object.keys(o).length>0;return await this.mirrorNode.getPendingTokenAirdrops(n,i?o:void 0)}async getBlocks(e){if(!e)return await this.mirrorNode.getBlocks();const t=v(e),n=Object.keys(t).length>0;return await this.mirrorNode.getBlocks(n?t:void 0)}async getBlock(e){return await this.mirrorNode.getBlock(e)}async getContractResults(e){return await this.mirrorNode.getContractResults(e)}async getContractResult(e,t){return await this.mirrorNode.getContractResult(e,t)}async getContractLogs(e){return await this.mirrorNode.getContractLogs(e)}async getContractActions(e,t){return await this.mirrorNode.getContractActions(e,t)}async getNftInfo(e,t){return await this.mirrorNode.getNftInfo(e,t)}async getNftsByToken(e,t){return await this.mirrorNode.getNftsByToken(e,t)}async getNetworkStake(e){return await this.mirrorNode.getNetworkStake(e)}async getNetworkSupply(e){return await this.mirrorNode.getNetworkSupply(e)}async getContracts(e){if(!e)return await this.mirrorNode.getContracts();const t=v(e),n=Object.keys(t).length>0;return await this.mirrorNode.getContracts(n?t:void 0)}async getContract(e,t,n){const r=await this.mirrorNode.getContract(e,t);return n||delete r?.bytecode,r}async getContractResultsByContract(e,t){return await this.mirrorNode.getContractResultsByContract(e,t)}async getContractState(e,t){return await this.mirrorNode.getContractState(e,t)}async getContractLogsByContract(e,t){return await this.mirrorNode.getContractLogsByContract(e,t)}async getNetworkInfo(){return await this.mirrorNode.getNetworkInfo()}async getNetworkFees(e){return await this.mirrorNode.getNetworkFees(e)}async getOpcodeTraces(e,t){return await this.mirrorNode.getOpcodeTraces(e,t)}}var C=(e=>(e.SMALL="SMALL",e.MEDIUM="MEDIUM",e.LARGE="LARGE",e.UNLIMITED="UNLIMITED",e))(C||{});class K{constructor(e,t,n){this.maxRetries=5,this.initialDelayMs=2e3,this.maxDelayMs=3e4,this.backoffFactor=2,this.network=e,n?.apiKey&&(this.apiKey=n.apiKey),this.customHeaders=n?.headers||{},this.baseUrl=n?.customUrl||this.getMirrorNodeUrl(),this.logger=t||new g({level:"debug",module:"MirrorNode"}),this.isServerEnvironment="undefined"==typeof window,n?.customUrl&&this.logger.info(`Using custom mirror node URL: ${n.customUrl}`),n?.apiKey&&this.logger.info("Using API key for mirror node requests")}configureRetry(e){this.maxRetries=e.maxRetries??this.maxRetries,this.initialDelayMs=e.initialDelayMs??this.initialDelayMs,this.maxDelayMs=e.maxDelayMs??this.maxDelayMs,this.backoffFactor=e.backoffFactor??this.backoffFactor,this.logger.info(`Retry configuration updated: maxRetries=${this.maxRetries}, initialDelayMs=${this.initialDelayMs}, maxDelayMs=${this.maxDelayMs}, backoffFactor=${this.backoffFactor}`)}configureMirrorNode(e){e.customUrl&&(this.baseUrl=e.customUrl,this.logger.info(`Updated mirror node URL: ${e.customUrl}`)),e.apiKey&&(this.apiKey=e.apiKey,this.logger.info("Updated API key for mirror node requests")),e.headers&&(this.customHeaders={...this.customHeaders,...e.headers},this.logger.info("Updated custom headers for mirror node requests"))}constructUrl(e){if(this.baseUrl.includes("<API-KEY>")&&this.apiKey){const t=this.baseUrl.replace("<API-KEY>",this.apiKey);return e.startsWith("/")?`${t}${e}`:`${t}/${e}`}return e.startsWith("/")?`${this.baseUrl}${e}`:`${this.baseUrl}/${e}`}getMirrorNodeUrl(){return"mainnet"===this.network?"https://mainnet-public.mirrornode.hedera.com":"https://testnet.mirrornode.hedera.com"}getBaseUrl(){return this.baseUrl}async getPublicKey(t){this.logger.info(`Getting public key for account ${t}`);const n=await this.requestAccount(t);try{if(!n||!n.key)throw new Error(`Failed to retrieve public key for account ID: ${t}`);return e.PublicKey.fromString(n.key.key)}catch(r){const e=`Error fetching public key from Mirror Node: ${r.message}`;throw this.logger.error(e),new Error(e)}}async getAccountMemo(e){this.logger.info(`Getting account memo for account ID: ${e}`);try{const t=await this._requestWithRetry(`/api/v1/accounts/${e}`);return t?.memo?t.memo:(this.logger.warn(`No memo found for account ${e}`),null)}catch(t){const n=t;return this.logger.error(`Failed to get account memo for ${e} after retries: ${n.message}`),null}}async getTopicInfo(e){try{this.logger.debug(`Fetching topic info for ${e}`);return await this._requestWithRetry(`/api/v1/topics/${e}`)}catch(t){const n=`Error retrieving topic information for ${e} after retries: ${t.message}`;throw this.logger.error(n),new Error(n)}}async getTopicFees(e){try{return(await this.getTopicInfo(e)).custom_fees}catch(t){const e=`Error retrieving topic fees: ${t.message}`;return this.logger.error(e),null}}async getHBARPrice(t){try{const n=e.Timestamp.fromDate(t).toString();this.logger.debug(`Fetching HBAR price for timestamp ${n}`);const r=await this._requestWithRetry(`/api/v1/network/exchangerate?timestamp=${n}`);return Number(r?.current_rate?.cent_equivalent)/Number(r?.current_rate?.hbar_equivalent)/100}catch(n){const e=`Error retrieving HBAR price: ${n.message}`;return this.logger.error(e),null}}async getTokenInfo(e){this.logger.debug(`Fetching token info for ${e}`);try{const t=await this._requestWithRetry(`/api/v1/tokens/${e}`);return t?(this.logger.trace(`Token info found for ${e}:`,t),t):(this.logger.warn(`No token info found for ${e}`),null)}catch(t){const n=`Error fetching token info for ${e}: ${t.message}`;return this.logger.error(n),null}}async getTopicMessages(e,t){this.logger.trace(`Querying messages for topic ${e}${t?" with filters":""}`);let n=`/api/v1/topics/${e}/messages`;const r=new URLSearchParams;if(t){if(void 0!==t.sequenceNumber){const e="number"==typeof t.sequenceNumber?t.sequenceNumber.toString():t.sequenceNumber;e.match(/^(gt|gte|lt|lte|eq|ne):/)?r.append("sequencenumber",e):r.append("sequencenumber",`gt:${e}`)}t.limit&&r.append("limit",t.limit.toString()),t.order&&r.append("order",t.order)}const o=r.toString();o&&(n+=`?${o}`);const i=[];let s=n;for(;s;)try{const e=await this._requestWithRetry(s);if(e.messages&&e.messages.length>0)for(const t of e.messages)try{if(!t.message)continue;let e,n;try{e=this.isServerEnvironment?globalThis.Buffer.from(t.message,"base64").toString("utf-8"):(new TextDecoder).decode(Uint8Array.from(atob(t.message),e=>e.charCodeAt(0)))}catch(a){const e=`Error decoding message: ${a}`;this.logger.error(e);continue}try{n=JSON.parse(e)}catch{const t=`Invalid JSON message content: ${e}`;this.logger.error(t);continue}n.sequence_number=t.sequence_number,i.push({...n,consensus_timestamp:t.consensus_timestamp,sequence_number:t.sequence_number,created:new Date(1e3*Number(t.consensus_timestamp))})}catch(a){const e=`Error processing message: ${a.message}`;this.logger.error(e)}s=e.links?.next||""}catch(c){const t=`Error querying topic messages for topic ${e} (endpoint: ${s}) after retries: ${c.message}`;throw this.logger.error(t),new Error(t)}return i}async requestAccount(e){try{this.logger.debug(`Requesting account info for ${e}`);const t=await this._requestWithRetry(`/api/v1/accounts/${e}`);if(!t)throw new Error(`No data received from mirror node for account: ${e}`);return t}catch(t){const n=`Failed to fetch account ${e} after retries: ${t.message}`;throw this.logger.error(n),new Error(n)}}async checkKeyListAccess(e,t){try{const n=i.proto.Key.decode(e);return this.evaluateKeyAccess(n,t)}catch(n){const e=`Error decoding protobuf key: ${n.message}`;throw this.logger.error(e),new Error(e)}}async evaluateKeyAccess(e,t){return e.ed25519?this.compareEd25519Key(e.ed25519,t):e.keyList?this.evaluateKeyList(e.keyList,t):!(!e.thresholdKey||!e.thresholdKey.keys)&&this.evaluateKeyList(e.thresholdKey.keys,t)}async evaluateKeyList(e,t){const n=e.keys||[];for(const o of n)if(o)if(o.ed25519){if(this.compareEd25519Key(o.ed25519,t))return!0}else if(o.keyList||o.thresholdKey)try{const e=i.proto.Key.encode({...o.keyList?{keyList:o.keyList}:{},...o.thresholdKey?{thresholdKey:o.thresholdKey}:{}}).finish();if(await this.checkKeyListAccess(globalThis.Buffer.from(e),t))return!0}catch(r){const e=`Error in nested key: ${r.message}`;this.logger.debug(e)}return!1}compareEd25519Key(t,n){try{return e.PublicKey.fromBytes(globalThis.Buffer.from(t)).toString()===n.toString()}catch(r){const e=`Error comparing Ed25519 key: ${r.message}`;return this.logger.debug(e),!1}}async getScheduleInfo(e){try{this.logger.info(`Getting information for scheduled transaction ${e}`);const t=await this._requestWithRetry(`/api/v1/schedules/${e}`);return t||(this.logger.warn(`No schedule info found for ${e} after retries.`),null)}catch(t){return this.logger.error(`Error fetching schedule info for ${e} after retries: ${t.message}`),null}}async getScheduledTransactionStatus(e){try{this.logger.info(`Checking status of scheduled transaction ${e}`);const t=await this.getScheduleInfo(e);if(!t)throw new Error(`Schedule ${e} not found`);return{executed:Boolean(t.executed_timestamp),executedDate:t.executed_timestamp?new Date(1e3*Number(t.executed_timestamp)):void 0,deleted:t.deleted||!1}}catch(t){throw this.logger.error(`Error checking scheduled transaction status: ${t}`),t}}async getTransaction(e){this.logger.info(`Getting transaction details for ID/hash: ${e}`);try{const t=await this._requestWithRetry(`/api/v1/transactions/${e}`);return t?.transactions?.length>0?(this.logger.trace(`Transaction details found for ${e}:`,t.transactions[0]),t.transactions[0]):(this.logger.warn(`No transaction details found for ${e} or unexpected response structure.`),null)}catch(t){const n=t;return this.logger.error(`Failed to get transaction details for ${e} after retries: ${n.message}`),null}}async _requestWithRetry(e,t){let n=0,r=this.initialDelayMs;const i=this.constructUrl(e),s={...t,headers:{...this.customHeaders,...t?.headers}};for(this.apiKey&&(s.headers={...s.headers,Authorization:`Bearer ${this.apiKey}`,"X-API-Key":this.apiKey});n<this.maxRetries;)try{return(await o.get(i,s)).data}catch(a){n++;const e=n>=this.maxRetries,t=a.response?.status;if(t&&t>404&&t<500&&429!==t)throw this.logger.error(`Client error for ${i} (status ${t}): ${a.message}. Not retrying.`),a;if(e)throw this.logger.error(`Max retries (${this.maxRetries}) reached for ${i}. Last error: ${a.message}`),a;this.logger.warn(`Attempt ${n}/${this.maxRetries} failed for ${i}: ${a.message}. Retrying in ${r}ms...`),await new Promise(e=>setTimeout(e,r)),r=Math.min(r*this.backoffFactor,this.maxDelayMs)}throw new Error(`Failed to fetch data from ${i} after ${this.maxRetries} attempts.`)}async _fetchWithRetry(e,t){let n=0,r=this.initialDelayMs;const o={...this.customHeaders};t?.headers&&(t.headers instanceof Headers?t.headers.forEach((e,t)=>{o[t]=e}):Array.isArray(t.headers)?t.headers.forEach(([e,t])=>{o[e]=t}):Object.assign(o,t.headers)),this.apiKey&&(o.Authorization=`Bearer ${this.apiKey}`,o["X-API-Key"]=this.apiKey);const i={...t,headers:o};for(;n<this.maxRetries;)try{const t=await fetch(e,i);if(!t.ok){if(t.status>=400&&t.status<500&&429!==t.status)throw this.logger.error(`Client error for ${e} (status ${t.status}): ${t.statusText}. Not retrying.`),new Error(`Fetch failed with status ${t.status}: ${t.statusText} for URL: ${e}`);throw new Error(`Fetch failed with status ${t.status}: ${t.statusText} for URL: ${e}`)}return await t.json()}catch(s){if(n++,n>=this.maxRetries)throw this.logger.error(`Max retries (${this.maxRetries}) reached for ${e}. Last error: ${s.message}`),s;this.logger.warn(`Attempt ${n}/${this.maxRetries} failed for ${e}: ${s.message}. Retrying in ${r}ms...`),await new Promise(e=>setTimeout(e,r)),r=Math.min(r*this.backoffFactor,this.maxDelayMs)}throw new Error(`Failed to fetch data from ${e} after ${this.maxRetries} attempts.`)}async getAccountBalance(e){this.logger.info(`Getting balance for account ${e}`);try{const t=await this.requestAccount(e);if(t&&t.balance){return t.balance.balance/1e8}return this.logger.warn(`Could not retrieve balance for account ${e} from account info.`),null}catch(t){return this.logger.error(`Error fetching numerical balance for account ${e}: ${t.message}`),null}}async getTopicMessagesByFilter(e,t){this.logger.trace(`Querying messages for topic ${e} with filters: ${JSON.stringify(t)}`);let n=`/api/v1/topics/${e}/messages`;const r=new URLSearchParams;t?.limit&&r.append("limit",t.limit.toString()),t?.sequenceNumber&&r.append("sequencenumber",t.sequenceNumber),t?.startTime&&r.append("timestamp",`gte:${t.startTime}`),t?.endTime&&r.append("timestamp",`lt:${t.endTime}`),t?.order&&r.append("order",t.order);const o=r.toString();o&&(n+=`?${o}`);const i=[];let s=0;try{for(;n&&s<10;){s++;const e=await this._requestWithRetry(n);if(e.messages&&e.messages.length>0)for(const t of e.messages)try{if(!t.message)continue;let e;e=this.isServerEnvironment?globalThis.Buffer.from(t.message,"base64").toString("utf-8"):(new TextDecoder).decode(Uint8Array.from(atob(t.message),e=>e.charCodeAt(0)));let n={};try{n=JSON.parse(e)}catch{this.logger.debug(`Message content is not valid JSON, using raw: ${e}`),n={raw_content:e}}const r={...n,consensus_timestamp:t.consensus_timestamp,sequence_number:t.sequence_number,payer_account_id:t.payer_account_id,topic_id:t.topic_id,running_hash:t.running_hash,running_hash_version:t.running_hash_version,chunk_info:t.chunk_info??{},created:new Date(1e3*Number(t.consensus_timestamp.split(".")[0])+Number(t.consensus_timestamp.split(".")[1]||0)/1e6),payer:t.payer_account_id};i.push(r)}catch(a){const e=a;this.logger.error(`Error processing individual message: ${e.message}`)}if(t?.limit&&i.length>=t.limit)break;n=e.links?.next?`${e.links.next}`:""}return i}catch(a){const t=a;return this.logger.error(`Error querying filtered topic messages for ${e}: ${t.message}`),null}}async getAccountTokens(e,t=100){this.logger.info(`Getting tokens for account ${e}`);let n=[],r=`/api/v1/accounts/${e}/tokens?limit=${t}`;try{for(let e=0;e<10&&r;e++){const e=await this._requestWithRetry(r);if(e&&e.tokens&&(n=n.concat(e.tokens)),r=e.links?.next||"",!r||t&&n.length>=t){t&&n.length>t&&(n=n.slice(0,t));break}}return n}catch(o){return this.logger.error(`Error fetching tokens for account ${e}: ${o.message}`),null}}async getTransactionByTimestamp(e){this.logger.info(`Getting transaction by timestamp: ${e}`);try{return(await this._requestWithRetry(`/api/v1/transactions?timestamp=${e}&limit=1`)).transactions}catch(t){return this.logger.error(`Error fetching transaction by timestamp ${e}: ${t}`),[]}}async getAccountNfts(e,t,n=100){this.logger.info(`Getting NFTs for account ${e}${t?` for token ${t}`:""}`);let r=[],o=`/api/v1/accounts/${e}/nfts?limit=${n}`;t&&(o+=`&token.id=${t}`);try{for(let e=0;e<10&&o;e++){const e=await this._requestWithRetry(o);if(e&&e.nfts){const t=e.nfts.map(e=>{let t;if(e.metadata)try{t=this.isServerEnvironment?globalThis.Buffer.from(e.metadata,"base64").toString("utf-8"):(new TextDecoder).decode(Uint8Array.from(atob(e.metadata),e=>e.charCodeAt(0)))}catch(n){this.logger.warn(`Failed to decode metadata for NFT ${e.token_id} SN ${e.serial_number}: ${n.message}`)}return{...e,token_uri:t}});r=r.concat(t)}if(o=e.links?.next||"",!o)break}return r}catch(i){return this.logger.error(`Error fetching NFTs for account ${e}: ${i}`),null}}async validateNFTOwnership(e,t,n){this.logger.info(`Validating ownership of NFT ${t} SN ${n} for account ${e}`);try{const r=await this.getAccountNfts(e,t);if(r){return r.find(e=>e.token_id===t&&e.serial_number===n)||null}return null}catch(r){return this.logger.error(`Error validating NFT ownership: ${r.message}`),null}}async readSmartContractQuery(t,n,r,o){this.logger.info(`Reading smart contract ${t} with selector ${n}`);const i=t.startsWith("0x")?t:`0x${e.AccountId.fromString(t).toSolidityAddress()}`,s=r.startsWith("0x")?r:`0x${e.AccountId.fromString(r).toSolidityAddress()}`,a={block:o?.block||"latest",data:n,estimate:o?.estimate||!1,from:s,to:i,gas:o?.gas,gasPrice:o?.gasPrice,value:o?.value||0};Object.keys(a).forEach(e=>{const t=e;void 0===a[t]&&delete a[t]});try{const e=this.constructUrl("/api/v1/contracts/call");return await this._fetchWithRetry(e,{method:"POST",body:JSON.stringify(a),headers:{"Content-Type":"application/json"}})}catch(c){return this.logger.error(`Error reading smart contract ${t}: ${c.message}`),null}}async getOutstandingTokenAirdrops(e,t){this.logger.info(`Getting outstanding token airdrops sent by account ${e}`);let n=`/api/v1/accounts/${e}/airdrops/outstanding`;const r=new URLSearchParams;t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order),t?.receiverId&&r.append("receiver.id",t.receiverId),t?.serialNumber&&r.append("serialnumber",t.serialNumber),t?.tokenId&&r.append("token.id",t.tokenId);const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).airdrops||[]}catch(i){return this.logger.error(`Error fetching outstanding token airdrops for account ${e}: ${i.message}`),null}}async getPendingTokenAirdrops(e,t){this.logger.info(`Getting pending token airdrops received by account ${e}`);let n=`/api/v1/accounts/${e}/airdrops/pending`;const r=new URLSearchParams;t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order),t?.senderId&&r.append("sender.id",t.senderId),t?.serialNumber&&r.append("serialnumber",t.serialNumber),t?.tokenId&&r.append("token.id",t.tokenId);const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).airdrops||[]}catch(i){return this.logger.error(`Error fetching pending token airdrops for account ${e}: ${i.message}`),null}}async getBlocks(e){this.logger.info("Getting blocks from the network");let t="/api/v1/blocks";const n=new URLSearchParams;e?.limit&&n.append("limit",e.limit.toString()),e?.order&&n.append("order",e.order),e?.timestamp&&n.append("timestamp",e.timestamp),e?.blockNumber&&n.append("block.number",e.blockNumber);const r=n.toString();r&&(t+=`?${r}`);try{return(await this._requestWithRetry(t)).blocks||[]}catch(o){return this.logger.error(`Error fetching blocks: ${o.message}`),null}}async getBlock(e){this.logger.info(`Getting block ${e}`);try{return await this._requestWithRetry(`/api/v1/blocks/${e}`)}catch(t){return this.logger.error(`Error fetching block ${e}: ${t.message}`),null}}async getContracts(e){this.logger.info("Getting contracts from the network");let t="/api/v1/contracts";const n=new URLSearchParams;e?.contractId&&n.append("contract.id",e.contractId),e?.limit&&n.append("limit",e.limit.toString()),e?.order&&n.append("order",e.order);const r=n.toString();r&&(t+=`?${r}`);try{return(await this._requestWithRetry(t)).contracts||[]}catch(o){return this.logger.error(`Error fetching contracts: ${o.message}`),null}}async getContract(e,t){this.logger.info(`Getting contract ${e}`);let n=`/api/v1/contracts/${e}`;t&&(n+=`?timestamp=${t}`);try{return await this._requestWithRetry(n)}catch(r){return this.logger.error(`Error fetching contract ${e}: ${r.message}`),null}}async getContractResults(e){this.logger.info("Getting contract results from the network");let t="/api/v1/contracts/results";const n=new URLSearchParams;e?.from&&n.append("from",e.from),e?.blockHash&&n.append("block.hash",e.blockHash),e?.blockNumber&&n.append("block.number",e.blockNumber),void 0!==e?.internal&&n.append("internal",e.internal.toString()),e?.limit&&n.append("limit",e.limit.toString()),e?.order&&n.append("order",e.order),e?.timestamp&&n.append("timestamp",e.timestamp),e?.transactionIndex&&n.append("transaction.index",e.transactionIndex.toString());const r=n.toString();r&&(t+=`?${r}`);try{return(await this._requestWithRetry(t)).results||[]}catch(o){return this.logger.error(`Error fetching contract results: ${o.message}`),null}}async getContractResult(e,t){this.logger.info(`Getting contract result for ${e}`);let n=`/api/v1/contracts/results/${e}`;void 0!==t&&(n+=`?nonce=${t}`);try{return await this._requestWithRetry(n)}catch(r){return this.logger.error(`Error fetching contract result for ${e}: ${r.message}`),null}}async getContractResultsByContract(e,t){this.logger.info(`Getting contract results for contract ${e}`);let n=`/api/v1/contracts/${e}/results`;const r=new URLSearchParams;t?.blockHash&&r.append("block.hash",t.blockHash),t?.blockNumber&&r.append("block.number",t.blockNumber),t?.from&&r.append("from",t.from),void 0!==t?.internal&&r.append("internal",t.internal.toString()),t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order),t?.timestamp&&r.append("timestamp",t.timestamp),t?.transactionIndex&&r.append("transaction.index",t.transactionIndex.toString());const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).results||[]}catch(i){return this.logger.error(`Error fetching contract results for ${e}: ${i.message}`),null}}async getContractState(e,t){this.logger.info(`Getting contract state for ${e}`);let n=`/api/v1/contracts/${e}/state`;const r=new URLSearchParams;t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order),t?.slot&&r.append("slot",t.slot),t?.timestamp&&r.append("timestamp",t.timestamp);const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).state||[]}catch(i){return this.logger.error(`Error fetching contract state for ${e}: ${i.message}`),null}}async getContractActions(e,t){this.logger.info(`Getting contract actions for ${e}`);let n=`/api/v1/contracts/results/${e}/actions`;const r=new URLSearchParams;t?.index&&r.append("index",t.index),t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order);const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).actions||[]}catch(i){return this.logger.error(`Error fetching contract actions for ${e}: ${i.message}`),null}}async getContractLogs(e){this.logger.info("Getting contract logs from the network");let t="/api/v1/contracts/results/logs";const n=new URLSearchParams;e?.index&&n.append("index",e.index),e?.limit&&n.append("limit",e.limit.toString()),e?.order&&n.append("order",e.order),e?.timestamp&&n.append("timestamp",e.timestamp),e?.topic0&&n.append("topic0",e.topic0),e?.topic1&&n.append("topic1",e.topic1),e?.topic2&&n.append("topic2",e.topic2),e?.topic3&&n.append("topic3",e.topic3),e?.transactionHash&&n.append("transaction.hash",e.transactionHash);const r=n.toString();r&&(t+=`?${r}`);try{return(await this._requestWithRetry(t)).logs||[]}catch(o){return this.logger.error(`Error fetching contract logs: ${o.message}`),null}}async getContractLogsByContract(e,t){this.logger.info(`Getting contract logs for contract ${e}`);let n=`/api/v1/contracts/${e}/results/logs`;const r=new URLSearchParams;t?.index&&r.append("index",t.index),t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order),t?.timestamp&&r.append("timestamp",t.timestamp),t?.topic0&&r.append("topic0",t.topic0),t?.topic1&&r.append("topic1",t.topic1),t?.topic2&&r.append("topic2",t.topic2),t?.topic3&&r.append("topic3",t.topic3);const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).logs||[]}catch(i){return this.logger.error(`Error fetching contract logs for ${e}: ${i.message}`),null}}async getNftInfo(e,t){this.logger.info(`Getting NFT info for ${e}/${t}`);const n=`/api/v1/tokens/${e}/nfts/${t}`;try{return await this._requestWithRetry(n)}catch(r){return this.logger.error(`Error fetching NFT info for ${e}/${t}: ${r.message}`),null}}async getNftsByToken(e,t){this.logger.info(`Getting NFTs for token ${e}`);let n=`/api/v1/tokens/${e}/nfts`;const r=new URLSearchParams;t?.accountId&&r.append("account.id",t.accountId),t?.limit&&r.append("limit",t.limit.toString()),t?.order&&r.append("order",t.order),t?.serialNumber&&r.append("serialnumber",t.serialNumber);const o=r.toString();o&&(n+=`?${o}`);try{return(await this._requestWithRetry(n)).nfts||[]}catch(i){return this.logger.error(`Error fetching NFTs for token ${e}: ${i.message}`),null}}async getNetworkInfo(){this.logger.info("Getting network information");try{return await this._requestWithRetry("/api/v1/network/nodes")}catch(e){return this.logger.error(`Error fetching network info: ${e.message}`),null}}async getNetworkFees(e){this.logger.info("Getting network fees");let t="/api/v1/network/fees";e&&(t+=`?timestamp=${e}`);try{return await this._requestWithRetry(t)}catch(n){return this.logger.error(`Error fetching network fees: ${n.message}`),null}}async getNetworkSupply(e){this.logger.info("Getting network supply");let t="/api/v1/network/supply";e&&(t+=`?timestamp=${e}`);try{return await this._requestWithRetry(t)}catch(n){return this.logger.error(`Error fetching network supply: ${n.message}`),null}}async getNetworkStake(e){this.logger.info("Getting network stake");let t="/api/v1/network/stake";e&&(t+=`?timestamp=${e}`);try{return await this._requestWithRetry(t)}catch(n){return this.logger.error(`Error fetching network stake: ${n.message}`),null}}async getOpcodeTraces(e,t){this.logger.info(`Getting opcode traces for ${e}`);let n=`/api/v1/contracts/results/${e}/opcodes`;const r=new URLSearchParams;void 0!==t?.stack&&r.append("stack",t.stack.toString()),void 0!==t?.memory&&r.append("memory",t.memory.toString()),void 0!==t?.storage&&r.append("storage",t.storage.toString());const o=r.toString();o&&(n+=`?${o}`);try{return await this._requestWithRetry(n)}catch(i){return this.logger.error(`Error fetching opcode traces for ${e}: ${i.message}`),null}}}const O="HederaAgentKit not initialized. Call await kit.initialize() first.";class F{constructor(t,n,r="returnBytes",o,i=!0,s=C.MEDIUM,a,c,l=!1){this.isInitialized=!1,this.signer=t,this.network=this.signer.getNetwork();const d=l||"true"===process.env.DISABLE_LOGS;if(this.logger=new g({level:d?"silent":"info",module:"HederaAgentKit",silent:d}),"mainnet"===this.network)this.client=e.Client.forMainnet();else{if("testnet"!==this.network)throw new Error(`Unsupported network type: ${this.network}`);this.client=e.Client.forTestnet()}this.client.setOperator(this.signer.getAccountId(),this.signer.getOperatorPrivateKey()),this.mirrorNode=new K(this.network,new g({level:d?"silent":"info",module:"HederaAgentKit-MirrorNode",silent:d}),c),this.pluginConfigInternal=n,this.loadedPlugins=[],this.aggregatedTools=[],this.operationalMode=r,this.userAccountId=o,this.scheduleUserTransactionsInBytesMode=i,this.modelCapability=s,this.modelName=a}async initialize(){if(this.isInitialized)return void this.logger.warn("HederaAgentKit is already initialized.");this.loadedPlugins=[];const e={logger:this.logger,config:{...this.pluginConfigInternal?.appConfig||{},hederaKit:this,modelCapability:this.modelCapability},client:{getNetwork:()=>this.network}},t=[],n=new Set;if(this.pluginConfigInternal?.plugins)for(const i of this.pluginConfigInternal.plugins)n.has(i.id)||(t.push(i),n.add(i.id));for(const i of t)try{this.logger.info(`Initializing plugin: ${i.name}`),await i.initialize(e),this.loadedPlugins.push(i),this.logger.info(`Successfully initialized and added plugin: ${i.name}`)}catch(o){this.logger.error(`Failed to initialize plugin ${i.name}: ${o instanceof Error?o.message:String(o)}`)}const r=this.loadedPlugins.flatMap(e=>e.getTools());this.aggregatedTools=[...r],this.isInitialized=!0,this.logger.info("HederaAgentKit initialized successfully with all tools aggregated.")}async getOperator(){return{id:this.signer.getAccountId(),publicKey:await this.signer.getPublicKey()}}getAggregatedLangChainTools(){if(!this.isInitialized)throw new Error("HederaAgentKit not initialized. Call await kit.initialize() before accessing tools.");return this.aggregatedTools}hcs(){if(!this.isInitialized)throw new Error(O);return new b(this)}hts(){if(!this.isInitialized)throw new Error(O);return new w(this)}accounts(){if(!this.isInitialized)throw new Error(O);return new S(this)}scs(){if(!this.isInitialized)throw new Error(O);return new N(this)}query(){if(!this.isInitialized)throw new Error(O);return new z(this)}async getTransactionReceipt(t){const n="string"==typeof t?e.TransactionId.fromString(t):t;try{return await n.getReceipt(this.client)}catch(r){throw this.logger.error(`Failed to get transaction receipt for ${n.toString()}: ${r instanceof Error?r.message:String(r)}`),r}}async signScheduledTransaction(t){if(!this.isInitialized)throw new Error("HederaAgentKit not initialized. Call await kit.initialize() first.");this.logger.info(`Attempting to sign scheduled transaction: ${t.scheduleId.toString()}`);const n="string"==typeof t.scheduleId?e.ScheduleId.fromString(t.scheduleId):t.scheduleId,r=(new e.ScheduleSignTransaction).setScheduleId(n);let o;t.memo&&r.setTransactionMemo(t.memo),r.transactionId||r.freezeWith(this.client),o=r.transactionId?.toString();try{return{success:!0,receipt:await this.signer.signAndExecuteTransaction(r),transactionId:o}}catch(i){return this.logger.error(`Failed to sign scheduled transaction ${t.scheduleId.toString()}: ${i instanceof Error?i.message:String(i)}`),{success:!1,error:i instanceof Error?i.message:String(i),transactionId:o}}}}const $={"gpt-3.5-turbo":{capability:C.SMALL,contextWindow:16385,description:"OpenAI GPT-3.5 Turbo"},"gpt-4":{capability:C.LARGE,contextWindow:8192,description:"OpenAI GPT-4"},"gpt-4-turbo":{capability:C.MEDIUM,contextWindow:128e3,description:"OpenAI GPT-4 Turbo"},"gpt-4o":{capability:C.MEDIUM,contextWindow:128e3,description:"OpenAI GPT-4o"},"gpt-4o-mini":{capability:C.SMALL,contextWindow:128e3,description:"OpenAI GPT-4o Mini"},"o1-preview":{capability:C.LARGE,contextWindow:128e3,description:"OpenAI o1 Preview"},"o1-mini":{capability:C.MEDIUM,contextWindow:128e3,description:"OpenAI o1 Mini"},"o3-mini":{capability:C.MEDIUM,contextWindow:128e3,description:"OpenAI o3 Mini"},"claude-3.5-sonnet":{capability:C.LARGE,contextWindow:2e5,description:"Anthropic Claude 3.5 Sonnet"},"claude-4":{capability:C.LARGE,contextWindow:2e5,description:"Anthropic Claude 4"},"gemini-1.5-pro":{capability:C.LARGE,contextWindow:2e6,description:"Google Gemini 1.5 Pro"}};class E{constructor(){this.lastFetchTime=0,this.CACHE_DURATION=864e5,this.OPENROUTER_API_URL="https://openrouter.ai/api/v1/models",this.registry={...$}}static getInstance(){return E.instance||(E.instance=new E),E.instance}determineCapability(e){const t=e.id.toLowerCase(),n=e.context_length;return t.includes("mini")||t.includes("tiny")||t.includes("light")||t.includes("instant")||t.includes("3.5-turbo")?C.SMALL:t.includes("local")||t.includes("llama")||t.includes("mistral")||t.includes("yi-")||t.includes("qwen")||t.includes("deepseek")||t.includes("phi-")||t.includes("mythomax")||t.includes("valkyrie")?C.UNLIMITED:n<=16e3?C.SMALL:n<=5e4?C.MEDIUM:C.LARGE}async fetchModelsFromAPI(){try{const e=await fetch(this.OPENROUTER_API_URL,{headers:{Accept:"application/json","User-Agent":"hedera-agent-kit/1.0"}});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);const t=(await e.json()).data||[];this.registry={...$};for(const n of t){const e={capability:this.determineCapability(n),contextWindow:n.context_length,description:n.name};this.registry[n.id]=e;const t=this.getSimplifiedModelId(n.id);t!==n.id&&(this.registry[t]=e)}this.lastFetchTime=Date.now(),console.log(`ModelCapabilityDetector: Loaded ${t.length} models from OpenRouter API`)}catch(e){console.warn("ModelCapabilityDetector: Failed to fetch from API, using fallback registry:",e)}}getSimplifiedModelId(e){return e.startsWith("openai/")?e.replace("openai/",""):e.startsWith("anthropic/")?e.replace("anthropic/",""):e.startsWith("google/")?e.replace("google/",""):e.startsWith("mistralai/")?e.replace("mistralai/",""):e.startsWith("meta-llama/")?e.replace("meta-llama/",""):e}async ensureModelsLoaded(){Date.now()-this.lastFetchTime>this.CACHE_DURATION&&await this.fetchModelsFromAPI()}registerModel(e,t){this.registry[e]=t}registerModels(e){Object.assign(this.registry,e)}async getModelCapability(e){if(!e)return C.MEDIUM;await this.ensureModelsLoaded();const t=this.registry[e];if(t)return t.capability;const n=e.toLowerCase();for(const[r,o]of Object.entries(this.registry))if(n.includes(r.toLowerCase())||r.toLowerCase().includes(n))return o.capability;return this.getCapabilityFromHeuristics(n)}getModelCapabilitySync(e){if(!e)return C.MEDIUM;const t=this.registry[e];if(t)return t.capability;const n=e.toLowerCase();for(const[r,o]of Object.entries(this.registry))if(n.includes(r.toLowerCase())||r.toLowerCase().includes(n))return o.capability;return this.getCapabilityFromHeuristics(n)}getCapabilityFromHeuristics(e){return e.includes("mini")||e.includes("3.5")||e.includes("tiny")||e.includes("light")||e.includes("instant")?C.SMALL:e.includes("turbo")||e.includes("4o")||e.includes("flash")||e.includes("small")||e.includes("medium")||e.includes("haiku")||e.includes("bison")||e.includes("palm")?C.MEDIUM:e.includes("claude")||e.includes("gpt-4")||e.includes("gemini")||e.includes("sonnet")||e.includes("opus")||e.includes("large")||e.includes("ultra")||e.includes("mixtral")||e.includes("command-r")||e.includes("o1")||e.includes("o3")?C.LARGE:e.includes("local")||e.includes("ollama")||e.includes("llama")||e.includes("mistral")||e.includes("yi-")||e.includes("qwen")||e.includes("deepseek")||e.includes("phi-")?C.UNLIMITED:C.MEDIUM}async getModelConfig(e){return await this.ensureModelsLoaded(),this.registry[e]}async getContextWindow(e){if(!e)return 16385;await this.ensureModelsLoaded();const t=this.registry[e];if(t)return t.contextWindow;const n=e.toLowerCase();for(const[r,o]of Object.entries(this.registry))if(n.includes(r.toLowerCase())||r.toLowerCase().includes(n))return o.contextWindow;return 16385}getContextWindowSync(e){if(!e)return 16385;const t=this.registry[e];if(t)return t.contextWindow;const n=e.toLowerCase();for(const[r,o]of Object.entries(this.registry))if(n.includes(r.toLowerCase())||r.toLowerCase().includes(n))return o.contextWindow;return 16385}async getAllModels(){return await this.ensureModelsLoaded(),{...this.registry}}async isModelRegistered(e){return await this.ensureModelsLoaded(),e in this.registry}async getModelsByCapability(e){return await this.ensureModelsLoaded(),Object.entries(this.registry).filter(([,t])=>t.capability===e).map(([e])=>e)}async refreshModels(){this.lastFetchTime=0,await this.fetchModelsFromAPI()}getCacheStatus(){const e=Date.now()-this.lastFetchTime>this.CACHE_DURATION;return{lastFetch:new Date(this.lastFetchTime),isStale:e,modelCount:Object.keys(this.registry).length}}}const R="gpt-4o-mini";class D{constructor(){this.pricingCache=new Map,this.lastFetchTime=0,this.CACHE_DURATION=864e5,this.OPENROUTER_API_URL="https://openrouter.ai/api/v1/models",this.DEFAULT_MODEL="gpt-4o-mini",this.logger=new g({module:"ModelPricingManager",level:"info"}),this.initializeFallbackPricing()}static getInstance(){return D.instance||(D.instance=new D),D.instance}initializeFallbackPricing(){const e={"gpt-4o":{prompt:.005,completion:.015},[this.DEFAULT_MODEL]:{prompt:15e-5,completion:6e-4},"gpt-4-turbo":{prompt:.01,completion:.03},"gpt-4":{prompt:.03,completion:.06},"gpt-3.5-turbo":{prompt:5e-4,completion:.0015}};for(const[t,n]of Object.entries(e))this.pricingCache.set(t,n)}async fetchPricingFromAPI(){try{const e=await fetch(this.OPENROUTER_API_URL,{headers:{Accept:"application/json","User-Agent":"hedera-agent-kit/1.0"}});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);const t=(await e.json()).data||[];for(const n of t)if(n.pricing?.prompt&&n.pricing?.completion){const e=parseFloat(n.pricing.prompt),t=parseFloat(n.pricing.completion);if(!isNaN(e)&&!isNaN(t)){this.pricingCache.set(n.id,{prompt:1e3*e,completion:1e3*t});const r=this.getSimplifiedModelId(n.id);r!==n.id&&this.pricingCache.set(r,{prompt:1e3*e,completion:1e3*t})}}this.lastFetchTime=Date.now(),this.logger.info(`Loaded pricing for ${t.length} models from OpenRouter API`)}catch(e){this.logger.warn("Failed to fetch pricing from API, using fallback pricing",e)}}getSimplifiedModelId(e){const t=["openai/","anthropic/","google/","mistralai/","meta-llama/"];for(const n of t)if(e.startsWith(n))return e.replace(n,"");return e}async ensurePricingLoaded(){(Date.now()-this.lastFetchTime>this.CACHE_DURATION||this.pricingCache.size<10)&&await this.fetchPricingFromAPI()}async getPricing(e){await this.ensurePricingLoaded();const t=this.pricingCache.get(e);if(t)return t;const n=e.toLowerCase();for(const[r,o]of this.pricingCache.entries())if(r.toLowerCase().includes(n)||n.includes(r.toLowerCase()))return o;return this.pricingCache.get(this.DEFAULT_MODEL)||{prompt:15e-5,completion:6e-4}}getPricingSync(e){const t=this.pricingCache.get(e);if(t)return t;const n=e.toLowerCase();for(const[r,o]of this.pricingCache.entries())if(r.toLowerCase().includes(n)||n.includes(r.toLowerCase()))return o;return this.pricingCache.get(this.DEFAULT_MODEL)||{prompt:15e-5,completion:6e-4}}}class M extends l.BaseCallbackHandler{constructor(e,t){super(),this.name="TokenUsageCallbackHandler",this.tokenUsageHistory=[],this.currentTokenUsage=void 0,this.modelName=e,this.logger=t||new g({module:"TokenUsageTracker",level:"info"})}async handleLLMEnd(e){try{e.llmOutput?.tokenUsage&&(this.currentTokenUsage={promptTokens:e.llmOutput.tokenUsage.promptTokens||0,completionTokens:e.llmOutput.tokenUsage.completionTokens||0,totalTokens:e.llmOutput.tokenUsage.totalTokens||0,modelName:this.modelName,timestamp:new Date},this.tokenUsageHistory.push(this.currentTokenUsage),this.logger.debug("Token usage tracked:",{promptTokens:this.currentTokenUsage.promptTokens,completionTokens:this.currentTokenUsage.completionTokens,totalTokens:this.currentTokenUsage.totalTokens,model:this.modelName}))}catch(t){this.logger.error("Failed to track token usage:",t)}}getLatestTokenUsage(){return this.currentTokenUsage}getTokenUsageHistory(){return[...this.tokenUsageHistory]}getTotalTokenUsage(){return{...this.tokenUsageHistory.reduce((e,t)=>({promptTokens:e.promptTokens+t.promptTokens,completionTokens:e.completionTokens+t.completionTokens,totalTokens:e.totalTokens+t.totalTokens}),{promptTokens:0,completionTokens:0,totalTokens:0}),modelName:this.modelName,timestamp:new Date}}reset(){this.currentTokenUsage=void 0,this.tokenUsageHistory=[]}}function P(e,t){const n=t||e.modelName||R,r=D.getInstance().getPricingSync(n),o=e.promptTokens/1e3*r.prompt,i=e.completionTokens/1e3*r.completion;return{promptCost:o,completionCost:i,totalCost:o+i,currency:"USD"}}class B{async getPublicKey(){if(!this.mirrorNode)throw new Error("AbstractSigner: HederaMirrorNode has not been initialized by the concrete signer implementation. This is an internal error.");const e=this.getAccountId();try{return await this.mirrorNode.getPublicKey(e.toString())}catch(t){const n=t instanceof Error?t.message:String(t);throw new Error(`Failed to retrieve public key from mirror node for account ${e.toString()}: ${n}`)}}initializeMirrorNode(e,t){this.mirrorNode=new K(e,new g({level:"info",module:`${t}-MirrorNode`}))}}var L=(e=>(e.CREATE_TOPIC_CUSTODIAL="createTopicCustodial",e.CREATE_TOPIC_NON_CUSTODIAL="createTopicNonCustodial",e.DELETE_TOPIC_CUSTODIAL="deleteTopicCustodial",e.DELETE_TOPIC_NON_CUSTODIAL="deleteTopicNonCustodial",e.SUBMIT_TOPIC_MESSAGE_CUSTODIAL="submitTopicMessageCustodial",e.SUBMIT_TOPIC_MESSAGE_NON_CUSTODIAL="submitTopicMessageCustodial",e.CREATE_TOKEN_CUSTODIAL="createTokenCustodial",e.CREATE_TOKEN_NON_CUSTODIAL="createTokenNonCustodial",e.ASSOCIATE_TOKEN_CUSTODIAL="associateTokenCustodial",e.ASSOCIATE_TOKEN_NON_CUSTODIAL="associateTokenNonCustodial",e.DISSOCIATE_TOKEN_CUSTODIAL="dissociateTokenCustodial",e.DISSOCIATE_TOKEN_NON_CUSTODIAL="dissociateTokenNonCustodial",e.AIRDROP_TOKEN_CUSTODIAL="airdropTokenCustodial",e.AIRDROP_TOKEN_NON_CUSTODIAL="airdropTokenNonCustodial",e.REJECT_TOKEN_CUSTODIAL="rejectedTokenCustodial",e.REJECT_TOKEN_NON_CUSTODIAL="rejectedTokenNonCustodial",e.MINT_TOKEN_CUSTODIAL="mintTokenCustodial",e.MINT_TOKEN_NON_CUSTODIAL="mintTokenNonCustodial",e.MINT_NFT_TOKEN_CUSTODIAL="mintNFTTokenCustodial",e.MINT_NFT_TOKEN_NON_CUSTODIAL="mintNFTTokenNonCustodial",e.CLAIM_AIRDROP_CUSTODIAL="claimAirdropCustodial",e.CLAIM_AIRDROP_NON_CUSTODIAL="claimAirdropNonCustodial",e.TRANSFER_TOKEN_CUSTODIAL="transferTokenCustodial",e.TRANSFER_TOKEN_NON_CUSTODIAL="transferTokenNonCustodial",e.TRANSFER_HBAR_CUSTODIAL="transferHbarCustodial",e.TRANSFER_HBAR_NON_CUSTODIAL="transferHbarNonCustodial",e.ASSET_ALLOWANCE_CUSTODIAL="assetAllowedCustodial",e.ASSET_ALLOWANCE_NON_CUSTODIAL="assetAllowedNonCustodial",e))(L||{});function _(t){if(!t)return null;try{return m(t).privateKey.publicKey}catch{try{return e.PublicKey.fromString(t)}catch{return null}}}const H=u.z.object({transactionMemo:u.z.string().optional().describe("Optional memo for the Hedera transaction."),transactionId:u.z.string().optional().describe("Optional transaction ID to use (e.g., for pre-generated IDs)."),nodeAccountIds:u.z.array(u.z.string()).optional().describe("Optional specific node account IDs to target for the transaction."),schedule:u.z.boolean().optional().describe("Set to true to schedule the transaction. If true, output will be for a ScheduleCreate transaction."),scheduleMemo:u.z.string().optional().describe("Optional memo for the ScheduleCreate transaction itself."),schedulePayerAccountId:u.z.string().optional().describe("Optional payer account ID for the ScheduleCreate transaction."),scheduleAdminKey:u.z.string().optional().describe("Optional admin key (serialized string) for the ScheduleCreate transaction. Builder parses.")}).optional();class U extends h.StructuredTool{constructor({hederaKit:e,logger:t,...n}){super(n),this.neverScheduleThisTool=!1,this.requiresMultipleTransactions=!1,this.hederaKit=e,this.logger=t||e.logger}get schema(){return this.specificInputSchema.extend({metaOptions:H})}async _applyMetaOptions(e,t,n){await this._substituteKeyFields(n),this._applyTransactionOptions(e,t)}async _substituteKeyFields(e){const t=["adminKey","kycKey","freezeKey","wipeKey","supplyKey","feeScheduleKey","pauseKey"];for(const r of t){if("current_signer"===e[r])try{const t=(await this.hederaKit.signer.getPublicKey()).toStringDer();e[r]=t,this.logger.info(`Substituted ${r} with current signer's public key.`)}catch(n){const e=n;this.logger.error(`Failed to get current signer's public key for ${r} substitution: ${e.message}`,n)}}}_applyTransactionOptions(t,n){if(n){if(n.transactionId)try{t.setTransactionId(e.TransactionId.fromString(n.transactionId))}catch{this.logger.warn(`Invalid transactionId format in metaOptions: ${n.transactionId}, ignoring.`)}if(n.nodeAccountIds&&n.nodeAccountIds.length>0)try{t.setNodeAccountIds(n.nodeAccountIds.map(t=>e.AccountId.fromString(t)))}catch{this.logger.warn("Invalid nodeAccountId format in metaOptions, ignoring.")}n.transactionMemo&&t.setTransactionMemo(n.transactionMemo)}}async _handleAutonomous(e,t,n){const r=this._buildScheduleOptions(t);this.logger.info(`Executing transaction directly (mode: autonomous): ${this.name}`);const o=await e.execute(r);return JSON.stringify({...o,notes:n})}async _handleReturnBytes(e,t,n){if(this.requiresMultipleTransactions){const e=`The ${this.name} tool requires multiple transactions and cannot be used in returnBytes mode. Please use autonomous mode or break down the operation into individual steps.`;return this.logger.warn(e),JSON.stringify({success:!1,error:e,requiresAutonomous:!0,notes:n})}return this._shouldScheduleTransaction(t)?this._handleScheduledTransaction(e,t,n):this._handleUnscheduledTransaction(e,n)}_shouldScheduleTransaction(e){return!this.neverScheduleThisTool&&(e?.schedule??("returnBytes"===this.hederaKit.operationalMode&&this.hederaKit.scheduleUserTransactionsInBytesMode))}async _handleScheduledTransaction(e,t,n){this.logger.info(`Preparing scheduled transaction (mode: returnBytes, schedule: true): ${this.name}`);const r=this._buildScheduleOptions(t,!0);r.schedulePayerAccountId=this.hederaKit.signer.getAccountId();const o=await e.execute(r);if(o.success&&o.scheduleId){const e=t?.transactionMemo||`Scheduled ${this.name} operation.`,r=this.hederaKit.userAccountId?` User (${this.hederaKit.userAccountId}) will be payer of scheduled transaction.`:"";return JSON.stringify({success:!0,op:"schedule_create",scheduleId:o.scheduleId.toString(),description:e+r,payer_account_id_scheduled_tx:this.hederaKit.userAccountId||"unknown",memo_scheduled_tx:t?.transactionMemo,notes:n})}return JSON.stringify({success:!1,error:o.error||"Failed to create schedule and retrieve ID.",notes:n})}async _handleUnscheduledTransaction(e,t){this.logger.info(`Returning transaction bytes (mode: returnBytes, schedule: false): ${this.name}`);const n=await e.getTransactionBytes({});return JSON.stringify({success:!0,transactionBytes:n,transactionId:e.getCurrentTransaction()?.transactionId?.toString(),notes:t})}_buildScheduleOptions(t,n=!1){const r={};if(n||t?.schedule){if(r.schedule=!0,t?.scheduleMemo&&(r.scheduleMemo=t.scheduleMemo),t?.schedulePayerAccountId)try{r.schedulePayerAccountId=e.AccountId.fromString(t.schedulePayerAccountId)}catch{this.logger.warn("Invalid schedulePayerAccountId")}if(t?.scheduleAdminKey)try{const e=_(t.scheduleAdminKey);e&&(r.scheduleAdminKey=e)}catch{this.logger.warn("Invalid scheduleAdminKey")}}return r}getNoteForKey(e,t,n){}async _call(e,t){const n=e.metaOptions,r=this._extractSpecificArgsFromCombinedArgs(e);this.logger.info(`Executing ${this.name} with Zod-parsed specific args (schema defaults applied by LangChain):`,JSON.parse(JSON.stringify(r)),"and metaOptions:",n);const o=[];if(this.specificInputSchema&&this.specificInputSchema.shape)for(const a in this.specificInputSchema.shape)if(Object.prototype.hasOwnProperty.call(this.specificInputSchema.shape,a)){const e=this.specificInputSchema.shape[a];if(e._def&&"ZodDefault"===e._def.typeName){const t=e._def.defaultValue();let n=t;if("function"==typeof t)try{n=t()}catch(i){this.logger.warn(`Could not execute default value function for key ${a}. Error: ${i.message}`),n="[dynamic schema default]"}const s=r[a];let c;this.getNoteForKey&&(c=this.getNoteForKey(a,n,s)),c||(c=`For the parameter '${a}', the value '${JSON.stringify(s)}' was used. This field has a tool schema default of '${JSON.stringify(n)}'.`),o.push(c)}}this.logger.debug("Zod Schema Default Info Notes:",o);try{const e=this.getServiceBuilder();e.clearNotes(),await this.callBuilderMethod(e,r,t),await this._applyMetaOptions(e,n,r);const i=e.getNotes();this.logger.debug("Builder Applied Default Notes:",i);const s=[...o,...i];return this.logger.debug("All Notes combined:",s),"autonomous"===this.hederaKit.operationalMode?this._handleAutonomous(e,n,s):this._handleReturnBytes(e,n,s)}catch(s){const e=this.getServiceBuilder(),t=e?e.getNotes():[],n=[...o,...t];return this._handleError(s,n)}}_extractSpecificArgsFromCombinedArgs(e){const t={};if(this.specificInputSchema&&this.specificInputSchema.shape)for(const n in this.specificInputSchema.shape)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}_handleError(e,t){const n=e instanceof Error?e.message:JSON.stringify(e);return this.logger.error(`Error in ${this.name}: ${n}`,e),JSON.stringify({success:!1,error:n,notes:t||[]})}}const j=u.z.object({key:u.z.string().optional().describe("Optional. Public key string (hex) or private key string for the new account. Used if alias is not set. Builder validates presence of key or alias."),alias:u.z.string().optional().describe("Optional. Account alias (e.g., EVM address or serialized PublicKey string). Takes precedence over key. Builder validates presence of key or alias."),initialBalance:u.z.union([u.z.number(),u.z.string()]).optional().describe("Optional. Initial balance in HBAR. Builder handles conversion. Defaults to 0."),memo:u.z.string().optional().describe("Optional. Memo for the account."),autoRenewAccountId:u.z.string().optional().describe('Optional. Account ID for auto-renewal payments (e.g., "0.0.xxxx").'),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. Auto-renewal period in seconds (e.g., 7776000 for 90 days)."),receiverSignatureRequired:u.z.boolean().optional().describe("Optional. If true, account must sign transfers out of it."),maxAutomaticTokenAssociations:u.z.number().int().optional().describe("Optional. Max automatic token associations for the account."),stakedAccountId:u.z.string().optional().describe('Optional. Account ID to stake to (e.g., "0.0.zzzz").'),stakedNodeId:u.z.number().int().optional().describe("Optional. Node ID to stake to. Builder handles Long conversion."),declineStakingReward:u.z.boolean().optional().describe("Optional. If true, decline staking rewards.")});class q extends U{constructor(e){super(e),this.name="hedera-account-create",this.description="Creates a new Hedera account. Requires key or alias (builder validates). Builder handles parsing and defaults.",this.specificInputSchema=j,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.createAccount(t)}}const G=u.z.object({accountId:u.z.string().describe('Account ID for the transfer (e.g., "0.0.xxxx").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("HBAR amount. Positive for credit, negative for debit. Builder handles Hbar unit & sum validation.")}),W=u.z.object({transfers:u.z.array(G).min(1).describe("Array of HBAR transfers, each with accountId and amount in HBARs."),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class Y extends U{constructor(e){super(e),this.name="hedera-account-transfer-hbar",this.description="Transfers HBAR between accounts. Builder validates amounts and sum.",this.specificInputSchema=W,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.transferHbar(t)}}const J=u.z.object({accountIdToUpdate:u.z.string().describe('The ID of the account to update (e.g., "0.0.12345").'),key:u.z.string().nullable().optional().describe("Optional. New key (serialized string). Pass null to clear (if allowed by SDK). Builder handles parsing."),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. New auto-renewal period in seconds (e.g., 7776000 for 90 days)."),memo:u.z.string().nullable().optional().describe("Optional. New memo. Pass null or empty string to clear."),maxAutomaticTokenAssociations:u.z.number().int().min(0).optional().describe("Optional. New max automatic token associations (0-5000)."),stakedAccountId:u.z.string().nullable().optional().describe('Optional. New account ID to stake to. Pass "0.0.0" or null to clear.'),stakedNodeId:u.z.number().int().nullable().optional().describe("Optional. New node ID to stake to. Pass -1 or null to clear. Builder handles Long conversion."),declineStakingReward:u.z.boolean().optional().describe("Optional. If true, account declines staking rewards."),receiverSignatureRequired:u.z.boolean().optional().describe("Optional. If true, account must sign transfers out of it.")});class Q extends U{constructor(e){super(e),this.name="hedera-account-update",this.description="Updates an existing Hedera account. Specify accountIdToUpdate and fields to change. Builder handles parsing and clearing logic.",this.specificInputSchema=J,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.updateAccount(t)}}const V=u.z.object({deleteAccountId:u.z.string().describe('The ID of the account to be deleted (e.g., "0.0.xxxx"). This account must sign.'),transferAccountId:u.z.string().describe('The ID of the account to transfer the remaining HBAR balance to (e.g., "0.0.yyyy").')});class X extends U{constructor(e){super(e),this.name="hedera-account-delete",this.description="Deletes an account, transferring its HBAR balance to another account.",this.specificInputSchema=V,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.deleteAccount(t)}}const Z=u.z.object({ownerAccountId:u.z.string().optional().describe('Optional. The HBAR owner account ID (e.g., "0.0.xxxx"). Defaults to operator if not provided.'),spenderAccountId:u.z.string().describe('The spender account ID being granted the allowance (e.g., "0.0.yyyy").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("Max HBAR amount spender can use (in HBARs). Builder handles Hbar object creation."),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class ee extends U{constructor(e){super(e),this.name="hedera-account-approve-hbar-allowance",this.description="Approves an HBAR allowance for a spender. Builder handles Hbar unit conversion.",this.specificInputSchema=Z,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.approveHbarAllowance(t)}}const te=u.z.object({ownerAccountId:u.z.string().optional().describe('Optional. The token owner account ID (e.g., "0.0.xxxx"). Defaults to operator.'),spenderAccountId:u.z.string().describe('The spender account ID (e.g., "0.0.yyyy").'),tokenId:u.z.string().describe('The fungible token ID (e.g., "0.0.zzzz").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("Max token amount (smallest unit) spender can use. Builder handles conversion."),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class ne extends U{constructor(e){super(e),this.name="hedera-account-approve-fungible-token-allowance",this.description="Approves a fungible token allowance for a spender. Builder handles amount conversion.",this.specificInputSchema=te,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.approveFungibleTokenAllowance(t)}}const re=u.z.object({ownerAccountId:u.z.string().optional().describe('Optional. The NFT owner account ID (e.g., "0.0.xxxx"). Defaults to operator.'),spenderAccountId:u.z.string().describe('The spender account ID (e.g., "0.0.yyyy").'),tokenId:u.z.string().describe('The NFT collection ID (e.g., "0.0.zzzz").'),serials:u.z.array(u.z.union([u.z.number().int().positive(),u.z.string()])).optional().describe("Optional. Specific serial numbers to approve. Use this OR allSerials. Builder handles conversion."),allSerials:u.z.boolean().optional().describe("Optional. If true, approves spender for all serials of the NFT ID. Use this OR serials."),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class oe extends U{constructor(e){super(e),this.name="hedera-account-approve-nft-allowance",this.description="Approves an NFT allowance. Builder validates serials/allSerials logic and handles serial conversion.",this.specificInputSchema=re,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.approveTokenNftAllowance(t)}}const ie=u.z.object({ownerAccountId:u.z.string().optional().describe('Optional. The HBAR owner account ID (e.g., "0.0.xxxx"). Defaults to operator.'),spenderAccountId:u.z.string().describe('The spender account ID whose HBAR allowance is to be revoked (e.g., "0.0.yyyy").'),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class se extends U{constructor(e){super(e),this.name="hedera-account-revoke-hbar-allowance",this.description="Revokes/clears an HBAR allowance for a specific spender by approving zero HBAR.",this.specificInputSchema=ie,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.revokeHbarAllowance(t)}}const ae=u.z.object({ownerAccountId:u.z.string().optional().describe('Optional. The token owner account ID (e.g., "0.0.xxxx"). Defaults to operator.'),spenderAccountId:u.z.string().describe('The spender account ID whose token allowance is to be revoked (e.g., "0.0.yyyy").'),tokenId:u.z.string().describe('The ID of the fungible token (e.g., "0.0.zzzz").'),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class ce extends U{constructor(e){super(e),this.name="hedera-account-revoke-fungible-token-allowance",this.description="Revokes/clears a fungible token allowance for a specific spender by approving zero amount.",this.specificInputSchema=ae,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.revokeFungibleTokenAllowance(t)}}const le=u.z.object({ownerAccountId:u.z.string().optional().describe("Optional. The ID of the NFT owner. Defaults to the operator/signer if not provided."),spenderAccountId:u.z.string().describe("The ID of the spender whose allowance for specific NFTs will be deleted."),nftIdString:u.z.string().describe('The NFT ID including serial number (e.g., "0.0.token.serial") for which the allowance will be deleted.'),tokenId:u.z.string().describe('The token ID of the NFT collection (e.g., "0.0.xxxx").'),serials:u.z.array(u.z.union([u.z.number().int().positive(),u.z.string()])).min(1).describe("An array of serial numbers of the NFT to remove allowance for.")});class de extends U{constructor(e){super(e),this.name="hedera-account-delete-nft-spender-allowance",this.description="Deletes/revokes NFT allowances for specific serial numbers of a token for a specific spender. The owner of the NFTs must sign.",this.specificInputSchema=le,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.deleteTokenNftAllowanceForSpender(t)}}const ue=u.z.object({ownerAccountId:u.z.string().optional().describe("Optional. The ID of the NFT owner. Defaults to the operator/signer if not provided."),nftIdString:u.z.string().describe('The specific NFT ID including serial number (e.g., "0.0.token.serial") for which all spender allowances will be deleted.'),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class he extends U{constructor(e){super(e),this.name="hedera-account-delete-nft-serial-allowances-for-all-spenders",this.description="Deletes all allowances for a specific NFT serial (for all spenders), granted by an owner. This action must be signed by the NFT owner.",this.specificInputSchema=ue,this.namespace="account"}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){await e.deleteNftSerialAllowancesForAllSpenders(t)}}const pe={[C.SMALL]:{maxTokens:4e3,summarizeArrays:!0,maxArrayLength:3,includeMetadata:!0},[C.MEDIUM]:{maxTokens:12e3,summarizeArrays:!1,maxArrayLength:10,includeMetadata:!0},[C.LARGE]:{maxTokens:32e3,summarizeArrays:!1,maxArrayLength:50,includeMetadata:!1},[C.UNLIMITED]:{maxTokens:1/0,summarizeArrays:!1,includeMetadata:!1}};class ge extends h.StructuredTool{constructor({hederaKit:e,logger:t,modelCapability:n=C.MEDIUM,customStrategy:r,...o}){super(o),this.notes=[],this.hederaKit=e,this.logger=t||e.logger,this.modelCapability=n;const i=pe[n];this.responseStrategy={...i,...r},this.logger.debug(`Initialized query tool with ${n} capability strategy`)}get schema(){return this.specificInputSchema}estimateTokens(e){return Math.ceil(e.length/4)}matchesPattern(e,t){if(t===e)return!0;if(t.includes("*")){return new RegExp("^"+t.replace(/\*/g,"[^.]*")+"$").test(e)}return!1}processData(e,t,n=""){if(this.responseStrategy.maxTokens===1/0)return e;const r=this.getLargeFieldProcessors?this.getLargeFieldProcessors(t):{};return null==e?e:Array.isArray(e)?this.processArray(e,t,n):"object"!=typeof e||null===e||Array.isArray(e)?"string"==typeof e?this.processString(e,n,r):e:this.processObject(e,t,n,r)}processArray(e,t,n){const r=e.map((e,r)=>this.processData(e,t,`${n}[${r}]`));if(this.responseStrategy.summarizeArrays&&this.responseStrategy.maxArrayLength&&e.length>this.responseStrategy.maxArrayLength){const t=this.responseStrategy.maxArrayLength,o=Math.floor(t/2),i=t-o-1;return[...r.slice(0,o),{_summary:`[${e.length-t} items truncated]`,_originalLength:e.length,_truncatedAt:n},...r.slice(-i)]}return r}processObject(e,t,n,r){const o={};for(const[i,s]of Object.entries(e)){const e=n?`${n}.${i}`:i,a=Object.entries(r).find(([t])=>this.matchesPattern(e,t)),c=a?a[1]:void 0;c&&c.exclude||(o[i]=this.processData(s,t,e))}return o}processString(e,t,n){const r=Object.entries(n).find(([e])=>this.matchesPattern(t,e)),o=r?r[1]:void 0;if(o&&o.maxLength&&e.length>o.maxLength){return`${e.substring(0,o.maxLength)}...${o.truncateMessage?o.truncateMessage:`[TRUNCATED: ${e.length} chars total]`}`}return e}formatResult(e,t){if("string"==typeof e)return e;let n=e;this.processCustomResponse&&t&&(n=this.processCustomResponse(n,t)),n=this.processData(n,t||{});const r=JSON.stringify(n,null,2),o=this.estimateTokens(r);if(this.responseStrategy.includeMetadata&&o>.8*this.responseStrategy.maxTokens){const e={..."object"==typeof n&&null!==n?n:{data:n},_meta:{estimatedTokens:o,maxTokens:this.responseStrategy.maxTokens,capability:Object.keys(pe).find(e=>pe[e]===this.responseStrategy),note:"Response may be truncated. Use higher model capability for full data."}};return JSON.stringify(e,null,2)}return r}handleError(e){const t=e instanceof Error?e.message:JSON.stringify(e);return this.logger.error(`Error in query tool: ${t}`,e),JSON.stringify({success:!1,error:t})}async _call(e,t){this.clearNotes();try{this.logger.info(`Executing ${this.name} with model capability: ${this.modelCapability}`);const n=await this.executeQuery(e,t),r=await this.processLargeFields(n,e),o=this.getNotes();if("object"==typeof r.data&&null!==r.data&&"success"in r.data){const e=r.data,t={...e,...o.length>0&&{notes:[...e.notes||[],...o]}};return JSON.stringify(t)}const i={success:!0,data:r.data,...o.length>0&&{notes:o}};return JSON.stringify(i)}catch(n){const e=n instanceof Error?n.message:String(n);this.logger.error(`Error in ${this.name}: ${e}`,n);const t=this.getNotes();return JSON.stringify({success:!1,error:e,...t.length>0&&{notes:t}})}}async getModelCapabilityLimits(){if(this.modelCapability===C.UNLIMITED)return{maxTokens:1/0,arrayLimit:1/0};try{const e=E.getInstance();if(this.hederaKit.modelName){const t=await e.getContextWindow(this.hederaKit.modelName);if(t>0){const e=Math.floor(.6*t),n=t-e-Math.floor(.2*t),r=this.calculateArrayLimit(n);return{maxTokens:Math.max(n,1e3),arrayLimit:r}}}const t=await e.getAllModels();let n=0;for(const[,r]of Object.entries(t))r.capability===this.modelCapability&&r.contextWindow>n&&(n=r.contextWindow);if(n>0){const e=Math.floor(.6*n),t=n-e-Math.floor(.2*n),r=this.calculateArrayLimit(t);return{maxTokens:Math.max(t,1e3),arrayLimit:r}}}catch(e){this.logger.warn("Failed to get model context window, using fallback limits",e)}switch(this.modelCapability){case C.SMALL:return{maxTokens:1e3,arrayLimit:3};case C.MEDIUM:return{maxTokens:4e3,arrayLimit:10};case C.LARGE:return{maxTokens:12e3,arrayLimit:30};default:return{maxTokens:4e3,arrayLimit:10}}}calculateArrayLimit(e){return e<8e3?5:e<5e4?20:e<1e5?50:100}addNote(e){this.notes.push(e)}clearNotes(){this.notes=[]}getNotes(){return[...this.notes]}async processLargeFields(e,t){const n={data:JSON.parse(JSON.stringify(e)),notes:[]};if(this.modelCapability===C.UNLIMITED)return n;const r=this.getLargeFieldProcessors&&t?this.getLargeFieldProcessors(t):{},o=await this.getModelCapabilityLimits();for(const[i,s]of Object.entries(r)){const e=this.getNestedValue(n.data,i);if("string"==typeof e&&s.maxLength&&e.length>s.maxLength){const t=e.substring(0,s.maxLength);this.setNestedValue(n.data,i,t);const r=s.truncateMessage?s.truncateMessage:"Large data field was shortened to fit your model's capacity";this.addNote(`${r}. Original size: ${e.length} characters, shown: ${s.maxLength} characters.`)}}return n.data=this.processDataStructure(n.data,o,n.notes),n}processDataStructure(e,t,n){if(Array.isArray(e)){if(e.length>t.arrayLimit){const r=e.slice(0,t.arrayLimit);return this.addNote(`List was shortened to fit your model's capacity. Showing ${t.arrayLimit} of ${e.length} items.`),r.map(e=>this.processDataStructure(e,t,n))}return e.map(e=>this.processDataStructure(e,t,n))}if(e&&"object"==typeof e&&!Array.isArray(e)){const r={};for(const[o,i]of Object.entries(e))r[o]=this.processDataStructure(i,t,n);return r}return e}getNestedValue(e,t){return t.split(".").reduce((e,t)=>{if(!e||"object"!=typeof e)return;const n=e;if(t.includes("[")&&t.includes("]")){const[e,r]=t.split("["),o=parseInt(r.replace("]","")),i=n[e];return Array.isArray(i)?i[o]:void 0}return n[t]},e)}setNestedValue(e,t,n){if(!e||"object"!=typeof e)return;const r=t.split("."),o=r.pop(),i=r.reduce((e,t)=>{if(!e||"object"!=typeof e)return e;const n=e;if(t.includes("[")&&t.includes("]")){const[e,r]=t.split("["),o=parseInt(r.replace("]","")),i=n[e];return Array.isArray(i)?i[o]:void 0}return n[t]},e);if(!i||"object"!=typeof i)return;const s=i;if(o.includes("[")&&o.includes("]")){const[e,t]=o.split("["),r=parseInt(t.replace("]","")),i=s[e];Array.isArray(i)&&(i[r]=n)}else s[o]=n}}const me=u.z.object({accountId:u.z.string().describe('The account ID that sent the airdrops (e.g., "0.0.123")'),limit:u.z.number().optional().describe("Maximum number of airdrops to return"),order:u.z.enum(["asc","desc"]).optional().describe("Order of results"),receiverId:u.z.string().optional().describe("Filter by receiver account ID"),serialNumber:u.z.string().optional().describe("Filter by NFT serial number"),tokenId:u.z.string().optional().describe("Filter by token ID")});class fe extends ge{constructor(e){super(e),this.name="hedera-get-outstanding-airdrops",this.description="Retrieves outstanding token airdrops that have been sent by an account but not yet claimed.",this.specificInputSchema=me,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting outstanding airdrops for account: ${e.accountId}`);const t=await this.hederaKit.query().getOutstandingTokenAirdrops(e);return null===t?{success:!1,error:`Could not retrieve outstanding airdrops for account ${e.accountId}`}:{success:!0,accountId:e.accountId,airdrops:t,count:t.length}}}const ye=u.z.object({accountId:u.z.string().describe('The account ID that received the airdrops (e.g., "0.0.123")'),limit:u.z.number().optional().describe("Maximum number of airdrops to return"),order:u.z.enum(["asc","desc"]).optional().describe("Order of results"),senderId:u.z.string().optional().describe("Filter by sender account ID"),serialNumber:u.z.string().optional().describe("Filter by NFT serial number"),tokenId:u.z.string().optional().describe("Filter by token ID")});class be extends ge{constructor(e){super(e),this.name="hedera-get-pending-airdrops",this.description="Retrieves pending token airdrops that have been received by an account but not yet claimed.",this.specificInputSchema=ye,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting pending airdrops for account: ${e.accountId}`);const t=await this.hederaKit.query().getPendingTokenAirdrops(e);return t?{success:!0,accountId:e.accountId,airdrops:t,count:t.length}:{success:!1,error:`Could not retrieve pending airdrops for account ${e.accountId}`}}}const Ie=u.z.object({accountId:u.z.string().describe('The account ID to get balance for (e.g., "0.0.12345")')});class ke extends ge{constructor(e){super(e),this.name="hedera-get-account-balance",this.description="Retrieves the HBAR balance for a Hedera account. Returns the balance in HBAR (not tinybars).",this.specificInputSchema=Ie,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting balance for account ID: ${e.accountId}`);const t=await this.hederaKit.query().getAccountBalance(e.accountId);return null===t?{success:!1,error:`Could not retrieve balance for account ${e.accountId}`}:{success:!0,accountId:e.accountId,balance:t,unit:"HBAR"}}}const Te=u.z.object({accountId:u.z.string().describe('The account ID to get information for (e.g., "0.0.12345")')});class we extends ge{constructor(e){super(e),this.name="hedera-get-account-info",this.description="Retrieves comprehensive information about a Hedera account including balance, key, memo, and other metadata.",this.specificInputSchema=Te,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting account info for account ID: ${e.accountId}`);const t=await this.hederaKit.query().getAccountInfo(e.accountId);return t?{success:!0,accountInfo:t}:{success:!1,error:`Account ${e.accountId} not found`}}}const Ae=u.z.object({accountId:u.z.string().describe('The account ID to get NFTs for (e.g., "0.0.12345")'),tokenId:u.z.string().optional().describe('Optional token ID to filter NFTs by (e.g., "0.0.67890")'),limit:u.z.number().int().positive().optional().default(100).describe("Maximum number of NFTs to return (default: 100)")});class Se extends ge{constructor(e){super(e),this.name="hedera-get-account-nfts",this.description="Retrieves all NFTs owned by a Hedera account. Optionally filter by token ID.",this.specificInputSchema=Ae,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting NFTs for account ID: ${e.accountId}`);const t=await this.hederaKit.query().getAccountNfts(e.accountId,e.tokenId,e.limit);return t?{success:!0,accountId:e.accountId,tokenId:e.tokenId,nftCount:t.length,nfts:t}:{success:!1,error:`Could not retrieve NFTs for account ${e.accountId}`}}}const xe=u.z.object({accountId:u.z.string().describe('The account ID to get the public key for (e.g., "0.0.12345")')});class Ne extends ge{constructor(e){super(e),this.name="hedera-get-account-public-key",this.description="Retrieves the public key for a Hedera account. Returns the public key in string format.",this.specificInputSchema=xe,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting public key for account ID: ${e.accountId}`);const t=await this.hederaKit.query().getPublicKey(e.accountId);return t?{success:!0,accountId:e.accountId,publicKey:t.toString(),publicKeyDer:t.toStringDer(),publicKeyRaw:t.toStringRaw()}:{success:!1,error:`Could not retrieve public key for account ${e.accountId}`}}}const ve=u.z.object({accountId:u.z.string().describe('The account ID to get token balances for (e.g., "0.0.12345")'),limit:u.z.number().int().positive().optional().default(100).describe("Maximum number of tokens to return (default: 100)")});class ze extends ge{constructor(e){super(e),this.name="hedera-get-account-tokens",this.description="Retrieves all token balances for a Hedera account. Returns fungible and non-fungible token associations.",this.specificInputSchema=ve,this.namespace="account"}async executeQuery(e){this.logger.info(`Getting tokens for account ID: ${e.accountId}`);const t=await this.hederaKit.query().getAccountTokens(e.accountId,e.limit);return t?{success:!0,accountId:e.accountId,tokenCount:t.length,tokens:t}:{success:!1,error:`Could not retrieve tokens for account ${e.accountId}`}}}const Ce=u.z.object({scheduleId:u.z.string().describe('The ID of the scheduled transaction (e.g., "0.0.SCHEDID").'),memo:u.z.string().optional().describe("Optional memo for the ScheduleSign transaction itself.")});class Ke extends U{constructor(e){super(e),this.name="hedera-sign-and-execute-scheduled-transaction",this.description="Prepares a ScheduleSignTransaction to add a signature to an existing scheduled transaction. Depending on agent configuration, this will either return transaction bytes (for the user to sign and pay) or be executed directly by the agent (agent signs and pays).",this.specificInputSchema=Ce,this.namespace="account",this.neverScheduleThisTool=!0}getServiceBuilder(){return this.hederaKit.accounts()}async callBuilderMethod(e,t){const n=e,r={scheduleId:t.scheduleId};t.memo&&""!==t.memo.trim()&&(r.memo=t.memo),await n.prepareSignScheduledTransaction(r)}}const Oe=u.z.object({feeCollectorAccountId:u.z.string().describe("The account ID to receive the custom fee."),denominatingTokenId:u.z.string().optional().describe("The token ID for fee denomination (if not HBAR)."),amount:u.z.union([u.z.number(),u.z.string()]).describe("The fee amount (smallest unit for tokens, or tinybars for HBAR).")}),Fe=u.z.object({memo:u.z.string().optional().describe("Optional. Memo for the topic."),adminKey:u.z.string().optional().describe("Optional. Admin key for the topic (e.g., serialized public key string, or private key string for derivation by builder)."),submitKey:u.z.string().optional().describe("Optional. Submit key for the topic (e.g., serialized public key string, or private key string for derivation by builder)."),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. Auto-renewal period in seconds (e.g., 7776000 for 90 days)."),autoRenewAccountId:u.z.string().optional().describe('Optional. Account ID for auto-renewal payments (e.g., "0.0.xxxx").'),feeScheduleKey:u.z.string().optional().describe("Optional. Fee schedule key for the topic (e.g., serialized public key string, or private key string for derivation by builder)."),customFees:u.z.array(Oe).optional().describe("Optional. Array of custom fee objects to be applied to the topic."),exemptAccountIds:u.z.array(u.z.string()).optional().describe("Optional. Account IDs exempt from custom fees.")});class $e extends U{constructor(e){super(e),this.name="hedera-hcs-create-topic",this.description="Creates a new Hedera Consensus Service (HCS) topic. Provide parameters as needed. The builder handles defaults and key parsing.",this.specificInputSchema=Fe,this.namespace="hcs",this.neverScheduleThisTool=!0}getServiceBuilder(){return this.hederaKit.hcs()}async callBuilderMethod(e,t){await e.createTopic(t)}}const Ee=u.z.object({topicId:u.z.string().describe('The ID of the topic (e.g., "0.0.xxxx").'),message:u.z.string().describe("The message content. For binary data, provide as a base64 encoded string; the builder handles decoding."),maxChunks:u.z.number().int().positive().optional().describe("Optional. Maximum number of chunks for messages exceeding single transaction limits. Builder handles chunking."),chunkSize:u.z.number().int().positive().optional().describe("Optional. Size of each chunk in bytes if chunking is performed. Builder applies default if needed."),submitKey:u.z.string().optional().describe("Optional. Submit key if required by the topic and different from the operator (e.g., serialized public key string, or private key string for derivation by builder).")});class Re extends U{constructor(e){super(e),this.name="hedera-hcs-submit-message",this.description="Submits a message to a Hedera Consensus Service (HCS) topic. The builder handles chunking and base64 decoding for binary messages.",this.specificInputSchema=Ee,this.namespace="hcs"}getServiceBuilder(){return this.hederaKit.hcs()}async callBuilderMethod(e,t){await e.submitMessageToTopic(t)}}const De=u.z.object({topicId:u.z.string().describe('The ID of the topic to be deleted (e.g., "0.0.xxxx").')});class Me extends U{constructor(e){super(e),this.name="hedera-hcs-delete-topic",this.description="Deletes an HCS topic. Requires topicId.",this.specificInputSchema=De,this.namespace="hcs"}getServiceBuilder(){return this.hederaKit.hcs()}async callBuilderMethod(e,t){await e.deleteTopic(t)}}const Pe=u.z.object({topicId:u.z.string().describe('The ID of the topic to update (e.g., "0.0.xxxx").'),memo:u.z.string().nullable().optional().describe("Optional. New memo for the topic. Pass null to clear."),adminKey:u.z.string().nullable().optional().describe("Optional. New admin key (serialized string). Pass null to clear."),submitKey:u.z.string().nullable().optional().describe("Optional. New submit key (serialized string). Pass null to clear."),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. New auto-renewal period in seconds."),autoRenewAccountId:u.z.string().nullable().optional().describe("Optional. New auto-renew account ID. Pass null to clear."),feeScheduleKey:u.z.string().nullable().optional().describe("Optional. New fee schedule key (serialized string). Pass null to clear."),exemptAccountIds:u.z.array(u.z.string()).optional().describe("Optional. New list of exempt account IDs. An empty array clears all exemptions.")});class Be extends U{constructor(e){super(e),this.name="hedera-hcs-update-topic",this.description="Updates an HCS topic. Requires topicId. Other fields are optional. Null can be used to clear certain fields.",this.specificInputSchema=Pe,this.namespace="hcs"}getServiceBuilder(){return this.hederaKit.hcs()}async callBuilderMethod(e,t){await e.updateTopic(t)}}const Le=u.z.object({topicId:u.z.string().describe('The topic ID to get messages for (e.g., "0.0.12345")'),sequenceNumber:u.z.string().optional().describe('Filter by sequence number (e.g., "gt:10", "lte:20")'),startTime:u.z.string().optional().describe('Filter by start consensus timestamp (e.g., "1629400000.000000000")'),endTime:u.z.string().optional().describe('Filter by end consensus timestamp (e.g., "1629500000.000000000")'),limit:u.z.number().int().positive().optional().describe("Maximum number of messages to return"),order:u.z.enum(["asc","desc"]).optional().describe("Order of messages (ascending or descending)")});class _e extends ge{constructor(e){super(e),this.name="hedera-get-topic-messages-by-filter",this.description="Retrieves filtered messages from a Hedera Consensus Service topic with optional filters for sequence number, time range, limit, and order.",this.specificInputSchema=Le,this.namespace="hcs"}async executeQuery(e){this.logger.info(`Getting filtered messages for topic ID: ${e.topicId}`);const t={};e.sequenceNumber&&(t.sequenceNumber=e.sequenceNumber),e.startTime&&(t.startTime=e.startTime),e.endTime&&(t.endTime=e.endTime),e.limit&&(t.limit=e.limit),e.order&&(t.order=e.order);const n=await this.hederaKit.query().getTopicMessagesByFilter(e.topicId,t);return n?{success:!0,topicId:e.topicId,messageCount:n.length,filters:t,messages:n}:{success:!1,error:`Could not retrieve messages for topic ${e.topicId}`}}}const He=u.z.object({topicId:u.z.string().describe('The topic ID to get information for (e.g., "0.0.12345")')});class Ue extends ge{constructor(e){super(e),this.name="hedera-get-topic-info",this.description="Retrieves information about a Hedera Consensus Service topic including admin key, submit key, memo, and other metadata.",this.specificInputSchema=He,this.namespace="hcs"}async executeQuery(e){this.logger.info(`Getting topic info for topic ID: ${e.topicId}`);const t=await this.hederaKit.query().getTopicInfo(e.topicId);return t?{success:!0,topicInfo:t}:{success:!1,error:`Topic ${e.topicId} not found`}}}const je=u.z.object({topicId:u.z.string().describe('The topic ID to get custom fees for (e.g., "0.0.12345")')});class qe extends ge{constructor(e){super(e),this.name="hedera-get-topic-fees",this.description="Retrieves custom fees associated with a Hedera Consensus Service topic.",this.specificInputSchema=je,this.namespace="hcs"}async executeQuery(e){this.logger.info(`Getting custom fees for topic ID: ${e.topicId}`);const t=await this.hederaKit.query().getTopicFees(e.topicId);return t?{success:!0,topicId:e.topicId,customFees:t}:{success:!0,topicId:e.topicId,customFees:null,message:"No custom fees found for this topic"}}}const Ge=u.z.object({accountId:u.z.string().describe('Recipient account ID (e.g., "0.0.xxxx").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("Amount in smallest unit. Builder handles Long conversion.")}),We=u.z.object({tokenId:u.z.string().describe('The ID of the fungible token to airdrop (e.g., "0.0.yyyy").'),recipients:u.z.array(Ge).min(1).describe("Array of recipient objects, each with accountId and amount."),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class Ye extends U{constructor(e){super(e),this.name="hedera-hts-airdrop-token",this.description="Airdrops fungible tokens to multiple recipients. Builder handles parsing and validation.",this.specificInputSchema=We,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.airdropToken(t)}}const Je=u.z.object({accountId:u.z.string().describe('The account ID to associate tokens with (e.g., "0.0.xxxx").'),tokenIds:u.z.array(u.z.string().describe('A token ID (e.g., "0.0.yyyy").')).min(1).describe("An array of one or more token IDs to associate.")});class Qe extends U{constructor(e){super(e),this.name="hedera-hts-associate-tokens",this.description="Associates one or more Hedera tokens with an account.",this.specificInputSchema=Je,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.associateTokens(t)}}const Ve=u.z.object({tokenId:u.z.string().describe('The ID of the fungible token (e.g., "0.0.xxxx").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("Amount to burn (smallest unit). Number or string for large values. Builder handles conversion.")});class Xe extends U{constructor(e){super(e),this.name="hedera-hts-burn-fungible-token",this.description="Burns fungible tokens. Requires tokenId and amount.",this.specificInputSchema=Ve,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.burnFungibleToken(t)}}const Ze=u.z.object({tokenId:u.z.string().describe('The ID of the NFT collection (e.g., "0.0.xxxx").'),serials:u.z.array(u.z.union([u.z.number().int().positive(),u.z.string()])).min(1).describe("Array of serial numbers to burn. Numbers or strings for large serials. Builder handles conversion.")});class et extends U{constructor(e){super(e),this.name="hedera-hts-burn-nft",this.description="Burns Non-Fungible Tokens (NFTs). Requires token ID and an array of serial numbers.",this.specificInputSchema=Ze,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.burnNonFungibleToken(t)}}const tt=u.z.object({pendingAirdrops:u.z.array(u.z.object({senderAccountId:u.z.string().describe("The account ID of the sender of the airdrop."),tokenId:u.z.string().describe("The token ID of the airdropped token."),serialNumber:u.z.union([u.z.number(),u.z.string()]).describe("The serial number for an NFT, or a string/number convertible to Long(0) for fungible token claims (representing the whole pending amount for that FT from that sender).")})).min(1).max(10).describe("An array of pending airdrops to claim. Each object must have senderAccountId, tokenId, and serialNumber. Max 10 entries.")});class nt extends U{constructor(e){super(e),this.name="hedera-hts-claim-airdrop",this.description="Claims pending airdropped tokens (fungible or NFT serials). Requires an array of airdrop objects, each specifying senderAccountId, tokenId, and serialNumber. Use metaOptions for execution control.",this.specificInputSchema=tt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(t,n){const r={pendingAirdropIds:n.pendingAirdrops.map((t,n)=>{const r=n+1;let o;if("string"==typeof t.serialNumber)try{o=e.Long.fromString(t.serialNumber)}catch(i){const e=i;throw new Error(`Pending airdrop item #${r} serialNumber string ('${t.serialNumber}') is not a valid Long: ${e.message}`)}else o=e.Long.fromNumber(t.serialNumber);try{const n=e.AccountId.fromString(t.senderAccountId),r=e.TokenId.fromString(t.tokenId);return new e.PendingAirdropId({senderId:n,tokenId:r,nftId:e.NftId.fromString(o.toString())})}catch(i){const e=i;throw new Error(`Error constructing PendingAirdropId for item #${r} (sender: ${t.senderAccountId}, token: ${t.tokenId}, serial: ${t.serialNumber}): ${e.message}`)}})};t.claimAirdrop(r)}}const rt="serialized string). Builder handles parsing.",ot="Fee collector's account ID. Defaults to user's account if in user-centric context and not specified.";const it=u.z.object({type:u.z.enum(["FIXED","FIXED_FEE"]),feeCollectorAccountId:u.z.string().optional().describe(ot),denominatingTokenId:u.z.string().optional().describe("Denominating token ID for the fee (if not HBAR)."),amount:u.z.union([u.z.number(),u.z.string()]).describe("Fee amount (smallest unit for tokens, or tinybars for HBAR).")}),st=u.z.object({type:u.z.enum(["FRACTIONAL","FRACTIONAL_FEE"]),feeCollectorAccountId:u.z.string().optional().describe(ot),numerator:u.z.number().int().describe("Numerator of the fractional fee."),denominator:u.z.number().int().positive().describe("Denominator of the fractional fee."),minAmount:u.z.union([u.z.number(),u.z.string()]).optional().describe("Minimum fractional fee amount."),maxAmount:u.z.union([u.z.number(),u.z.string()]).optional().describe("Maximum fractional fee amount (0 for no max)."),assessmentMethodInclusive:u.z.boolean().optional().describe("Fee is assessed on net amount (false) or gross (true).")}),at=u.z.object({type:u.z.enum(["ROYALTY","ROYALTY_FEE"]),feeCollectorAccountId:u.z.string().optional().describe(ot),numerator:u.z.number().int().describe("Numerator of the royalty fee."),denominator:u.z.number().int().positive().describe("Denominator of the royalty fee."),fallbackFee:it.omit({type:!0}).optional().describe("Fallback fixed fee if royalty is not applicable.")}),ct=u.z.discriminatedUnion("type",[it,st,at]),lt=u.z.object({tokenName:u.z.string().describe("The publicly visible name of the token."),tokenSymbol:u.z.string().optional().describe("The publicly visible symbol of the token."),treasuryAccountId:u.z.string().optional().describe('Treasury account ID (e.g., "0.0.xxxx").'),initialSupply:u.z.union([u.z.number(),u.z.string()]).describe("Initial supply in the smallest denomination."),decimals:u.z.number().int().optional().default(0).describe("Number of decimal places for the token. Defaults to 0 if not specified."),adminKey:u.z.string().optional().describe(`Optional. Admin key (${rt}. Required for token to be mutable.`),kycKey:u.z.string().optional().describe(`Optional. KYC key (${rt}`),freezeKey:u.z.string().optional().describe(`Optional. Freeze key (${rt}`),wipeKey:u.z.string().optional().describe(`Optional. Wipe key (${rt}`),supplyKey:u.z.string().optional().describe(`Optional. Supply key (${rt}`),feeScheduleKey:u.z.string().optional().describe(`Optional. Fee schedule key (${rt}`),pauseKey:u.z.string().optional().describe(`Optional. Pause key (${rt}`),autoRenewAccountId:u.z.string().optional().describe('Optional. Auto-renew account ID (e.g., "0.0.xxxx").'),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. Auto-renewal period in seconds."),memo:u.z.string().optional().describe("Optional. Memo for the token."),freezeDefault:u.z.boolean().optional().describe("Optional. Default freeze status for accounts."),customFees:u.z.array(ct).optional().describe("Optional. Array of custom fee objects for the token."),supplyType:u.z.enum([e.TokenSupplyType.Finite.toString(),e.TokenSupplyType.Infinite.toString()]).optional().default(e.TokenSupplyType.Finite.toString()).describe("Supply type: FINITE or INFINITE. Defaults to FINITE if not specified."),maxSupply:u.z.union([u.z.number(),u.z.string()]).optional().default(1e15).describe("Max supply if supplyType is FINITE. Builder validates against initialSupply.")});class dt extends U{constructor(e){super(e),this.name="hedera-hts-create-fungible-token",this.description="Creates a new Hedera Fungible Token (FT). Builder handles key parsing, fee construction, and supply validation.",this.specificInputSchema=lt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.createFungibleToken(t)}getNoteForKey(e,t,n){if("decimals"===e)return`The number of decimal places for your token was automatically set to '${n}'.`;if("supplyType"===e)return`Your token's supply type was set to '${n}' by default.`;if("maxSupply"===e)try{return`A maximum supply of '${BigInt(String(n)).toLocaleString()}' for the token was set by default.`}catch{return`The maximum supply for the token was set to '${n}' by default.`}return"freezeDefault"===e?`By default, accounts holding this token will ${n?"be frozen":"not be frozen"}.`:void 0}}const ut=u.z.object({type:u.z.enum(["FIXED","FIXED_FEE"]),feeCollectorAccountId:u.z.string().optional().describe(ot),denominatingTokenId:u.z.string().optional().describe("Denominating token ID for the fee (if not HBAR)."),amount:u.z.union([u.z.number(),u.z.string()]).describe("Fee amount (smallest unit for tokens, or tinybars for HBAR).")}),ht=u.z.object({type:u.z.enum(["FRACTIONAL","FRACTIONAL_FEE"]),feeCollectorAccountId:u.z.string().optional().describe(ot),numerator:u.z.number().int().describe("Numerator of the fractional fee."),denominator:u.z.number().int().positive().describe("Denominator of the fractional fee."),minAmount:u.z.union([u.z.number(),u.z.string()]).optional().describe("Minimum fractional fee amount."),maxAmount:u.z.union([u.z.number(),u.z.string()]).optional().describe("Maximum fractional fee amount (0 for no max)."),assessmentMethodInclusive:u.z.boolean().optional().describe("Fee is assessed on net amount (false) or gross (true).")}),pt=u.z.object({type:u.z.enum(["ROYALTY","ROYALTY_FEE"]),feeCollectorAccountId:u.z.string().optional().describe(ot),numerator:u.z.number().int().describe("Numerator of the royalty fee."),denominator:u.z.number().int().positive().describe("Denominator of the royalty fee."),fallbackFee:ut.omit({type:!0}).optional().describe("Fallback fixed fee if royalty is not applicable.")}),gt=u.z.discriminatedUnion("type",[ut,ht,pt]),mt=u.z.object({tokenName:u.z.string().describe("The publicly visible name of the NFT collection."),tokenSymbol:u.z.string().optional().describe("The publicly visible symbol of the NFT collection."),treasuryAccountId:u.z.string().optional().describe('Treasury account ID (e.g., "0.0.xxxx").'),adminKey:u.z.string().optional().describe(`Optional. Admin key (${rt}`),kycKey:u.z.string().optional().describe(`Optional. KYC key (${rt}`),freezeKey:u.z.string().optional().describe(`Optional. Freeze key (${rt}`),wipeKey:u.z.string().optional().describe(`Optional. Wipe key (${rt}`),supplyKey:u.z.string().optional().describe(`Optional. Supply key (${rt}`),feeScheduleKey:u.z.string().optional().describe(`Optional. Fee schedule key (${rt}`),pauseKey:u.z.string().optional().describe(`Optional. Pause key (${rt}`),autoRenewAccountId:u.z.string().optional().describe('Optional. Auto-renew account ID (e.g., "0.0.xxxx").'),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. Auto-renewal period in seconds."),memo:u.z.string().optional().describe("Optional. Memo for the NFT collection."),freezeDefault:u.z.boolean().optional().describe("Optional. Default freeze status for accounts."),customFees:u.z.array(gt).optional().describe("Optional. Array of custom fee objects for the token."),supplyType:u.z.enum([e.TokenSupplyType.Finite.toString(),e.TokenSupplyType.Infinite.toString()]).optional().default(e.TokenSupplyType.Finite.toString()).describe("Supply type: FINITE or INFINITE. NFTs typically use FINITE. Defaults to FINITE if not specified."),maxSupply:u.z.union([u.z.number(),u.z.string()]).optional().describe("Max supply if supplyType is FINITE. Builder handles validation.")});class ft extends U{constructor(e){super(e),this.name="hedera-hts-create-nft",this.description="Creates a new Hedera Non-Fungible Token (NFT) collection. Builder handles key parsing, fee construction, and supply validation.",this.specificInputSchema=mt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.createNonFungibleToken(t)}getNoteForKey(e,t,n){if("supplyType"===e)return`Your NFT collection's supply type was set to '${n}' by default.`;if("maxSupply"===e&&void 0!==n)try{return`A maximum supply of '${BigInt(String(n)).toLocaleString()}' for the NFT collection was set (tool schema default).`}catch{return`The maximum supply for the NFT collection was set to '${n}' (tool schema default).`}}}const yt=u.z.object({tokenId:u.z.string().describe('The ID of the token to delete (e.g., "0.0.xxxx").')});class bt extends U{constructor(e){super(e),this.name="hedera-hts-delete-token",this.description="Deletes a token. Requires the tokenId. Use metaOptions for execution control.",this.specificInputSchema=yt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.deleteToken(t)}}const It=u.z.object({accountId:u.z.string().describe('The account ID to dissociate tokens from (e.g., "0.0.xxxx").'),tokenIds:u.z.array(u.z.string().describe('A token ID (e.g., "0.0.yyyy").')).min(1).describe("An array of one or more token IDs to dissociate.")});class kt extends U{constructor(e){super(e),this.name="hedera-hts-dissociate-tokens",this.description="Dissociates one or more Hedera tokens from an account.",this.specificInputSchema=It,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.dissociateTokens(t)}}const Tt=u.z.object({tokenId:u.z.string().describe('The ID of the token (e.g., "0.0.xxxx").'),accountId:u.z.string().describe('The account ID to be frozen for the token (e.g., "0.0.yyyy").')});class wt extends U{constructor(e){super(e),this.name="hedera-hts-freeze-token-account",this.description="Freezes an account for a specific token.",this.specificInputSchema=Tt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.freezeTokenAccount(t)}}const At=u.z.object({tokenId:u.z.string().describe('The token ID to get information for (e.g., "0.0.12345")')});class St extends ge{constructor(e){super(e),this.name="hedera-get-token-info",this.description="Retrieves comprehensive information about a Hedera token including name, symbol, supply, keys, and other metadata.",this.specificInputSchema=At,this.namespace="hts"}async executeQuery(e){this.logger.info(`Getting token info for token ID: ${e.tokenId}`);const t=await this.hederaKit.query().getTokenInfo(e.tokenId);return t?{success:!0,tokenInfo:t}:{success:!1,error:`Token ${e.tokenId} not found`}}}const xt=u.z.object({tokenId:u.z.string().describe('The ID of the token (e.g., "0.0.xxxx").'),accountId:u.z.string().describe('The account ID to be granted KYC for the token (e.g., "0.0.yyyy").')});class Nt extends U{constructor(e){super(e),this.name="hedera-hts-grant-kyc-token",this.description="Grants KYC to an account for a specific token.",this.specificInputSchema=xt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.grantKycToken(t)}}const vt=u.z.object({tokenId:u.z.string().describe('The ID of the fungible token (e.g., "0.0.xxxx").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("Amount to mint (smallest unit). Number or string for large values. Builder handles conversion.")});class zt extends U{constructor(e){super(e),this.name="hedera-hts-mint-fungible-token",this.description="Mints more fungible tokens. Requires tokenId and amount.",this.specificInputSchema=vt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.mintFungibleToken(t)}}const Ct=u.z.object({tokenId:u.z.string().describe('The ID of the NFT collection (e.g., "0.0.xxxx").'),metadata:u.z.array(u.z.string()).describe("Array of metadata for each NFT. Strings are treated as UTF-8, or base64 for binary. Builder handles decoding & validation."),batchSize:u.z.number().int().positive().optional().describe("Optional. Max NFTs per transaction if chunking. Builder handles default/limits.")});class Kt extends U{constructor(e){super(e),this.name="hedera-hts-mint-nft",this.description="Mints new Non-Fungible Tokens (NFTs). Builder handles metadata decoding and batching.",this.specificInputSchema=Ct,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.mintNonFungibleToken(t)}}const Ot=u.z.object({tokenId:u.z.string().describe('The ID of the token to pause (e.g., "0.0.xxxx").')});class Ft extends U{constructor(e){super(e),this.name="hedera-hts-pause-token",this.description="Pauses a token. Requires the tokenId. Use metaOptions for execution control.",this.specificInputSchema=Ot,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.pauseToken(t)}}const $t=u.z.object({tokenId:u.z.string().describe('The ID of the token type to reject future associations with (e.g., "0.0.xxxx").'),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class Et extends U{constructor(e){super(e),this.name="hedera-hts-reject-tokens",this.description="Configures the operator to reject future auto-associations with a specific token type.",this.specificInputSchema=$t,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.rejectTokens(t)}}const Rt=u.z.object({tokenId:u.z.string().describe('The ID of the token (e.g., "0.0.xxxx").'),accountId:u.z.string().describe('The account ID to have KYC revoked for the token (e.g., "0.0.yyyy").')});class Dt extends U{constructor(e){super(e),this.name="hedera-hts-revoke-kyc-token",this.description="Revokes KYC from an account for a specific token.",this.specificInputSchema=Rt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.revokeKycToken(t)}}const Mt="Fee collector's account ID.",Pt=u.z.object({type:u.z.literal("FIXED"),feeCollectorAccountId:u.z.string().describe(Mt),denominatingTokenId:u.z.string().optional().describe("Denominating token ID for the fee (if not HBAR)."),amount:u.z.union([u.z.number(),u.z.string()]).describe("Fee amount (smallest unit for tokens, or tinybars for HBAR).")}),Bt=u.z.object({type:u.z.literal("FRACTIONAL"),feeCollectorAccountId:u.z.string().describe(Mt),numerator:u.z.number().int().describe("Numerator of the fractional fee."),denominator:u.z.number().int().positive().describe("Denominator of the fractional fee."),assessmentMethodInclusive:u.z.boolean().optional().describe("Fee is assessed on net amount (false) or gross (true).")}),Lt=u.z.object({type:u.z.literal("ROYALTY"),feeCollectorAccountId:u.z.string().describe(Mt),numerator:u.z.number().int().describe("Numerator of the royalty fee."),denominator:u.z.number().int().positive().describe("Denominator of the royalty fee."),fallbackFee:Pt.omit({type:!0}).optional().describe("Fallback fixed fee if royalty is not applicable.")}),_t=u.z.discriminatedUnion("type",[Pt,Bt,Lt]),Ht=u.z.object({tokenId:u.z.string().describe('The ID of the token whose fee schedule is to be updated (e.g., "0.0.xxxx").'),customFees:u.z.array(_t).min(1).describe("An array of new custom fee objects. This will replace the existing fee schedule.")});class Ut extends U{constructor(e){super(e),this.name="hedera-hts-token-fee-schedule-update",this.description="Updates the fee schedule of a token. Requires tokenId and an array of custom fee objects.",this.specificInputSchema=Ht,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.feeScheduleUpdate(t)}}const jt=u.z.object({tokenId:u.z.string().describe('The token ID of the NFT (e.g., "0.0.xxxx").'),serial:u.z.union([u.z.number().int().positive(),u.z.string()]).describe("The serial number of the NFT."),senderAccountId:u.z.string().describe('The sender account ID (e.g., "0.0.xxxx").'),receiverAccountId:u.z.string().describe('The receiver account ID (e.g., "0.0.yyyy").'),isApproved:u.z.boolean().optional().describe("Optional. True if sender is an approved operator for the NFT."),memo:u.z.string().optional().describe("Optional. Memo for the transaction.")});class qt extends U{constructor(e){super(e),this.name="hedera-hts-transfer-nft",this.description="Transfers a single Non-Fungible Token (NFT).",this.specificInputSchema=jt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.transferNft(t)}}const Gt=u.z.object({type:u.z.literal("fungible"),tokenId:u.z.string().describe('Token ID (e.g., "0.0.xxxx").'),accountId:u.z.string().describe('Account ID for the transfer (e.g., "0.0.yyyy").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("Amount in smallest unit. Positive for credit, negative for debit. Builder handles conversion.")}),Wt=u.z.object({type:u.z.literal("nft"),tokenId:u.z.string().describe('Token ID of the NFT (e.g., "0.0.xxxx").'),serial:u.z.union([u.z.number().int().positive(),u.z.string()]).describe("Serial number of the NFT."),senderAccountId:u.z.string().describe('Sender account ID (e.g., "0.0.ssss").'),receiverAccountId:u.z.string().describe('Receiver account ID (e.g., "0.0.rrrr").'),isApproved:u.z.boolean().optional().describe("Optional. True if sender is an approved operator.")}),Yt=u.z.object({accountId:u.z.string().describe('Account ID for the HBAR transfer (e.g., "0.0.zzzz").'),amount:u.z.union([u.z.number(),u.z.string()]).describe("HBAR amount in tinybars. Positive for credit, negative for debit. Builder handles Hbar unit conversion.")}),Jt=u.z.object({tokenTransfers:u.z.array(u.z.discriminatedUnion("type",[Gt,Wt])).min(1).describe("Array of fungible token and/or NFT transfers."),hbarTransfers:u.z.array(Yt).optional().describe("Optional. Array of HBAR transfers. Sum of amounts must be zero."),memo:u.z.string().optional().describe("Optional. Memo for the entire transaction.")});class Qt extends U{constructor(e){super(e),this.name="hedera-hts-transfer-tokens",this.description="Transfers multiple fungible tokens, NFTs, and/or HBAR in a single transaction. Builder handles parsing and validation.",this.specificInputSchema=Jt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.transferTokens(t)}}const Vt=u.z.object({tokenId:u.z.string().describe('The ID of the token (e.g., "0.0.xxxx").'),accountId:u.z.string().describe('The account ID to be unfrozen for the token (e.g., "0.0.yyyy").')});class Xt extends U{constructor(e){super(e),this.name="hedera-hts-unfreeze-token-account",this.description="Unfreezes an account for a specific token.",this.specificInputSchema=Vt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.unfreezeTokenAccount(t)}}const Zt=u.z.object({tokenId:u.z.string().describe('The ID of the token to unpause (e.g., "0.0.xxxx").')});class en extends U{constructor(e){super(e),this.name="hedera-hts-unpause-token",this.description="Unpauses a token. Requires the tokenId. Use metaOptions for execution control.",this.specificInputSchema=Zt,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.unpauseToken(t)}}const tn=u.z.object({tokenId:u.z.string().describe('The ID of the token to update (e.g., "0.0.xxxx").'),tokenName:u.z.string().nullable().optional().describe("Optional. New token name. Pass null to clear."),tokenSymbol:u.z.string().nullable().optional().describe("Optional. New token symbol. Pass null to clear."),treasuryAccountId:u.z.string().optional().describe('Optional. New treasury account ID (e.g., "0.0.yyyy").'),adminKey:u.z.string().nullable().optional().describe("Optional. New admin key (serialized string). Pass null to clear."),kycKey:u.z.string().nullable().optional().describe("Optional. New KYC key (serialized string). Pass null to clear."),freezeKey:u.z.string().nullable().optional().describe("Optional. New freeze key (serialized string). Pass null to clear."),wipeKey:u.z.string().nullable().optional().describe("Optional. New wipe key (serialized string). Pass null to clear."),supplyKey:u.z.string().nullable().optional().describe("Optional. New supply key (serialized string). Pass null to clear."),feeScheduleKey:u.z.string().nullable().optional().describe("Optional. New fee schedule key (serialized string). Pass null to clear."),pauseKey:u.z.string().nullable().optional().describe("Optional. New pause key (serialized string). Pass null to clear."),autoRenewAccountId:u.z.string().nullable().optional().describe("Optional. New auto-renew account ID. Pass null to clear."),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. New auto-renewal period in seconds."),memo:u.z.string().nullable().optional().describe("Optional. New token memo. Pass null to clear.")});class nn extends U{constructor(e){super(e),this.name="hedera-hts-update-token",this.description="Updates an existing Hedera token. Requires tokenId. Other fields are optional. Null can be used to clear certain fields.",this.specificInputSchema=tn,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.updateToken(t)}}const rn=u.z.object({accountId:u.z.string().describe('The account ID to check ownership for (e.g., "0.0.12345")'),tokenId:u.z.string().describe('The NFT token ID (e.g., "0.0.67890")'),serialNumber:u.z.number().int().positive().describe("The serial number of the NFT")});class on extends ge{constructor(e){super(e),this.name="hedera-validate-nft-ownership",this.description="Validates whether a specific account owns a particular NFT by token ID and serial number.",this.specificInputSchema=rn,this.namespace="hts"}async executeQuery(e){this.logger.info(`Validating NFT ownership: account ${e.accountId}, token ${e.tokenId}, serial ${e.serialNumber}`);const t=await this.hederaKit.query().validateNftOwnership(e.accountId,e.tokenId,e.serialNumber),n=null!==t;return{success:!0,accountId:e.accountId,tokenId:e.tokenId,serialNumber:e.serialNumber,isOwned:n,nftDetail:n?t:null}}}const sn=u.z.object({tokenId:u.z.string().describe('The ID of the token to wipe (e.g., "0.0.xxxx").'),accountId:u.z.string().describe('The account ID from which tokens will be wiped (e.g., "0.0.yyyy").'),amount:u.z.union([u.z.number(),u.z.string()]).optional().describe("For Fungible Tokens: amount to wipe (smallest unit). Builder handles conversion and validation."),serials:u.z.array(u.z.union([u.z.number().int().positive(),u.z.string()])).optional().describe("For Non-Fungible Tokens: array of serial numbers to wipe. Builder handles conversion and validation.")});class an extends U{constructor(e){super(e),this.name="hedera-hts-wipe-token-account",this.description="Wipes tokens (fungible or non-fungible) from an account. Provide 'amount' for FTs or 'serials' for NFTs. Builder validates inputs.",this.specificInputSchema=sn,this.namespace="hts"}getServiceBuilder(){return this.hederaKit.hts()}async callBuilderMethod(e,t){await e.wipeTokenAccount(t)}}const cn=u.z.object({contractId:u.z.string().describe('The ID of the contract to delete (e.g., "0.0.xxxx").'),transferAccountId:u.z.string().optional().describe("Optional. Account ID to transfer balance to. Builder validates if needed."),transferContractId:u.z.string().optional().describe("Optional. Contract ID to transfer balance to. Builder validates if needed.")});class ln extends U{constructor(e){super(e),this.name="hedera-scs-delete-contract",this.description="Deletes a smart contract. Optionally specify a transfer target for any remaining balance.",this.specificInputSchema=cn,this.namespace="scs"}getServiceBuilder(){return this.hederaKit.scs()}async callBuilderMethod(e,t){await e.deleteContract(t)}}const dn=u.z.object({contractIdOrAddress:u.z.string().describe("The contract ID or EVM address"),timestamp:u.z.string().optional().describe("Optional timestamp for historical data"),includeBytecode:u.z.boolean().optional().default(!1).describe("Whether to include full bytecode in response (may be very large)")});class un extends ge{constructor(e){super(e),this.name="hedera-get-contract",this.description="Retrieves a specific contract by ID or EVM address from the Hedera network. Use includeBytecode=true for full bytecode (may be large).",this.specificInputSchema=dn,this.namespace="scs"}getLargeFieldProcessors(e){return e.includeBytecode?{}:{"contract.bytecode":{maxLength:200,truncateMessage:"[Use includeBytecode=true for full bytecode]"},"contract.runtime_bytecode":{maxLength:200,truncateMessage:"[Use includeBytecode=true for full runtime bytecode]"},"contract.creation_bytecode":{maxLength:200,truncateMessage:"[Use includeBytecode=true for full creation bytecode]"},bytecode:{maxLength:200,truncateMessage:"[Use includeBytecode=true for full bytecode]"},runtime_bytecode:{maxLength:200,truncateMessage:"[Use includeBytecode=true for full runtime bytecode]"},creation_bytecode:{maxLength:200,truncateMessage:"[Use includeBytecode=true for full creation bytecode]"}}}async executeQuery(e){this.logger.info(`Getting contract: ${e.contractIdOrAddress}`);const t=await this.hederaKit.query().getContract(e.contractIdOrAddress,e.timestamp);return null===t?{success:!1,error:`Contract ${e.contractIdOrAddress} not found`}:{success:!0,contract:t,summary:{contractId:t.contract_id,evmAddress:t.evm_address,created:t.created_timestamp,expiration:t.expiration_timestamp,deleted:t.deleted,memo:t.memo||"No memo",autoRenewPeriod:t.auto_renew_period,maxAutomaticTokenAssociations:t.max_automatic_token_associations,hasAdminKey:Boolean(t.admin_key),hasBytecode:Boolean(t.bytecode),hasRuntimeBytecode:Boolean(t.runtime_bytecode),bytecodeIncluded:e.includeBytecode}}}}const hn=u.z.object({contractId:u.z.string().optional().describe("Filter by specific contract ID"),limit:u.z.number().optional().describe("Maximum number of contracts to return"),order:u.z.enum(["asc","desc"]).optional().describe("Order of results")});class pn extends ge{constructor(e){super(e),this.name="hedera-get-contracts",this.description="Retrieves contract entities from the Hedera network with optional filtering.",this.specificInputSchema=hn,this.namespace="scs"}async executeQuery(e){this.logger.info("Getting contracts from the network");const t=await this.hederaKit.query().getContracts(e);return null===t?{success:!1,error:"Could not retrieve contracts from the network"}:{success:!0,contracts:t,count:t.length}}}const gn=u.z.object({contractId:u.z.string().describe('The ID of the contract to update (e.g., "0.0.xxxx").'),adminKey:u.z.string().nullable().optional().describe("Optional. New admin key (serialized string). Pass null to clear."),autoRenewPeriod:u.z.number().int().positive().optional().describe("Optional. New auto-renewal period in seconds."),memo:u.z.string().nullable().optional().describe("Optional. New contract memo. Pass null or empty string to clear."),stakedAccountId:u.z.string().nullable().optional().describe('Optional. New account ID to stake to. Pass "0.0.0" or null to clear.'),stakedNodeId:u.z.number().int().nullable().optional().describe("Optional. New node ID to stake to. Pass -1 or null to clear. Builder handles Long conversion."),declineStakingReward:u.z.boolean().optional().describe("Optional. If true, contract declines staking rewards."),maxAutomaticTokenAssociations:u.z.number().int().optional().describe("Optional. New max automatic token associations."),proxyAccountId:u.z.string().nullable().optional().describe('Optional. New proxy account ID. Pass "0.0.0" or null to clear.')});class mn extends U{constructor(e){super(e),this.name="hedera-scs-update-contract",this.description="Updates an existing Hedera smart contract. Builder handles parsing and clearing logic.",this.specificInputSchema=gn,this.namespace="scs"}getServiceBuilder(){return this.hederaKit.scs()}async callBuilderMethod(e,t){await e.updateContract(t)}}const fn=u.z.object({date:u.z.string().optional().describe('Date to get HBAR price for in ISO format (e.g., "2023-12-01T00:00:00Z"). Defaults to current date.')});class yn extends ge{constructor(e){super(e),this.name="hedera-get-hbar-price",this.description="Retrieves the HBAR price in USD for a specific date. Defaults to current date if no date provided.",this.specificInputSchema=fn,this.namespace="network"}async executeQuery(e){const t=e.date?new Date(e.date):new Date;this.logger.info(`Getting HBAR price for date: ${t.toISOString()}`);const n=await this.hederaKit.query().getHbarPrice(t);return null===n?{success:!1,error:`Could not retrieve HBAR price for date ${t.toISOString()}`}:{success:!0,date:t.toISOString(),priceUsd:n,currency:"USD"}}}const bn=u.z.object({});class In extends ge{constructor(e){super(e),this.name="hedera-get-network-info",this.description="Retrieves network information from the Hedera network.",this.specificInputSchema=bn,this.namespace="network"}async executeQuery(){this.logger.info("Getting network information");const e=await this.hederaKit.query().getNetworkInfo();return null===e?{success:!1,error:"Could not retrieve network information"}:{success:!0,networkInfo:e}}}const kn=u.z.object({timestamp:u.z.string().optional().describe("Optional timestamp for historical fees")});class Tn extends ge{constructor(e){super(e),this.name="hedera-get-network-fees",this.description="Retrieves network fees from the Hedera network.",this.specificInputSchema=kn,this.namespace="network"}async executeQuery(e){this.logger.info("Getting network fees");const t=await this.hederaKit.query().getNetworkFees(e.timestamp);return null===t?{success:!1,error:"Could not retrieve network fees"}:{success:!0,networkFees:t}}}const wn=u.z.object({blockNumber:u.z.string().optional().describe("Filter by block number"),timestamp:u.z.string().optional().describe("Filter by timestamp"),limit:u.z.number().optional().describe("Maximum number of blocks to return"),order:u.z.enum(["asc","desc"]).optional().describe("Order of results")});class An extends ge{constructor(e){super(e),this.name="hedera-get-blocks",this.description="Retrieves blocks from the Hedera network with optional filtering.",this.specificInputSchema=wn,this.namespace="network"}async executeQuery(e){this.logger.info("Getting blocks from the network");const t=await this.hederaKit.query().getBlocks(e);return null===t?{success:!1,error:"Could not retrieve blocks from the network"}:{success:!0,blocks:t,count:t.length}}}const Sn=u.z.object({transactionIdOrHash:u.z.string().describe('The transaction ID (e.g., "0.0.12345-1234567890-123456789") or hash to get details for')});class xn{async initialize(e){this.context=e}async cleanup(){}}class Nn extends xn{constructor(){super(...arguments),this.id="hedera-hts",this.name="Hedera Token Service Plugin",this.description="Provides tools for interacting with the Hedera Token Service (HTS).",this.version="1.0.0",this.author="Auto-Generated",this.tools=[]}async initialize(e){await super.initialize(e);const t=e.config.hederaKit,n=e.logger;let r=C.MEDIUM;e.config.modelCapability&&Object.values(C).includes(e.config.modelCapability)&&(r=e.config.modelCapability);const o={hederaKit:t,logger:n},i={hederaKit:t,logger:n,modelCapability:r};this.tools=[new Ye(o),new Qe(o),new nt(o),new dt(o),new ft(o),new zt(o),new Kt(o),new Et(o),new Qt(o),new kt(o),new nn(o),new bt(o),new Ft(o),new en(o),new wt(o),new Xt(o),new Nt(o),new Dt(o),new an(o),new Ut(o),new qt(o),new Xe(o),new et(o),new St(i),new on(i)]}getTools(){return this.tools}}class vn extends xn{constructor(){super(...arguments),this.id="hedera-hcs",this.name="Hedera Consensus Service Plugin",this.description="Provides tools for interacting with the Hedera Consensus Service (HCS).",this.version="1.0.0",this.author="Auto-Generated",this.tools=[]}async initialize(e){await super.initialize(e);const t=e.config.hederaKit,n=e.logger;let r=C.MEDIUM;e.config.modelCapability&&Object.values(C).includes(e.config.modelCapability)&&(r=e.config.modelCapability);const o={hederaKit:t,logger:n},i={hederaKit:t,logger:n,modelCapability:r};this.tools=[new $e(o),new Me(o),new Be(o),new Re(o),new Ue(i),new qe(i),new _e(i)]}getTools(){return this.tools}}class zn extends xn{constructor(){super(...arguments),this.id="hedera-account",this.name="Hedera Account Plugin",this.description="Provides tools for interacting with Hedera accounts.",this.version="1.0.0",this.author="Hedera Hashgraph",this.tools=[]}async initialize(e){await super.initialize(e);const t=e.config.hederaKit,n=e.logger;let r=C.MEDIUM;e.config.modelCapability&&Object.values(C).includes(e.config.modelCapability)&&(r=e.config.modelCapability);const o={hederaKit:t,logger:n},i={hederaKit:t,logger:n,modelCapability:r};this.tools=[new ne(o),new ee(o),new oe(o),new q(o),new X(o),new Q(o),new Y(o),new se(o),new ce(o),new Ke(o),new de(o),new he(o),new ke(i),new Ne(i),new we(i),new ze(i),new Se(i),new fe(i),new be(i)]}getTools(){return this.tools}}class Cn extends xn{constructor(){super(...arguments),this.id="hedera-scs",this.name="Hedera Smart Contract Service Plugin",this.description="Provides tools for interacting with the Hedera Smart Contract Service (SCS).",this.version="1.0.0",this.author="Auto-Generated",this.tools=[]}async initialize(e){await super.initialize(e);const t=e.config.hederaKit,n=e.logger;let r=C.MEDIUM;e.config.modelCapability&&Object.values(C).includes(e.config.modelCapability)&&(r=e.config.modelCapability);const o={hederaKit:t,logger:n},i={hederaKit:t,logger:n,modelCapability:r};this.tools=[new mn(o),new ln(o),new pn(i),new un(i)]}getTools(){return this.tools}}class Kn extends xn{constructor(){super(...arguments),this.id="hedera-network",this.name="Hedera Network Plugin",this.description="Provides tools for interacting with the Hedera network and mirror node.",this.version="1.0.0",this.author="Auto-Generated",this.tools=[]}async initialize(e){await super.initialize(e);const t=e.config.hederaKit,n=e.logger;let r=C.MEDIUM;e.config.modelCapability&&Object.values(C).includes(e.config.modelCapability)&&(r=e.config.modelCapability);const o={hederaKit:t,logger:n,modelCapability:r};this.tools=[new yn(o),new An(o),new In(o),new Tn(o)]}getTools(){return this.tools}}Object.defineProperty(exports,"AccountId",{enumerable:!0,get:()=>e.AccountId}),Object.defineProperty(exports,"ContractFunctionParameters",{enumerable:!0,get:()=>e.ContractFunctionParameters}),Object.defineProperty(exports,"ContractId",{enumerable:!0,get:()=>e.ContractId}),Object.defineProperty(exports,"CustomFee",{enumerable:!0,get:()=>e.CustomFee}),Object.defineProperty(exports,"CustomFixedFee",{enumerable:!0,get:()=>e.CustomFixedFee}),Object.defineProperty(exports,"EvmAddress",{enumerable:!0,get:()=>e.EvmAddress}),Object.defineProperty(exports,"FileId",{enumerable:!0,get:()=>e.FileId}),Object.defineProperty(exports,"Hbar",{enumerable:!0,get:()=>e.Hbar}),Object.defineProperty(exports,"Key",{enumerable:!0,get:()=>e.Key}),Object.defineProperty(exports,"KeyList",{enumerable:!0,get:()=>e.KeyList}),Object.defineProperty(exports,"Long",{enumerable:!0,get:()=>e.Long}),Object.defineProperty(exports,"NftId",{enumerable:!0,get:()=>e.NftId}),Object.defineProperty(exports,"PendingAirdropId",{enumerable:!0,get:()=>e.PendingAirdropId}),Object.defineProperty(exports,"PrivateKey",{enumerable:!0,get:()=>e.PrivateKey}),Object.defineProperty(exports,"PublicKey",{enumerable:!0,get:()=>e.PublicKey}),Object.defineProperty(exports,"ScheduleId",{enumerable:!0,get:()=>e.ScheduleId}),Object.defineProperty(exports,"TokenId",{enumerable:!0,get:()=>e.TokenId}),Object.defineProperty(exports,"TokenSupplyType",{enumerable:!0,get:()=>e.TokenSupplyType}),Object.defineProperty(exports,"TokenType",{enumerable:!0,get:()=>e.TokenType}),Object.defineProperty(exports,"TopicId",{enumerable:!0,get:()=>e.TopicId}),Object.defineProperty(exports,"TransactionId",{enumerable:!0,get:()=>e.TransactionId}),exports.AbstractSigner=B,exports.AccountBuilder=S,exports.AgentKitActionName=L,exports.BaseHederaQueryTool=ge,exports.BaseHederaTransactionTool=U,exports.BasePlugin=xn,exports.BaseServiceBuilder=f,exports.FEE_COLLECTOR_DESCRIPTION=ot,exports.HcsBuilder=b,exports.HederaAccountPlugin=zn,exports.HederaAgentKit=F,exports.HederaAirdropTokenTool=Ye,exports.HederaApproveFungibleTokenAllowanceTool=ne,exports.HederaApproveHbarAllowanceTool=ee,exports.HederaApproveTokenNftAllowanceTool=oe,exports.HederaAssociateTokensTool=Qe,exports.HederaBurnFungibleTokenTool=Xe,exports.HederaBurnNftTool=et,exports.HederaClaimAirdropTool=nt,exports.HederaConversationalAgent=class{constructor(e,t={}){this.config={operationalMode:"returnBytes",verbose:!1,scheduleUserTransactionsInBytesMode:!0,...t};const n=this.config.modelCapability||E.getInstance().getModelCapabilitySync(t.openAIModelName),r=this.config.disableLogging||"true"===process.env.DISABLE_LOGS,o=this.config.verbose?"debug":"info",i=r?"silent":o;this.logger=new g({level:i,module:"HederaConversationalAgent",silent:r}),this.hederaKit=new F(e,this.config.pluginConfig,this.config.operationalMode,this.config.userAccountId,this.config.scheduleUserTransactionsInBytesMode,n,this.config.openAIModelName||process.env.OPENAI_MODEL_NAME||"gpt-4o-mini",this.config.mirrorNodeConfig,r);const a=this.config.openAIModelName||process.env.OPENAI_MODEL_NAME||"gpt-4o-mini";if(this.tokenUsageHandler=new M(a,this.logger),this.config.llm)this.llm=this.config.llm;else{const e=this.config.openAIApiKey||process.env.OPENAI_API_KEY;if(!e)throw new Error("OpenAI API key is required. Provide it in config or via OPENAI_API_KEY env variable.");this.llm=new s.ChatOpenAI({apiKey:e,modelName:a,temperature:.1,callbacks:[this.tokenUsageHandler]})}}constructSystemMessage(){let e=[];const t=this.hederaKit.signer.getAccountId().toString(),n=this.config.userAccountId;return this.config.customSystemMessagePreamble&&e.push(this.config.customSystemMessagePreamble),e.push(`You are a helpful Hedera assistant. Your primary operator account is ${t}. You have tools to interact with the Hedera network. When using any tool, provide all necessary parameters as defined by that tool's schema and description.`),n&&e.push(`The user you are assisting has a personal Hedera account ID: ${n}. IMPORTANT: When the user says things like "I want to send HBAR" or "transfer my tokens", you MUST use ${n} as the sender/from account. For example, if user says "I want to send 2 HBAR to 0.0.800", you must set up a transfer where ${n} sends the HBAR, not your operator account.`),"autonomous"===this.hederaKit.operationalMode?e.push(`\nOPERATIONAL MODE: 'autonomous'. Your goal is to execute transactions directly using your tools. Your account ${t} will be the payer for these transactions. Even if the user's account (${n||"a specified account"}) is the actor in the transaction body (e.g., sender of HBAR), you (the agent with operator ${t}) are still executing and paying. For HBAR transfers, ensure the amounts in the 'transfers' array sum to zero (as per tool schema), balancing with your operator account if necessary.`):this.config.scheduleUserTransactionsInBytesMode&&n?e.push(`\nOPERATIONAL MODE: 'returnBytes' with scheduled transactions for user actions. When a user asks for a transaction to be prepared (e.g., creating a token, topic, transferring assets for them to sign, etc), you MUST default to creating a Scheduled Transaction using the appropriate tool with the metaOption 'schedule: true'. The user (with account ID ${n}) will be the one to ultimately pay for and (if needed) sign the inner transaction. Your operator account (${t}) will pay for creating the schedule entity itself. You MUST return the ScheduleId and details of the scheduled operation in a structured JSON format with these fields: success, op, schedule_id, description, payer_account_id_scheduled_tx, and scheduled_transaction_details.\nOnce a transaction is scheduled and you've provided the Schedule ID, you should ask the user if they want to sign and execute it. If they agree, use the 'hedera-sign-and-execute-scheduled-transaction' tool, providing the Schedule ID. This tool will prepare a ScheduleSignTransaction. If the agent is also configured for 'returnBytes', this ScheduleSignTransaction will be returned as bytes for the user to sign and submit using their account ${n}. If the agent is in 'autonomous' mode for the ScheduleSign part (not typical for user-scheduled flows but possible), the agent would sign and submit it.`):e.push(`\nOPERATIONAL MODE: 'returnBytes'. Your goal is to provide transaction bytes directly. When a user asks for a transaction to be prepared (e.g., for them to sign, or for scheduling without the default scheduling flow), you MUST call the appropriate tool. If you want raw bytes for the user to sign for their own account ${n||"if specified"}, ensure the tool constructs the transaction body accordingly and use metaOption 'returnBytes: true' if available, or ensure the builder is configured for the user. `+(n?`If the transaction body was constructed to reflect the user's account ${n} as the actor, also inform the user the application can adapt these bytes for their signing and payment using their account ${n}.`:"")),e.push("\nAlways be concise. If the tool provides a JSON string as its primary output (especially in returnBytes mode), make your accompanying text brief. If the tool does not provide JSON output or an error occurs, your narrative becomes primary; if notes were generated by the tool in such cases, append them to your textual response."),this.config.customSystemMessagePostamble&&e.push(this.config.customSystemMessagePostamble),e.join("\n")}async initialize(){const e=await E.getInstance().getModelCapability(this.config.openAIModelName);e!==this.hederaKit.modelCapability&&(this.hederaKit.modelCapability=e,this.logger.info(`Updated model capability to ${e} after API fetch`)),await this.hederaKit.initialize(),this.systemMessage=this.constructSystemMessage();const t=this.hederaKit.getAggregatedLangChainTools();0===t.length&&this.logger.warn("No tools were loaded into HederaAgentKit. The agent may not function correctly."),this.logger.info(`Loaded ${t.length} tools for model capability: ${this.hederaKit.modelCapability}`);const n=a.ChatPromptTemplate.fromMessages([["system",this.systemMessage],new a.MessagesPlaceholder("chat_history"),["human","{input}"],new a.MessagesPlaceholder("agent_scratchpad")]),r=await d.createOpenAIToolsAgent({llm:this.llm,tools:t,prompt:n});this.agentExecutor=new d.AgentExecutor({agent:r,tools:t,verbose:this.config.verbose??!1,returnIntermediateSteps:!0}),this.logger.info("HederaConversationalAgent initialized.")}async processMessage(e,t){if(!this.agentExecutor)throw new Error("HederaConversationalAgent not initialized. Call await initialize() first.");const n=(t||[]).map(e=>"human"===e.type?new c.HumanMessage(e.content):new c.AIMessage(e.content));let r={output:"",message:"",notes:[],transactionBytes:void 0,receipt:void 0,scheduleId:void 0,transactionId:void 0,error:void 0,intermediateSteps:void 0,rawToolOutput:void 0,tokenUsage:void 0,cost:void 0};try{const t=await this.agentExecutor.invoke({input:e,chat_history:n});r.message=t.output||"";let i=t?.intermediateSteps?.[0]?.observation;if(i)try{r={...r,...JSON.parse(i)}}catch(o){this.logger.error("Error parsing intermediate steps:",o)}r.output&&""!==r.output.trim()||(r.output="Agent action complete.");const s=this.tokenUsageHandler.getLatestTokenUsage();return s&&(r.tokenUsage=s,r.cost=P(s),this.logger.debug("Token usage for request:",{promptTokens:s.promptTokens,completionTokens:s.completionTokens,totalTokens:s.totalTokens,cost:r.cost.totalCost})),r}catch(i){const e=i instanceof Error?i.message:"Unknown error";this.logger.error(`Error in HederaConversationalAgent.processMessage: ${e}`,i);const t=this.tokenUsageHandler.getLatestTokenUsage();let n;return t&&(n=P(t)),{output:"Sorry, I encountered an error processing your request.",message:r.message||"",notes:r.notes||[],error:e,transactionBytes:r?.transactionBytes,receipt:r.receipt,scheduleId:r.scheduleId,transactionId:r.transactionId,intermediateSteps:r.intermediateSteps,rawToolOutput:r.rawToolOutput,tokenUsage:t||void 0,cost:n}}}setOperationalMode(e){this.config.operationalMode=e,this.hederaKit.operationalMode=e,this.systemMessage=this.constructSystemMessage(),this.logger.info(`Operational mode set to: ${e}. System message and kit mode updated.`),this.agentExecutor&&this.logger.warn("Operational mode changed. For the new system prompt to fully take effect, re-initialization (call initialize()) or recreation of the agent executor is needed.")}getTotalTokenUsage(){const e=this.tokenUsageHandler.getTotalTokenUsage(),t=P(e);return{...e,cost:t}}getTokenUsageHistory(){return this.tokenUsageHandler.getTokenUsageHistory().map(e=>({...e,cost:P(e)}))}resetTokenUsageTracking(){this.tokenUsageHandler.reset(),this.logger.info("Token usage tracking has been reset")}getKit(){return this.hederaKit}},exports.HederaCreateAccountTool=q,exports.HederaCreateFungibleTokenTool=dt,exports.HederaCreateNftTool=ft,exports.HederaCreateTopicTool=$e,exports.HederaDeleteAccountTool=X,exports.HederaDeleteContractTool=ln,exports.HederaDeleteNftSerialAllowancesTool=he,exports.HederaDeleteNftSpenderAllowanceTool=de,exports.HederaDeleteTokenTool=bt,exports.HederaDeleteTopicTool=Me,exports.HederaDissociateTokensTool=kt,exports.HederaFreezeTokenAccountTool=wt,exports.HederaGetAccountBalanceTool=ke,exports.HederaGetAccountInfoTool=we,exports.HederaGetAccountNftsTool=Se,exports.HederaGetAccountPublicKeyTool=Ne,exports.HederaGetAccountTokensTool=ze,exports.HederaGetBlocksTool=An,exports.HederaGetContractTool=un,exports.HederaGetContractsTool=pn,exports.HederaGetHbarPriceTool=yn,exports.HederaGetNetworkFeesTool=Tn,exports.HederaGetNetworkInfoTool=In,exports.HederaGetOutstandingAirdropsTool=fe,exports.HederaGetPendingAirdropsTool=be,exports.HederaGetTokenInfoTool=St,exports.HederaGetTopicFeesTool=qe,exports.HederaGetTopicInfoTool=Ue,exports.HederaGetTopicMessages=_e,exports.HederaGetTransactionTool=class extends ge{constructor(e){super(e),this.name="hedera-get-transaction",this.description="Retrieves detailed information about a Hedera transaction by transaction ID or hash.",this.specificInputSchema=Sn,this.namespace="transaction"}async executeQuery(e){this.logger.info(`Getting transaction details for: ${e.transactionIdOrHash}`);const t=await this.hederaKit.query().getTransaction(e.transactionIdOrHash);return t?{success:!0,transactionIdOrHash:e.transactionIdOrHash,transaction:t}:{success:!1,error:`Transaction ${e.transactionIdOrHash} not found`}}},exports.HederaGrantKycTokenTool=Nt,exports.HederaHCSPlugin=vn,exports.HederaHTSPlugin=Nn,exports.HederaMintFungibleTokenTool=zt,exports.HederaMintNftTool=Kt,exports.HederaPauseTokenTool=Ft,exports.HederaRejectTokensTool=Et,exports.HederaRevokeFungibleTokenAllowanceTool=ce,exports.HederaRevokeHbarAllowanceTool=se,exports.HederaRevokeKycTokenTool=Dt,exports.HederaSCSPlugin=Cn,exports.HederaSubmitMessageTool=Re,exports.HederaTokenFeeScheduleUpdateTool=Ut,exports.HederaTransactionMetaOptionsSchema=H,exports.HederaTransferHbarTool=Y,exports.HederaTransferNftTool=qt,exports.HederaTransferTokensTool=Qt,exports.HederaUnfreezeTokenAccountTool=Xt,exports.HederaUnpauseTokenTool=en,exports.HederaUpdateAccountTool=Q,exports.HederaUpdateContractTool=mn,exports.HederaUpdateTokenTool=nn,exports.HederaUpdateTopicTool=Be,exports.HederaValidateNftOwnershipTool=on,exports.HederaWipeTokenAccountTool=an,exports.HtsBuilder=w,exports.Logger=g,exports.ModelCapabilityDetector=E,exports.ModelPricingManager=D,exports.PluginRegistry=class{constructor(e){this.plugins=new Map,this.context=e,this.logger=e.logger}async registerPlugin(e){if(this.plugins.has(e.id))throw new Error(`Plugin with ID ${e.id} is already registered`);await e.initialize(this.context),this.plugins.set(e.id,e),this.logger.info(`Plugin registered: ${e.name} (${e.id}) v${e.version}`)}getPlugin(e){return this.plugins.get(e)}getAllPlugins(){return Array.from(this.plugins.values())}getAllTools(){return this.getAllPlugins().flatMap(e=>e.getTools())}async unregisterPlugin(e){const t=this.plugins.get(e);if(!t)return!1;if(t.cleanup)try{await t.cleanup()}catch(r){this.logger.error(`Error during plugin cleanup: ${r}`)}const n=this.plugins.delete(e);return n&&this.logger.info(`Plugin unregistered: ${t.name} (${t.id})`),n}async unregisterAllPlugins(){const e=Array.from(this.plugins.keys());for(const t of e)await this.unregisterPlugin(t)}},exports.QueryBuilder=z,exports.SERIALIZED_KEY_DESCRIPTION=rt,exports.ScsBuilder=N,exports.ServerSigner=class extends B{constructor(t,n,r){if(super(),this.keyType="ed25519",this.keyTypeVerified=!1,this.accountIdInternal=e.AccountId.fromString(t.toString()),this.networkInternal=r,this.logger=new g({module:"ServerSigner",level:"true"===process.env.DEBUG?"debug":"warn"}),this.initializeMirrorNode(this.networkInternal,"ServerSigner"),"mainnet"===r)this.client=e.Client.forMainnet();else{if("testnet"!==r)throw new Error(`Unsupported Hedera network type specified: ${r}. Only 'mainnet' or 'testnet' are supported.`);this.client=e.Client.forTestnet()}if("string"==typeof n){this.privateKeyString=n;try{const e=m(n);this.privateKey=e.privateKey,this.keyType=e.detectedType,this.initializeOperator(),this.logger.debug(`Detected key type from string: ${this.keyType}`)}catch(o){this.logger.warn("Failed to detect key type from private key format, will query mirror node",o.message),this.privateKey=e.PrivateKey.fromStringED25519(n),this.keyType="ed25519"}}else this.privateKey=n,this.privateKeyString=n.toString();this.client.setOperator(this.accountIdInternal,this.privateKey)}async initializeOperator(){try{const t=await this.mirrorNode.requestAccount(this.accountIdInternal.toString()),n=t?.key?._type;let r="ed25519";n?.includes("ECDSA")?r="ecdsa":n?.includes("ED25519")&&(r="ed25519"),r!==this.keyType?(this.logger.debug(`Key type mismatch detected. String detection: ${this.keyType}, Mirror node: ${r}. Using mirror node result.`),this.keyType=r,this.privateKeyString&&(this.privateKey="ecdsa"===r?e.PrivateKey.fromStringECDSA(this.privateKeyString):e.PrivateKey.fromStringED25519(this.privateKeyString),this.client.setOperator(this.accountIdInternal,this.privateKey),this.logger.debug(`Updated operator with verified key type: ${this.keyType}`))):this.logger.debug(`Key type verification successful: ${this.keyType}`),this.keyTypeVerified=!0}catch(t){this.logger.error(`Failed to verify key type from mirror node: ${t.message}`),this.keyTypeVerified=!0}}getAccountId(){return this.accountIdInternal}async signAndExecuteTransaction(e){e.isFrozen()||(e.transactionId,await e.freezeWith(this.client)),0===e.getSignatures().size&&await e.sign(this.privateKey);return(await e.execute(this.client)).getReceipt(this.client)}getNetwork(){return this.networkInternal}getOperatorPrivateKey(){return this.privateKey}getClient(){return this.client}async getKeyType(){return!this.keyTypeVerified&&this.privateKeyString&&await this.initializeOperator(),this.keyType}getKeyTypeSync(){return this.keyType}},exports.SignAndExecuteScheduledTransactionTool=Ke,exports.TokenUsageCallbackHandler=M,exports.calculateTokenCost=async function(e,t){const n=t||e.modelName||R,r=D.getInstance(),o=await r.getPricing(n),i=e.promptTokens/1e3*o.prompt,s=e.completionTokens/1e3*o.completion;return{promptCost:i,completionCost:s,totalCost:i+s,currency:"USD"}},exports.calculateTokenCostSync=P,exports.convertStringToTimestamp=function(e){const t=new Date(e);if(isNaN(t.getTime()))throw new Error("Invalid date format");const n=t.getTime();return parseFloat((n/1e3).toFixed(6))},exports.createBaseMirrorNodeApiUrl=e=>`https://${"mainnet"===e?`${e}-public`:e}.mirrornode.hedera.com`,exports.detectKeyTypeFromString=m,exports.estimateTokens=function(e){return Math.ceil(e.length/4)},exports.formatCost=function(e,t=6){return`$${e.totalCost.toFixed(t)} ${e.currency}`},exports.fromBaseToDisplayUnit=function(e,t){const n=new r(t),o=new r(10).pow(n);return(r.isBigNumber(e)?e:new r(e)).dividedBy(o)},exports.fromDisplayToBaseUnit=function(e,t){return e*10**t},exports.getAllHederaCorePlugins=function(){return[new Nn,new vn,new zn,new Cn,new Kn]},exports.parseCustomFeesJson=function(t,n){let r;try{if(r=JSON.parse(t),!Array.isArray(r))throw new Error("customFeesJson did not parse to an array.")}catch(o){const e=o instanceof Error?o.message:String(o);throw n.error("Invalid JSON string for customFeesJson:",e),new Error(`Invalid JSON string for customFeesJson: ${e}`)}return r.map((t,n)=>{const r=t.feeCollectorAccountId;if(!r||"string"!=typeof r)throw new Error(`Fee #${n+1}: feeCollectorAccountId is required and must be a string.`);const o=e.AccountId.fromString(r);let i;switch(t.feeType){case"FIXED_FEE":const r=(new e.CustomFixedFee).setFeeCollectorAccountId(o);if(t.denominatingTokenId&&r.setDenominatingTokenId(e.TokenId.fromString(t.denominatingTokenId)),void 0===t.amount||null===t.amount)throw new Error(`Fee #${n+1} (FIXED_FEE): amount is required.`);r.setAmount("string"==typeof t.amount?e.Long.fromString(t.amount):e.Long.fromNumber(t.amount)),i=r;break;case"FRACTIONAL_FEE":if(void 0===t.numerator||void 0===t.denominator)throw new Error(`Fee #${n+1} (FRACTIONAL_FEE): numerator and denominator are required.`);const s=(new e.CustomFractionalFee).setFeeCollectorAccountId(o).setNumerator(e.Long.fromValue(t.numerator)).setDenominator(e.Long.fromValue(t.denominator));t.minimumAmount&&s.setMin("string"==typeof t.minimumAmount?e.Long.fromString(t.minimumAmount):e.Long.fromNumber(t.minimumAmount)),t.maximumAmount&&s.setMax("string"==typeof t.maximumAmount?e.Long.fromString(t.maximumAmount):e.Long.fromNumber(t.maximumAmount)),"EXCLUSIVE"===t.assessmentMethod||!0===t.netOfTransfers?s.setAssessmentMethod(e.FeeAssessmentMethod.Exclusive):s.setAssessmentMethod(e.FeeAssessmentMethod.Inclusive),i=s;break;case"ROYALTY_FEE":if(void 0===t.numerator||void 0===t.denominator)throw new Error(`Fee #${n+1} (ROYALTY_FEE): numerator and denominator are required.`);const a=(new e.CustomRoyaltyFee).setFeeCollectorAccountId(o).setNumerator(e.Long.fromValue(t.numerator)).setDenominator(e.Long.fromValue(t.denominator));if(t.fallbackFee){if("object"!=typeof t.fallbackFee||null===t.fallbackFee)throw new Error(`Fee #${n+1} (ROYALTY_FEE): fallbackFee must be an object if provided.`);const r=(new e.CustomFixedFee).setFeeCollectorAccountId(o);if(t.fallbackFee.denominatingTokenId&&r.setDenominatingTokenId(e.TokenId.fromString(t.fallbackFee.denominatingTokenId)),void 0===t.fallbackFee.amount||null===t.fallbackFee.amount)throw new Error(`Fee #${n+1} (ROYALTY_FEE): fallbackFee.amount is required.`);r.setAmount("string"==typeof t.fallbackFee.amount?e.Long.fromString(t.fallbackFee.amount):e.Long.fromNumber(t.fallbackFee.amount)),a.setFallbackFee(r)}i=a;break;default:throw new Error(`Fee #${n+1}: Unknown custom fee type: ${t.feeType}. Supported types are FIXED_FEE, FRACTIONAL_FEE, ROYALTY_FEE.`)}return t.allCollectorsAreExempt&&"boolean"==typeof t.allCollectorsAreExempt&&i.setAllCollectorsAreExempt(t.allCollectorsAreExempt),i})},exports.parseKey=_;
//# sourceMappingURL=index.cjs.map
