{"version":3,"file":"index60.js","sources":["../../src/langchain/tools/hts/hts-tool-utils.ts"],"sourcesContent":["import {\n  CustomFee,\n  AccountId,\n  TokenId,\n  CustomFixedFee,\n  CustomFractionalFee,\n  CustomRoyaltyFee,\n  FeeAssessmentMethod,\n  Long,\n} from '@hashgraph/sdk';\nimport { Logger } from '../../../utils/logger';\n\nexport const SERIALIZED_KEY_DESCRIPTION =\n  'serialized string). Builder handles parsing.';\nexport const FEE_COLLECTOR_DESCRIPTION =\n  \"Fee collector's account ID. Defaults to user's account if in user-centric context and not specified.\";\n\ninterface FeeData {\n  feeCollectorAccountId: string;\n  feeType: 'FIXED_FEE' | 'FRACTIONAL_FEE' | 'ROYALTY_FEE';\n  amount?: string | number;\n  denominatingTokenId?: string;\n  numerator?: number;\n  denominator?: number;\n  minimumAmount?: string | number;\n  maximumAmount?: string | number;\n  assessmentMethod?: 'EXCLUSIVE' | 'INCLUSIVE';\n  netOfTransfers?: boolean;\n  fallbackFee?: {\n    amount: string | number;\n    denominatingTokenId?: string;\n  };\n  allCollectorsAreExempt?: boolean;\n}\n\n/**\n * Parses a JSON string representing an array of custom fee objects into an array of SDK CustomFee instances.\n * @param {string} customFeesJson - The JSON string to parse.\n * @param {StandardsSdkLogger} logger - Logger instance for error/warning logging.\n * @returns {CustomFee[]} An array of SDK CustomFee objects.\n * @throws {Error} If JSON parsing fails or fee data is invalid.\n */\nexport function parseCustomFeesJson(\n  customFeesJson: string,\n  logger: Logger\n): CustomFee[] {\n  let parsedFeesInput: FeeData[];\n  try {\n    parsedFeesInput = JSON.parse(customFeesJson) as FeeData[];\n    if (!Array.isArray(parsedFeesInput)) {\n      throw new Error('customFeesJson did not parse to an array.');\n    }\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Invalid JSON string for customFeesJson:', errorMessage);\n    throw new Error(`Invalid JSON string for customFeesJson: ${errorMessage}`);\n  }\n\n  return parsedFeesInput.map((feeData, index) => {\n    const feeCollectorAccountIdStr = feeData.feeCollectorAccountId;\n    if (\n      !feeCollectorAccountIdStr ||\n      typeof feeCollectorAccountIdStr !== 'string'\n    ) {\n      throw new Error(\n        `Fee #${\n          index + 1\n        }: feeCollectorAccountId is required and must be a string.`\n      );\n    }\n    const feeCollectorAccountId = AccountId.fromString(\n      feeCollectorAccountIdStr\n    );\n\n    let newFee: CustomFee;\n\n    switch (feeData.feeType) {\n      case 'FIXED_FEE':\n        const fixedFee = new CustomFixedFee().setFeeCollectorAccountId(\n          feeCollectorAccountId\n        );\n        if (feeData.denominatingTokenId) {\n          fixedFee.setDenominatingTokenId(\n            TokenId.fromString(feeData.denominatingTokenId)\n          );\n        }\n        if (feeData.amount === undefined || feeData.amount === null) {\n          throw new Error(`Fee #${index + 1} (FIXED_FEE): amount is required.`);\n        }\n        fixedFee.setAmount(\n          typeof feeData.amount === 'string'\n            ? Long.fromString(feeData.amount)\n            : Long.fromNumber(feeData.amount)\n        );\n        newFee = fixedFee;\n        break;\n\n      case 'FRACTIONAL_FEE':\n        if (\n          feeData.numerator === undefined ||\n          feeData.denominator === undefined\n        ) {\n          throw new Error(\n            `Fee #${\n              index + 1\n            } (FRACTIONAL_FEE): numerator and denominator are required.`\n          );\n        }\n        const fractionalFee = new CustomFractionalFee()\n          .setFeeCollectorAccountId(feeCollectorAccountId)\n          .setNumerator(Long.fromValue(feeData.numerator))\n          .setDenominator(Long.fromValue(feeData.denominator));\n        if (feeData.minimumAmount) {\n          fractionalFee.setMin(\n            typeof feeData.minimumAmount === 'string'\n              ? Long.fromString(feeData.minimumAmount)\n              : Long.fromNumber(feeData.minimumAmount)\n          );\n        }\n        if (feeData.maximumAmount) {\n          fractionalFee.setMax(\n            typeof feeData.maximumAmount === 'string'\n              ? Long.fromString(feeData.maximumAmount)\n              : Long.fromNumber(feeData.maximumAmount)\n          );\n        }\n        if (\n          feeData.assessmentMethod === 'EXCLUSIVE' ||\n          feeData.netOfTransfers === true\n        ) {\n          fractionalFee.setAssessmentMethod(FeeAssessmentMethod.Exclusive);\n        } else {\n          fractionalFee.setAssessmentMethod(FeeAssessmentMethod.Inclusive);\n        }\n        newFee = fractionalFee;\n        break;\n\n      case 'ROYALTY_FEE':\n        if (\n          feeData.numerator === undefined ||\n          feeData.denominator === undefined\n        ) {\n          throw new Error(\n            `Fee #${\n              index + 1\n            } (ROYALTY_FEE): numerator and denominator are required.`\n          );\n        }\n        const royaltyFee = new CustomRoyaltyFee()\n          .setFeeCollectorAccountId(feeCollectorAccountId)\n          .setNumerator(Long.fromValue(feeData.numerator))\n          .setDenominator(Long.fromValue(feeData.denominator));\n        if (feeData.fallbackFee) {\n          if (\n            typeof feeData.fallbackFee !== 'object' ||\n            feeData.fallbackFee === null\n          ) {\n            throw new Error(\n              `Fee #${\n                index + 1\n              } (ROYALTY_FEE): fallbackFee must be an object if provided.`\n            );\n          }\n          const fallback = new CustomFixedFee().setFeeCollectorAccountId(\n            feeCollectorAccountId\n          );\n          if (feeData.fallbackFee.denominatingTokenId) {\n            fallback.setDenominatingTokenId(\n              TokenId.fromString(feeData.fallbackFee.denominatingTokenId)\n            );\n          }\n          if (\n            feeData.fallbackFee.amount === undefined ||\n            feeData.fallbackFee.amount === null\n          ) {\n            throw new Error(\n              `Fee #${index + 1} (ROYALTY_FEE): fallbackFee.amount is required.`\n            );\n          }\n          fallback.setAmount(\n            typeof feeData.fallbackFee.amount === 'string'\n              ? Long.fromString(feeData.fallbackFee.amount)\n              : Long.fromNumber(feeData.fallbackFee.amount)\n          );\n          royaltyFee.setFallbackFee(fallback);\n        }\n        newFee = royaltyFee;\n        break;\n\n      default:\n        throw new Error(\n          `Fee #${index + 1}: Unknown custom fee type: ${\n            feeData.feeType\n          }. Supported types are FIXED_FEE, FRACTIONAL_FEE, ROYALTY_FEE.`\n        );\n    }\n\n    if (\n      feeData.allCollectorsAreExempt &&\n      typeof feeData.allCollectorsAreExempt === 'boolean'\n    ) {\n      newFee.setAllCollectorsAreExempt(feeData.allCollectorsAreExempt);\n    }\n    return newFee;\n  });\n}\n"],"names":[],"mappings":"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"}