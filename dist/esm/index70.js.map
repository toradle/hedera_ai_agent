{"version":3,"file":"index70.js","sources":["../../src/builders/base-service-builder.ts"],"sourcesContent":["import {\n  AccountId,\n  Transaction,\n  TransactionId,\n  TransactionReceipt,\n  ScheduleCreateTransaction,\n  ScheduleId,\n  Key,\n  PublicKey,\n  PrivateKey,\n  KeyList,\n  Long,\n} from '@hashgraph/sdk';\nimport { Buffer } from 'buffer';\nimport { AbstractSigner } from '../signer/abstract-signer';\nimport { Logger } from '../utils/logger';\nimport { detectKeyTypeFromString } from '../utils/key-type-detector';\nimport type { HederaAgentKit } from '../agent/agent';\n\n/**\n * Defines the structure for the result of an execute operation.\n */\nexport interface ExecuteResult {\n  success: boolean;\n  receipt?: TransactionReceipt;\n  scheduleId?: ScheduleId | string | undefined;\n  error?: string;\n  transactionId?: string | undefined;\n}\n\n/**\n * BaseServiceBuilder provides common functionality for service-specific builders.\n * It manages the current transaction being built and offers common execution and byte generation methods.\n */\nexport abstract class BaseServiceBuilder {\n  protected currentTransaction: Transaction | null = null;\n  protected logger: Logger;\n  protected kit: HederaAgentKit;\n  protected notes: string[] = [];\n\n  /**\n   * @param {HederaAgentKit} kit - The HederaAgentKit instance\n   */\n  constructor(protected readonly hederaKit: HederaAgentKit) {\n    this.kit = hederaKit;\n\n    const shouldDisableLogs = process.env.DISABLE_LOGS === 'true';\n\n    this.logger = new Logger({\n      module: 'ServiceBuilder',\n      level: shouldDisableLogs ? 'silent' : 'info',\n      silent: shouldDisableLogs,\n    });\n  }\n\n  /**\n   * Helper method to get the effective sender account to use for transactions.\n   * In user-centric contexts, this will be the user's account. Otherwise, it falls back to the signer's account.\n   * @returns {AccountId} The account ID to use as sender\n   */\n  protected getEffectiveSenderAccountId(): AccountId {\n    if (this.kit.userAccountId) {\n      return AccountId.fromString(this.kit.userAccountId);\n    }\n    return this.kit.signer.getAccountId();\n  }\n\n  /**\n   * Helper method to determine if a transaction is a user-initiated transfer.\n   * Used for properly constructing transfer arrays.\n   * @param {boolean} isUserInitiated Whether this is a user-initiated transfer\n   * @returns {AccountId} The account that should be used as the sender\n   */\n  protected getTransferSourceAccount(\n    isUserInitiated: boolean = true\n  ): AccountId {\n    if (isUserInitiated && this.kit.userAccountId) {\n      return AccountId.fromString(this.kit.userAccountId);\n    }\n    return this.kit.signer.getAccountId();\n  }\n\n  /**\n   * @param {string} memo\n   * @returns {this}\n   * @throws {Error}\n   */\n  public setTransactionMemo(memo: string): this {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction is currently being built. Call a specific transaction method first (e.g., createTopic).'\n      );\n    }\n    this.currentTransaction.setTransactionMemo(memo);\n    return this;\n  }\n\n  /**\n   * @param {TransactionId} transactionId\n   * @returns {this}\n   * @throws {Error}\n   */\n  public setTransactionId(transactionId: TransactionId): this {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction is currently being built. Call a specific transaction method first.'\n      );\n    }\n    this.currentTransaction.setTransactionId(transactionId);\n    return this;\n  }\n\n  /**\n   * @param {AccountId[]} nodeAccountIds\n   * @returns {this}\n   * @throws {Error}\n   */\n  public setNodeAccountIds(nodeAccountIds: AccountId[]): this {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction is currently being built. Call a specific transaction method first.'\n      );\n    }\n    this.currentTransaction.setNodeAccountIds(nodeAccountIds);\n    return this;\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {boolean} [options.schedule]\n   * @param {string} [options.scheduleMemo]\n   * @param {string | AccountId} [options.schedulePayerAccountId]\n   * @returns {Promise<ExecuteResult>}\n   * @throws {Error}\n   */\n  public async execute(options?: {\n    schedule?: boolean;\n    scheduleMemo?: string;\n    schedulePayerAccountId?: string | AccountId;\n  }): Promise<ExecuteResult> {\n    const innerTx = this.currentTransaction;\n\n    if (!innerTx) {\n      return { success: false, error: 'No transaction to execute.' };\n    }\n\n    let transactionToExecute: Transaction = innerTx;\n    let originalTransactionIdForReporting = innerTx.transactionId?.toString();\n\n    if (options?.schedule) {\n      if (!innerTx.isFrozen() && this.kit.userAccountId) {\n        innerTx.setTransactionId(\n          TransactionId.generate(this.kit.userAccountId)\n        );\n      }\n\n      const scheduleCreateTx =\n        new ScheduleCreateTransaction().setScheduledTransaction(innerTx);\n\n      if (options.scheduleMemo) {\n        scheduleCreateTx.setScheduleMemo(options.scheduleMemo);\n      }\n\n      if (this.kit.userAccountId) {\n        scheduleCreateTx.setPayerAccountId(\n          AccountId.fromString(this.kit.userAccountId)\n        );\n      } else if (options.schedulePayerAccountId) {\n        const payerForScheduleCreate =\n          typeof options.schedulePayerAccountId === 'string'\n            ? AccountId.fromString(options.schedulePayerAccountId)\n            : options.schedulePayerAccountId;\n        scheduleCreateTx.setPayerAccountId(payerForScheduleCreate);\n      } else {\n        scheduleCreateTx.setPayerAccountId(this.kit.signer.getAccountId());\n        this.addNote(\n          `Your agent account (${this.kit.signer\n            .getAccountId()\n            .toString()}) will pay the fee to create this schedule.`\n        );\n      }\n\n      const agentOperator = await this.kit.getOperator();\n      const adminKeyList = new KeyList().setThreshold(1);\n      if (agentOperator.publicKey) {\n        adminKeyList.push(agentOperator.publicKey);\n        this.addNote(\n          `The schedule admin key allows both your agent and user (${this.kit.userAccountId}) to manage the schedule.`\n        );\n      }\n\n      if (this.kit.userAccountId) {\n        try {\n          const mirrorNode = this.kit.mirrorNode;\n          const userAccountInfo = await mirrorNode.requestAccount(\n            this.kit.userAccountId\n          );\n          if (userAccountInfo?.key?.key) {\n            adminKeyList.push(PublicKey.fromString(userAccountInfo.key.key));\n            this.addNote(\n              `The schedule admin key allows both your agent and user (${this.kit.userAccountId}) to manage the schedule.`\n            );\n          } else {\n            this.addNote(\n              `The schedule admin key is set to your agent. User (${this.kit.userAccountId}) key not found or not a single key.`\n            );\n          }\n        } catch (e) {\n          this.logger.warn(\n            `Failed to get user key for schedule admin key for ${\n              this.kit.userAccountId\n            }: ${(e as Error).message}`\n          );\n          this.addNote(\n            `The schedule admin key is set to your agent. Could not retrieve user (${this.kit.userAccountId}) key.`\n          );\n        }\n      }\n      if (Array.from(adminKeyList).length > 0) {\n        scheduleCreateTx.setAdminKey(adminKeyList);\n      } else {\n        this.addNote(\n          'No admin key could be set for the schedule (agent key missing and user key not found/retrieved).'\n        );\n      }\n\n      transactionToExecute = scheduleCreateTx;\n    }\n\n    try {\n      if (\n        !transactionToExecute.isFrozen() &&\n        !transactionToExecute.transactionId\n      ) {\n        await transactionToExecute.freezeWith(this.kit.client);\n      }\n      if (options?.schedule && transactionToExecute.transactionId) {\n        originalTransactionIdForReporting =\n          transactionToExecute.transactionId.toString();\n      }\n\n      const receipt = await this.kit.signer.signAndExecuteTransaction(\n        transactionToExecute\n      );\n      const finalTransactionId =\n        transactionToExecute.transactionId?.toString() ||\n        originalTransactionIdForReporting;\n\n      const result: ExecuteResult = {\n        success: true,\n        receipt: receipt,\n        transactionId: finalTransactionId,\n      };\n\n      if (options?.schedule && receipt.scheduleId) {\n        result.scheduleId = receipt.scheduleId.toString();\n      }\n      return result;\n    } catch (e: unknown) {\n      console.log('error is:', e);\n      const error = e as Error;\n      this.logger.error(\n        `Transaction execution failed: ${error.message}`,\n        error\n      );\n      const errorResult: ExecuteResult = {\n        success: false,\n        error:\n          error.message ||\n          'An unknown error occurred during transaction execution.',\n        transactionId: originalTransactionIdForReporting,\n      };\n      return errorResult;\n    }\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {boolean} [options.schedule]\n   * @param {string} [options.scheduleMemo]\n   * @param {string | AccountId} [options.schedulePayerAccountId]\n   * @param {Key} [options.scheduleAdminKey]\n   * @returns {Promise<string>}\n   * @throws {Error}\n   */\n  public async getTransactionBytes(options?: {\n    schedule?: boolean;\n    scheduleMemo?: string;\n    schedulePayerAccountId?: string | AccountId;\n    scheduleAdminKey?: Key;\n  }): Promise<string> {\n    if (!this.currentTransaction) {\n      throw new Error(\n        'No transaction to get bytes for. Call a specific transaction method first.'\n      );\n    }\n\n    let transactionForBytes: Transaction = this.currentTransaction;\n\n    if (options?.schedule) {\n      const scheduleCreateTx =\n        new ScheduleCreateTransaction().setScheduledTransaction(\n          this.currentTransaction\n        );\n\n      if (options.scheduleMemo) {\n        scheduleCreateTx.setScheduleMemo(options.scheduleMemo);\n      }\n      if (options.schedulePayerAccountId) {\n        const payerAccountId =\n          typeof options.schedulePayerAccountId === 'string'\n            ? AccountId.fromString(options.schedulePayerAccountId)\n            : options.schedulePayerAccountId;\n        scheduleCreateTx.setPayerAccountId(payerAccountId);\n      }\n      if (options.scheduleAdminKey) {\n        scheduleCreateTx.setAdminKey(options.scheduleAdminKey);\n      }\n      transactionForBytes = scheduleCreateTx;\n    }\n\n    return Buffer.from(transactionForBytes.toBytes()).toString('base64');\n  }\n\n  /**\n   * Executes the current transaction using a provided signer.\n   * This is useful if the transaction needs to be signed and paid for by a different account\n   * than the one initially configured with the HederaAgentKit/builder instance.\n   * Note: The transaction should ideally not be frozen, or if frozen, its transactionId\n   * should be compatible with the newSigner's accountId as the payer.\n   * @param {AbstractSigner} newSigner - The signer to use for this specific execution.\n   * @returns {Promise<ExecuteResult>}\n   * @throws {Error}\n   */\n  public async executeWithSigner(\n    newSigner: AbstractSigner\n  ): Promise<ExecuteResult> {\n    if (!this.currentTransaction) {\n      return {\n        success: false,\n        error:\n          'No transaction to execute. Call a specific transaction method first.',\n      };\n    }\n\n    let transactionToExecute = this.currentTransaction;\n\n    if (transactionToExecute.isFrozen()) {\n      throw new Error(\n        'Transaction is frozen, try to call the builder method again and then executeWithSigner.'\n      );\n    }\n\n    try {\n      const receipt = await newSigner.signAndExecuteTransaction(\n        transactionToExecute\n      );\n      const transactionId = transactionToExecute.transactionId?.toString();\n      return {\n        success: true,\n        receipt: receipt,\n        transactionId: transactionId,\n      };\n    } catch (e: unknown) {\n      const error = e as Error;\n      this.logger.error(\n        `Transaction execution with new signer failed: ${error.message}`\n      );\n      return {\n        success: false,\n        error:\n          error.message ||\n          'An unknown error occurred during transaction execution with new signer.',\n      };\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  protected setCurrentTransaction(transaction: Transaction): void {\n    this.currentTransaction = transaction;\n  }\n\n  /**\n   * Retrieves the current transaction object being built.\n   * @returns {Transaction | null} The current transaction or null.\n   */\n  public getCurrentTransaction(): Transaction | null {\n    return this.currentTransaction;\n  }\n\n  public addNote(note: string): void {\n    this.notes.push(note);\n  }\n\n  public getNotes(): string[] {\n    return this.notes;\n  }\n\n  public clearNotes(): void {\n    this.notes = [];\n  }\n\n  protected async parseKey(\n    keyInput?: string | PublicKey | Key | null\n  ): Promise<Key | undefined> {\n    if (keyInput === undefined || keyInput === null) {\n      return undefined;\n    }\n    if (\n      typeof keyInput === 'object' &&\n      ('_key' in keyInput ||\n        keyInput instanceof PublicKey ||\n        keyInput instanceof PrivateKey ||\n        keyInput instanceof KeyList)\n    ) {\n      return keyInput as Key;\n    }\n    if (typeof keyInput === 'string') {\n      if (keyInput.toLowerCase() === 'current_signer') {\n        if (this.kit.signer) {\n          this.logger.info(\n            `[BaseServiceBuilder.parseKey] Substituting \"current_signer\" with signer's public key.`\n          );\n          return await this.kit.signer.getPublicKey();\n        } else {\n          throw new Error(\n            '[BaseServiceBuilder.parseKey] Signer is not available to resolve \"current_signer\".'\n          );\n        }\n      }\n      try {\n        return PublicKey.fromString(keyInput);\n      } catch (e: unknown) {\n        const error = e as Error;\n        try {\n          this.logger.warn(\n            '[BaseServiceBuilder.parseKey] Attempting to parse key string as PrivateKey to derive PublicKey. This is generally not recommended for public-facing keys.',\n            { error: error.message }\n          );\n          const keyDetection = detectKeyTypeFromString(keyInput);\n          return keyDetection.privateKey;\n        } catch (e2: unknown) {\n          const error2 = e2 as Error;\n          this.logger.error(\n            `[BaseServiceBuilder.parseKey] Failed to parse key string as PublicKey or PrivateKey: ${keyInput.substring(\n              0,\n              30\n            )}...`,\n            { error: error2.message }\n          );\n          throw new Error(\n            `[BaseServiceBuilder.parseKey] Invalid key string format: ${keyInput.substring(\n              0,\n              30\n            )}...`\n          );\n        }\n      }\n    }\n    this.logger.warn(\n      `[BaseServiceBuilder.parseKey] Received an object that is not an SDK Key instance or a recognized string format: ${JSON.stringify(\n        keyInput\n      )}`\n    );\n    return undefined;\n  }\n\n  protected parseAmount(amount?: number | string | Long | BigNumber): Long {\n    if (amount === undefined) {\n      return Long.fromNumber(0);\n    }\n    if (typeof amount === 'number') {\n      return Long.fromNumber(amount);\n    }\n    if (typeof amount === 'string') {\n      return Long.fromString(amount);\n    }\n    if (amount instanceof BigNumber) {\n      return Long.fromString(amount.toString());\n    }\n    return amount;\n  }\n}\n"],"names":[],"mappings":"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"}