{"version":3,"file":"index5.js","sources":["../../src/signer/server-signer.ts"],"sourcesContent":["import {\n  AccountId,\n  Client,\n  PrivateKey,\n  Transaction,\n  TransactionResponse,\n  TransactionReceipt,\n} from '@hashgraph/sdk';\nimport { AbstractSigner } from './abstract-signer';\nimport { HederaNetworkType } from '../types';\nimport { Logger } from '../utils/logger';\nimport { detectKeyTypeFromString } from '../utils/key-type-detector';\n\n/**\n * A signer implementation for server-side environments that uses a private key for signing.\n * It directly interacts with the Hedera network using an operator-configured client.\n */\nexport class ServerSigner extends AbstractSigner {\n  private client: Client;\n  private accountIdInternal: AccountId;\n  private privateKey: PrivateKey;\n  private networkInternal: HederaNetworkType;\n  private keyType: 'ed25519' | 'ecdsa' = 'ed25519';\n  private logger: Logger;\n  private privateKeyString: string;\n  private keyTypeVerified: boolean = false;\n\n  /**\n   * Constructs a ServerSigner instance.\n   * @param {string | AccountId} accountId - The Hedera account ID.\n   * @param {string | PrivateKey} privateKey - The private key for the account.\n   * @param {HederaNetworkType} network - The Hedera network to connect to ('mainnet' or 'testnet').\n   */\n  constructor(\n    accountId: string | AccountId,\n    privateKey: string | PrivateKey,\n    network: HederaNetworkType\n  ) {\n    super();\n    this.accountIdInternal = AccountId.fromString(accountId.toString());\n    this.networkInternal = network;\n    this.logger = new Logger({\n      module: 'ServerSigner',\n      level: process.env.DEBUG === 'true' ? 'debug' : 'warn',\n    });\n\n    this.initializeMirrorNode(this.networkInternal, 'ServerSigner');\n\n    if (network === 'mainnet') {\n      this.client = Client.forMainnet();\n    } else if (network === 'testnet') {\n      this.client = Client.forTestnet();\n    } else {\n      throw new Error(\n        `Unsupported Hedera network type specified: ${network}. Only 'mainnet' or 'testnet' are supported.`\n      );\n    }\n\n    if (typeof privateKey === 'string') {\n      this.privateKeyString = privateKey;\n      try {\n        const keyDetection = detectKeyTypeFromString(privateKey);\n        this.privateKey = keyDetection.privateKey;\n        this.keyType = keyDetection.detectedType;\n        this.initializeOperator();\n        this.logger.debug(`Detected key type from string: ${this.keyType}`);\n      } catch (error: unknown) {\n        this.logger.warn(\n          'Failed to detect key type from private key format, will query mirror node',\n          (error as Error).message\n        );\n        this.privateKey = PrivateKey.fromStringED25519(privateKey);\n        this.keyType = 'ed25519';\n      }\n    } else {\n      this.privateKey = privateKey;\n      this.privateKeyString = privateKey.toString();\n    }\n\n    this.client.setOperator(this.accountIdInternal, this.privateKey);\n  }\n\n  /**\n   * Initializes the operator by verifying the key type against the mirror node.\n   * This follows the pattern from standards-sdk to ensure the correct key type is used.\n   */\n  private async initializeOperator(): Promise<void> {\n    try {\n      const account = await this.mirrorNode.requestAccount(\n        this.accountIdInternal.toString()\n      );\n      const keyType = account?.key?._type;\n\n      let actualKeyType: 'ed25519' | 'ecdsa' = 'ed25519';\n\n      if (keyType?.includes('ECDSA')) {\n        actualKeyType = 'ecdsa';\n      } else if (keyType?.includes('ED25519')) {\n        actualKeyType = 'ed25519';\n      }\n\n      if (actualKeyType !== this.keyType) {\n        this.logger.debug(\n          `Key type mismatch detected. String detection: ${this.keyType}, Mirror node: ${actualKeyType}. Using mirror node result.`\n        );\n\n        this.keyType = actualKeyType;\n\n        if (this.privateKeyString) {\n          this.privateKey =\n            actualKeyType === 'ecdsa'\n              ? PrivateKey.fromStringECDSA(this.privateKeyString)\n              : PrivateKey.fromStringED25519(this.privateKeyString);\n\n          this.client.setOperator(this.accountIdInternal, this.privateKey);\n\n          this.logger.debug(\n            `Updated operator with verified key type: ${this.keyType}`\n          );\n        }\n      } else {\n        this.logger.debug(`Key type verification successful: ${this.keyType}`);\n      }\n      this.keyTypeVerified = true;\n    } catch (error) {\n      this.logger.error(\n        `Failed to verify key type from mirror node: ${\n          (error as Error).message\n        }`\n      );\n      this.keyTypeVerified = true;\n    }\n  }\n\n  /**\n   * Retrieves the Hedera account ID associated with this signer.\n   * @returns {AccountId} The Hedera AccountId object.\n   */\n  public getAccountId(): AccountId {\n    return this.accountIdInternal;\n  }\n\n  /**\n   * Signs and executes a Hedera transaction using the configured client and private key,\n   * and returns the transaction receipt.\n   * @param {Transaction} transaction - The transaction to sign and execute.\n   * @returns {Promise<TransactionReceipt>} A promise that resolves to the transaction receipt.\n   */\n  public async signAndExecuteTransaction(\n    transaction: Transaction\n  ): Promise<TransactionReceipt> {\n    if (!transaction.isFrozen()) {\n      if (transaction.transactionId) {\n        await transaction.freezeWith(this.client);\n      } else {\n        await transaction.freezeWith(this.client);\n      }\n    }\n    if (transaction.getSignatures().size === 0) {\n      await transaction.sign(this.privateKey);\n    }\n    const response: TransactionResponse = await transaction.execute(\n      this.client\n    );\n    return response.getReceipt(this.client);\n  }\n\n  /**\n   * Retrieves the Hedera network type this signer is configured for.\n   * @returns {HederaNetworkType} The configured Hedera network type ('mainnet' or 'testnet').\n   */\n  public getNetwork(): HederaNetworkType {\n    return this.networkInternal;\n  }\n\n  /**\n   * Retrieves the operator's private key associated with this signer.\n   * @returns {PrivateKey} The Hedera PrivateKey object.\n   */\n  public getOperatorPrivateKey(): PrivateKey {\n    return this.privateKey;\n  }\n\n  /**\n   * Retrieves the client instance configured for this ServerSigner.\n   * @returns {Client} The Hedera Client object.\n   */\n  public getClient(): Client {\n    return this.client;\n  }\n\n  /**\n   * Retrieves the key type of the operator's private key.\n   * @returns {Promise<'ed25519' | 'ecdsa'>} The key type.\n   */\n  public async getKeyType(): Promise<'ed25519' | 'ecdsa'> {\n    if (!this.keyTypeVerified && this.privateKeyString) {\n      await this.initializeOperator();\n    }\n    return this.keyType;\n  }\n\n  /**\n   * Retrieves the key type synchronously (without mirror node verification).\n   * @returns {'ed25519' | 'ecdsa'} The key type.\n   */\n  public getKeyTypeSync(): 'ed25519' | 'ecdsa' {\n    return this.keyType;\n  }\n}\n"],"names":[],"mappings":"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"}