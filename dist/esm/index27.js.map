{"version":3,"file":"index27.js","sources":["../../src/langchain/tools/common/base-hedera-query-tool.ts"],"sourcesContent":["import { StructuredTool, ToolParams } from '@langchain/core/tools';\nimport { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';\nimport { z } from 'zod';\nimport { HederaAgentKit } from '../../../agent/agent';\nimport { ModelCapabilityDetector } from '../../../utils/model-capability-detector';\nimport { ModelCapability } from '../../../types/model-capability';\nimport { Logger } from '../../../utils/logger';\n\n/**\n * Field processing configuration\n */\nexport interface FieldProcessor {\n  maxLength?: number;\n  truncateMessage?: string;\n  summarize?: boolean;\n  exclude?: boolean;\n}\n\n/**\n * Response processing strategy\n */\nexport interface ResponseStrategy {\n  maxTokens: number;\n  summarizeArrays?: boolean;\n  maxArrayLength?: number;\n  includeMetadata?: boolean;\n}\n\n/**\n * Model-specific response strategies\n */\nconst MODEL_STRATEGIES: Record<ModelCapability, ResponseStrategy> = {\n  [ModelCapability.SMALL]: {\n    maxTokens: 4000,\n    summarizeArrays: true,\n    maxArrayLength: 3,\n    includeMetadata: true,\n  },\n  [ModelCapability.MEDIUM]: {\n    maxTokens: 12000,\n    summarizeArrays: false,\n    maxArrayLength: 10,\n    includeMetadata: true,\n  },\n  [ModelCapability.LARGE]: {\n    maxTokens: 32000,\n    summarizeArrays: false,\n    maxArrayLength: 50,\n    includeMetadata: false,\n  },\n  [ModelCapability.UNLIMITED]: {\n    maxTokens: Infinity,\n    summarizeArrays: false,\n    includeMetadata: false,\n  },\n};\n\n/**\n * Parameters required to initialize a BaseHederaQueryTool.\n */\nexport interface BaseHederaQueryToolParams extends ToolParams {\n  hederaKit: HederaAgentKit;\n  logger?: Logger;\n  modelCapability?: ModelCapability;\n  customStrategy?: Partial<ResponseStrategy>;\n}\n\n/**\n * Base class for all Hedera query tools.\n * Handles common query processing logic across different tool types.\n * Unlike transaction tools, query tools are read-only and don't require signing.\n *\n * @template S - The Zod schema that defines the input parameters for the specific tool\n */\nexport abstract class BaseHederaQueryTool<\n  //@ts-ignore\n  S extends z.ZodObject<unknown, unknown, unknown, unknown>\n  //@ts-ignore\n> extends StructuredTool<S> {\n  protected hederaKit: HederaAgentKit;\n  protected logger: Logger;\n  protected responseStrategy: ResponseStrategy;\n  protected modelCapability: ModelCapability;\n  private notes: string[] = [];\n\n  abstract specificInputSchema: S;\n  abstract namespace: string;\n\n  get schema(): S {\n    return this.specificInputSchema;\n  }\n\n  constructor({\n    hederaKit,\n    logger,\n    modelCapability = ModelCapability.MEDIUM,\n    customStrategy,\n    ...rest\n  }: BaseHederaQueryToolParams) {\n    super(rest);\n    this.hederaKit = hederaKit;\n    this.logger = logger || hederaKit.logger;\n    this.modelCapability = modelCapability;\n\n    const baseStrategy = MODEL_STRATEGIES[modelCapability];\n    this.responseStrategy = { ...baseStrategy, ...customStrategy };\n\n    this.logger.debug(\n      `Initialized query tool with ${modelCapability} capability strategy`\n    );\n  }\n\n  /**\n   * Execute the specific query operation.\n   * This method should be implemented by concrete query tools.\n   */\n  protected abstract executeQuery(\n    args: z.infer<S>,\n    runManager?: CallbackManagerForToolRun\n  ): Promise<unknown>;\n\n  /**\n   * Tools can define which fields should be processed for size optimization.\n   * Return a map of field paths to processing configurations.\n   * Field paths support dot notation (e.g., 'contract.bytecode') and wildcards (e.g., '*.bytecode')\n   */\n  protected getLargeFieldProcessors?(\n    args: z.infer<S>\n  ): Record<string, FieldProcessor>;\n\n  /**\n   * Allow tools to define custom response processing logic\n   */\n  protected processCustomResponse?(result: unknown, args: z.infer<S>): unknown;\n\n  /**\n   * Estimate token count (rough approximation: 1 token â‰ˆ 4 characters)\n   */\n  private estimateTokens(text: string): number {\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Check if a field path matches a pattern (supports wildcards)\n   */\n  private matchesPattern(fieldPath: string, pattern: string): boolean {\n    if (pattern === fieldPath) return true;\n    if (pattern.includes('*')) {\n      const regex = new RegExp('^' + pattern.replace(/\\*/g, '[^.]*') + '$');\n      return regex.test(fieldPath);\n    }\n    return false;\n  }\n\n  /**\n   * Process any data structure based on field processors and strategy\n   */\n  private processData(\n    data: unknown,\n    args: z.infer<S>,\n    path: string = ''\n  ): unknown {\n    if (this.responseStrategy.maxTokens === Infinity) {\n      return data;\n    }\n\n    const processors = this.getLargeFieldProcessors\n      ? this.getLargeFieldProcessors(args)\n      : {};\n\n    if (data === null || data === undefined) {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return this.processArray(data, args, path);\n    }\n\n    if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n      return this.processObject(\n        data as Record<string, unknown>,\n        args,\n        path,\n        processors\n      );\n    }\n\n    if (typeof data === 'string') {\n      return this.processString(data, path, processors);\n    }\n\n    return data;\n  }\n\n  /**\n   * Process array data\n   */\n  private processArray(\n    arr: unknown[],\n    args: z.infer<S>,\n    path: string\n  ): unknown[] {\n    const processedArray = arr.map((item, index) =>\n      this.processData(item, args, `${path}[${index}]`)\n    );\n\n    if (\n      this.responseStrategy.summarizeArrays &&\n      this.responseStrategy.maxArrayLength &&\n      arr.length > this.responseStrategy.maxArrayLength\n    ) {\n      const maxLength = this.responseStrategy.maxArrayLength;\n      const takeFirst = Math.floor(maxLength / 2);\n      const takeLast = maxLength - takeFirst - 1;\n\n      return [\n        ...processedArray.slice(0, takeFirst),\n        {\n          _summary: `[${arr.length - maxLength} items truncated]`,\n          _originalLength: arr.length,\n          _truncatedAt: path,\n        },\n        ...processedArray.slice(-takeLast),\n      ];\n    }\n\n    return processedArray;\n  }\n\n  /**\n   * Process object data\n   */\n  private processObject(\n    obj: Record<string, unknown>,\n    args: z.infer<S>,\n    path: string,\n    processors: Record<string, FieldProcessor>\n  ): Record<string, unknown> {\n    const result: Record<string, unknown> = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      const fieldPath = path ? `${path}.${key}` : key;\n\n      const matchingEntry = Object.entries(processors).find(([pattern]) =>\n        this.matchesPattern(fieldPath, pattern)\n      );\n      const matchingProcessor = matchingEntry ? matchingEntry[1] : undefined;\n\n      if (matchingProcessor && matchingProcessor.exclude) {\n        continue;\n      }\n\n      result[key] = this.processData(value, args, fieldPath);\n    }\n\n    return result;\n  }\n\n  /**\n   * Process string data\n   */\n  private processString(\n    str: string,\n    path: string,\n    processors: Record<string, FieldProcessor>\n  ): string {\n    const matchingEntry = Object.entries(processors).find(([pattern]) =>\n      this.matchesPattern(path, pattern)\n    );\n    const matchingProcessor = matchingEntry ? matchingEntry[1] : undefined;\n\n    if (\n      matchingProcessor &&\n      matchingProcessor.maxLength &&\n      str.length > matchingProcessor.maxLength\n    ) {\n      const truncated = str.substring(0, matchingProcessor.maxLength);\n      const message = matchingProcessor.truncateMessage\n        ? matchingProcessor.truncateMessage\n        : `[TRUNCATED: ${str.length} chars total]`;\n      return `${truncated}...${message}`;\n    }\n\n    return str;\n  }\n\n  /**\n   * Format the query result for return to the LLM.\n   * Override this method to customize result formatting.\n   */\n  protected formatResult(result: unknown, args?: z.infer<S>): string {\n    if (typeof result === 'string') {\n      return result;\n    }\n\n    let processedResult = result;\n\n    if (this.processCustomResponse && args) {\n      processedResult = this.processCustomResponse(processedResult, args);\n    }\n\n    processedResult = this.processData(\n      processedResult,\n      args || ({} as z.infer<S>)\n    );\n\n    const jsonString = JSON.stringify(processedResult, null, 2);\n    const estimatedTokens = this.estimateTokens(jsonString);\n\n    if (\n      this.responseStrategy.includeMetadata &&\n      estimatedTokens > this.responseStrategy.maxTokens * 0.8\n    ) {\n      const responseWithMeta = {\n        ...(typeof processedResult === 'object' && processedResult !== null\n          ? processedResult\n          : { data: processedResult }),\n        _meta: {\n          estimatedTokens,\n          maxTokens: this.responseStrategy.maxTokens,\n          capability: Object.keys(MODEL_STRATEGIES).find(\n            (key) =>\n              MODEL_STRATEGIES[key as ModelCapability] === this.responseStrategy\n          ),\n          note: 'Response may be truncated. Use higher model capability for full data.',\n        },\n      };\n      return JSON.stringify(responseWithMeta, null, 2);\n    }\n\n    return jsonString;\n  }\n\n  /**\n   * Handle errors that occur during query execution.\n   */\n  protected handleError(error: unknown): string {\n    const errorMessage =\n      error instanceof Error ? error.message : JSON.stringify(error);\n    this.logger.error(`Error in query tool: ${errorMessage}`, error);\n    return JSON.stringify({\n      success: false,\n      error: errorMessage,\n    });\n  }\n\n  /**\n   * Main method called when the tool is executed.\n   * Processes arguments, executes the query, and formats the result.\n   */\n  protected async _call(\n    args: z.infer<S>,\n    runManager?: CallbackManagerForToolRun\n  ): Promise<string> {\n    this.clearNotes();\n\n    try {\n      this.logger.info(\n        `Executing ${this.name} with model capability: ${this.modelCapability}`\n      );\n\n      const rawData = await this.executeQuery(args, runManager);\n      const processed = await this.processLargeFields(rawData, args);\n\n      const allNotes = this.getNotes();\n\n      if (\n        typeof processed.data === 'object' &&\n        processed.data !== null &&\n        'success' in processed.data\n      ) {\n        const toolResponse = processed.data as Record<string, unknown> & {\n          success: unknown;\n          notes?: string[];\n        };\n        const response = {\n          ...toolResponse,\n          ...(allNotes.length > 0 && {\n            notes: [...(toolResponse.notes || []), ...allNotes],\n          }),\n        };\n        return JSON.stringify(response);\n      }\n\n      const response = {\n        success: true,\n        data: processed.data,\n        ...(allNotes.length > 0 && { notes: allNotes }),\n      };\n\n      return JSON.stringify(response);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      this.logger.error(`Error in ${this.name}: ${errorMessage}`, error);\n\n      const allNotes = this.getNotes();\n      return JSON.stringify({\n        success: false,\n        error: errorMessage,\n        ...(allNotes.length > 0 && { notes: allNotes }),\n      });\n    }\n  }\n\n  private async getModelCapabilityLimits(): Promise<{\n    maxTokens: number;\n    arrayLimit: number;\n  }> {\n    if (this.modelCapability === ModelCapability.UNLIMITED) {\n      return { maxTokens: Infinity, arrayLimit: Infinity };\n    }\n\n    try {\n      const detector = ModelCapabilityDetector.getInstance();\n\n      if (this.hederaKit.modelName) {\n        const contextWindow = await detector.getContextWindow(\n          this.hederaKit.modelName\n        );\n        if (contextWindow > 0) {\n          const toolDefinitionsReserve = Math.floor(contextWindow * 0.6);\n          const responseReserve = Math.floor(contextWindow * 0.2);\n          const availableTokens =\n            contextWindow - toolDefinitionsReserve - responseReserve;\n          const arrayLimit = this.calculateArrayLimit(availableTokens);\n\n          return {\n            maxTokens: Math.max(availableTokens, 1000),\n            arrayLimit,\n          };\n        }\n      }\n\n      const allModels = await detector.getAllModels();\n      let maxContextWindow = 0;\n      for (const [, config] of Object.entries(allModels)) {\n        if (\n          config.capability === this.modelCapability &&\n          config.contextWindow > maxContextWindow\n        ) {\n          maxContextWindow = config.contextWindow;\n        }\n      }\n\n      if (maxContextWindow > 0) {\n        const toolDefinitionsReserve = Math.floor(maxContextWindow * 0.6);\n        const responseReserve = Math.floor(maxContextWindow * 0.2);\n        const availableTokens =\n          maxContextWindow - toolDefinitionsReserve - responseReserve;\n        const arrayLimit = this.calculateArrayLimit(availableTokens);\n\n        return {\n          maxTokens: Math.max(availableTokens, 1000),\n          arrayLimit,\n        };\n      }\n    } catch (error) {\n      this.logger.warn(\n        'Failed to get model context window, using fallback limits',\n        error\n      );\n    }\n\n    switch (this.modelCapability) {\n      case ModelCapability.SMALL:\n        return { maxTokens: 1000, arrayLimit: 3 };\n      case ModelCapability.MEDIUM:\n        return { maxTokens: 4000, arrayLimit: 10 };\n      case ModelCapability.LARGE:\n        return { maxTokens: 12000, arrayLimit: 30 };\n      default:\n        return { maxTokens: 4000, arrayLimit: 10 };\n    }\n  }\n\n  private calculateArrayLimit(availableTokens: number): number {\n    if (availableTokens < 8000) {\n      return 5;\n    }\n    if (availableTokens < 50000) {\n      return 20;\n    }\n    if (availableTokens < 100000) {\n      return 50;\n    }\n    return 100;\n  }\n\n  private addNote(note: string): void {\n    this.notes.push(note);\n  }\n\n  private clearNotes(): void {\n    this.notes = [];\n  }\n\n  private getNotes(): string[] {\n    return [...this.notes];\n  }\n\n  private async processLargeFields(\n    data: unknown,\n    args?: z.infer<S>\n  ): Promise<{ data: unknown; notes: string[] }> {\n    const result: { data: unknown; notes: string[] } = {\n      data: JSON.parse(JSON.stringify(data)),\n      notes: [],\n    };\n\n    if (this.modelCapability === ModelCapability.UNLIMITED) {\n      return result;\n    }\n\n    const processors =\n      this.getLargeFieldProcessors && args\n        ? this.getLargeFieldProcessors(args)\n        : {};\n    const limits = await this.getModelCapabilityLimits();\n\n    for (const [path, processorConfig] of Object.entries(processors)) {\n      const value = this.getNestedValue(result.data, path);\n      if (\n        typeof value === 'string' &&\n        processorConfig.maxLength &&\n        value.length > processorConfig.maxLength\n      ) {\n        const truncated = value.substring(0, processorConfig.maxLength);\n        this.setNestedValue(result.data, path, truncated);\n\n        const userFriendlyMessage = processorConfig.truncateMessage\n          ? processorConfig.truncateMessage\n          : `Large data field was shortened to fit your model's capacity`;\n        this.addNote(\n          `${userFriendlyMessage}. Original size: ${value.length} characters, shown: ${processorConfig.maxLength} characters.`\n        );\n      }\n    }\n\n    result.data = this.processDataStructure(result.data, limits, result.notes);\n    return result;\n  }\n\n  private processDataStructure(\n    data: unknown,\n    limits: { maxTokens: number; arrayLimit: number },\n    notes: string[]\n  ): unknown {\n    if (Array.isArray(data)) {\n      if (data.length > limits.arrayLimit) {\n        const truncated = data.slice(0, limits.arrayLimit);\n        this.addNote(\n          `List was shortened to fit your model's capacity. Showing ${limits.arrayLimit} of ${data.length} items.`\n        );\n        return truncated.map((item) =>\n          this.processDataStructure(item, limits, notes)\n        );\n      }\n      return data.map((item) => this.processDataStructure(item, limits, notes));\n    }\n\n    if (data && typeof data === 'object' && !Array.isArray(data)) {\n      const processed: Record<string, unknown> = {};\n      for (const [key, value] of Object.entries(\n        data as Record<string, unknown>\n      )) {\n        processed[key] = this.processDataStructure(value, limits, notes);\n      }\n      return processed;\n    }\n\n    return data;\n  }\n\n  private getNestedValue(obj: unknown, path: string): unknown {\n    return path.split('.').reduce((current, key) => {\n      if (!current || typeof current !== 'object') {\n        return undefined;\n      }\n\n      const currentObj = current as Record<string, unknown>;\n\n      if (key.includes('[') && key.includes(']')) {\n        const [arrayKey, indexStr] = key.split('[');\n        const index = parseInt(indexStr.replace(']', ''));\n        const arrayValue = currentObj[arrayKey];\n        return Array.isArray(arrayValue) ? arrayValue[index] : undefined;\n      }\n\n      return currentObj[key];\n    }, obj);\n  }\n\n  private setNestedValue(obj: unknown, path: string, value: unknown): void {\n    if (!obj || typeof obj !== 'object') {\n      return;\n    }\n\n    const keys = path.split('.');\n    const lastKey = keys.pop()!;\n    const target = keys.reduce((current, key) => {\n      if (!current || typeof current !== 'object') {\n        return current;\n      }\n\n      const currentObj = current as Record<string, unknown>;\n\n      if (key.includes('[') && key.includes(']')) {\n        const [arrayKey, indexStr] = key.split('[');\n        const index = parseInt(indexStr.replace(']', ''));\n        const arrayValue = currentObj[arrayKey];\n        return Array.isArray(arrayValue) ? arrayValue[index] : undefined;\n      }\n\n      return currentObj[key];\n    }, obj);\n\n    if (!target || typeof target !== 'object') {\n      return;\n    }\n\n    const targetObj = target as Record<string, unknown>;\n\n    if (lastKey.includes('[') && lastKey.includes(']')) {\n      const [arrayKey, indexStr] = lastKey.split('[');\n      const index = parseInt(indexStr.replace(']', ''));\n      const arrayValue = targetObj[arrayKey];\n      if (Array.isArray(arrayValue)) {\n        arrayValue[index] = value;\n      }\n    } else {\n      targetObj[lastKey] = value;\n    }\n  }\n}\n"],"names":["response"],"mappings":"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"}