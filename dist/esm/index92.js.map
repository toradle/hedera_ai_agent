{"version":3,"file":"index92.js","sources":["../../src/services/mirror-node/mirror-node.ts"],"sourcesContent":["import { PublicKey, Timestamp, AccountId } from '@hashgraph/sdk';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport { Logger } from '../../utils/logger';\nimport { proto } from '@hashgraph/proto';\nimport {\n  AccountResponse,\n  CustomFees,\n  HBARPrice,\n  ScheduleInfo,\n  TokenInfoResponse,\n  TopicMessagesResponse,\n  TopicResponse,\n  Transaction as HederaTransaction,\n  AccountTokenBalance,\n  AccountTokensResponse,\n  NftDetail,\n  AccountNftsResponse,\n  ContractCallQueryResponse,\n  TokenAirdrop,\n  TokenAirdropsResponse,\n  Block,\n  BlocksResponse,\n  ContractResult,\n  ContractResultsResponse,\n  ContractLog,\n  ContractLogsResponse,\n  ContractAction,\n  ContractActionsResponse,\n  ContractEntity,\n  ContractsResponse,\n  ContractState,\n  ContractStateResponse,\n  NftInfo,\n  NftsResponse,\n  NetworkInfo,\n  NetworkFees,\n  NetworkSupply,\n  NetworkStake,\n  OpcodesResponse,\n  HCSMessage,\n} from './types';\nimport { HederaNetworkType } from '../../types';\n\n/**\n * Configuration for retry attempts.\n */\nexport interface RetryConfig {\n  maxRetries?: number;\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  backoffFactor?: number;\n}\n\n/**\n * Configuration for custom mirror node providers.\n *\n * @example\n * // Using HGraph with API key in URL\n * const config = {\n *   customUrl: 'https://mainnet.hedera.api.hgraph.dev/v1/<API-KEY>',\n *   apiKey: 'your-api-key-here'\n * };\n *\n * @example\n * // Using custom provider with API key in headers\n * const config = {\n *   customUrl: 'https://custom-mirror-node.com',\n *   apiKey: 'your-api-key',\n *   headers: {\n *     'X-Custom-Header': 'value'\n *   }\n * };\n */\nexport interface MirrorNodeConfig {\n  /** Custom mirror node URL. Can include <API-KEY> placeholder for URL-based API keys. */\n  customUrl?: string;\n  /** API key for authentication. Will be used in both Authorization header and URL replacement. */\n  apiKey?: string;\n  /** Additional custom headers to include with requests. */\n  headers?: Record<string, string>;\n}\n\nexport class HederaMirrorNode {\n  private network: HederaNetworkType;\n  private baseUrl: string;\n  private logger: Logger;\n  private isServerEnvironment: boolean;\n  private apiKey?: string;\n  private customHeaders: Record<string, string>;\n\n  private maxRetries: number = 5;\n  private initialDelayMs: number = 2000;\n  private maxDelayMs: number = 30000;\n  private backoffFactor: number = 2;\n\n  constructor(\n    network: HederaNetworkType,\n    logger?: Logger,\n    config?: MirrorNodeConfig\n  ) {\n    this.network = network;\n    if (config?.apiKey) {\n      this.apiKey = config.apiKey;\n    }\n    this.customHeaders = config?.headers || {};\n    this.baseUrl = config?.customUrl || this.getMirrorNodeUrl();\n    this.logger =\n      logger ||\n      new Logger({\n        level: 'debug',\n        module: 'MirrorNode',\n      });\n    this.isServerEnvironment = typeof window === 'undefined';\n\n    if (config?.customUrl) {\n      this.logger.info(`Using custom mirror node URL: ${config.customUrl}`);\n    }\n    if (config?.apiKey) {\n      this.logger.info('Using API key for mirror node requests');\n    }\n  }\n\n  /**\n   * Configures the retry mechanism for API requests.\n   * @param config The retry configuration.\n   */\n  public configureRetry(config: RetryConfig): void {\n    this.maxRetries = config.maxRetries ?? this.maxRetries;\n    this.initialDelayMs = config.initialDelayMs ?? this.initialDelayMs;\n    this.maxDelayMs = config.maxDelayMs ?? this.maxDelayMs;\n    this.backoffFactor = config.backoffFactor ?? this.backoffFactor;\n    this.logger.info(\n      `Retry configuration updated: maxRetries=${this.maxRetries}, initialDelayMs=${this.initialDelayMs}, maxDelayMs=${this.maxDelayMs}, backoffFactor=${this.backoffFactor}`\n    );\n  }\n\n  /**\n   * Updates the mirror node configuration.\n   * @param config The new mirror node configuration.\n   */\n  public configureMirrorNode(config: MirrorNodeConfig): void {\n    if (config.customUrl) {\n      this.baseUrl = config.customUrl;\n      this.logger.info(`Updated mirror node URL: ${config.customUrl}`);\n    }\n    if (config.apiKey) {\n      this.apiKey = config.apiKey;\n      this.logger.info('Updated API key for mirror node requests');\n    }\n    if (config.headers) {\n      this.customHeaders = { ...this.customHeaders, ...config.headers };\n      this.logger.info('Updated custom headers for mirror node requests');\n    }\n  }\n\n  /**\n   * Constructs a full URL for API requests, handling custom providers with API keys in the path.\n   * @param endpoint The API endpoint (e.g., '/api/v1/accounts/0.0.123')\n   * @returns The full URL for the request\n   */\n  private constructUrl(endpoint: string): string {\n    if (this.baseUrl.includes('<API-KEY>') && this.apiKey) {\n      const baseUrlWithKey = this.baseUrl.replace('<API-KEY>', this.apiKey);\n      return endpoint.startsWith('/')\n        ? `${baseUrlWithKey}${endpoint}`\n        : `${baseUrlWithKey}/${endpoint}`;\n    }\n    return endpoint.startsWith('/')\n      ? `${this.baseUrl}${endpoint}`\n      : `${this.baseUrl}/${endpoint}`;\n  }\n\n  /**\n   * Returns the base URL for the Hedera mirror node based on the network type\n   * @returns The mirror node base URL\n   * @private\n   */\n  private getMirrorNodeUrl(): string {\n    return this.network === 'mainnet'\n      ? 'https://mainnet-public.mirrornode.hedera.com'\n      : 'https://testnet.mirrornode.hedera.com';\n  }\n\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  /**\n   * Retrieves the public key for a given account ID from the mirror node.\n   * @param accountId The ID of the account to retrieve the public key for.\n   * @returns A promise that resolves to the public key for the given account.\n   * @throws An error if the account ID is invalid or the public key cannot be retrieved.\n   */\n  async getPublicKey(accountId: string): Promise<PublicKey> {\n    this.logger.info(`Getting public key for account ${accountId}`);\n\n    const accountInfo = await this.requestAccount(accountId);\n\n    try {\n      if (!accountInfo || !accountInfo.key) {\n        throw new Error(\n          `Failed to retrieve public key for account ID: ${accountId}`\n        );\n      }\n\n      return PublicKey.fromString(accountInfo.key.key);\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error fetching public key from Mirror Node: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Retrieves the memo for a given account ID from the mirror node.\n   * @param accountId The ID of the account to retrieve the memo for.\n   * @returns A promise that resolves to the memo for the given account.\n   * @throws An error if the account ID is invalid or the memo cannot be retrieved.\n   */\n  async getAccountMemo(accountId: string): Promise<string | null> {\n    this.logger.info(`Getting account memo for account ID: ${accountId}`);\n\n    try {\n      const accountInfo = await this._requestWithRetry<AccountResponse>(\n        `/api/v1/accounts/${accountId}`\n      );\n\n      if (accountInfo?.memo) {\n        return accountInfo.memo;\n      }\n      this.logger.warn(`No memo found for account ${accountId}`);\n      return null;\n    } catch (e: any) {\n      const error = e as Error;\n      this.logger.error(\n        `Failed to get account memo for ${accountId} after retries: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves topic information for a given topic ID from the mirror node.\n   * @param topicId The ID of the topic to retrieve information for.\n   * @returns A promise that resolves to the topic information.\n   * @throws An error if the topic ID is invalid or the information cannot be retrieved.\n   */\n  async getTopicInfo(topicId: string): Promise<TopicResponse> {\n    try {\n      this.logger.debug(`Fetching topic info for ${topicId}`);\n      const data = await this._requestWithRetry<TopicResponse>(\n        `/api/v1/topics/${topicId}`\n      );\n      return data;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error retrieving topic information for ${topicId} after retries: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Retrieves custom fees for a given topic ID from the mirror node.\n   * @param topicId The ID of the topic to retrieve custom fees for.\n   * @returns A promise that resolves to the custom fees for the given topic.\n   * @throws An error if the topic ID is invalid or the custom fees cannot be retrieved.\n   */\n  async getTopicFees(topicId: string): Promise<CustomFees | null> {\n    try {\n      const topicInfo = await this.getTopicInfo(topicId);\n      return topicInfo.custom_fees;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error retrieving topic fees: ${error.message}`;\n      this.logger.error(logMessage);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves the current HBAR price from the mirror node.\n   * @param date The date to retrieve the HBAR price for.\n   * @returns A promise that resolves to the HBAR price for the given date.\n   * @throws An error if the date is invalid or the price cannot be retrieved.\n   */\n  async getHBARPrice(date: Date): Promise<number | null> {\n    try {\n      const timestamp = Timestamp.fromDate(date).toString();\n      this.logger.debug(`Fetching HBAR price for timestamp ${timestamp}`);\n\n      const response = await this._requestWithRetry<HBARPrice>(\n        `/api/v1/network/exchangerate?timestamp=${timestamp}`\n      );\n\n      const usdPrice =\n        Number(response?.current_rate?.cent_equivalent) /\n        Number(response?.current_rate?.hbar_equivalent) /\n        100;\n\n      return usdPrice;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error retrieving HBAR price: ${error.message}`;\n      this.logger.error(logMessage);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves token information for a given token ID from the mirror node.\n   * @param tokenId The ID of the token to retrieve information for.\n   * @returns A promise that resolves to the token information.\n   * @throws An error if the token ID is invalid or the information cannot be retrieved.\n   */\n  async getTokenInfo(tokenId: string): Promise<TokenInfoResponse | null> {\n    this.logger.debug(`Fetching token info for ${tokenId}`);\n    try {\n      const data = await this._requestWithRetry<TokenInfoResponse>(\n        `/api/v1/tokens/${tokenId}`\n      );\n      if (data) {\n        this.logger.trace(`Token info found for ${tokenId}:`, data);\n        return data;\n      }\n      this.logger.warn(`No token info found for ${tokenId}`);\n      return null;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error fetching token info for ${tokenId}: ${error.message}`;\n      this.logger.error(logMessage);\n\n      return null;\n    }\n  }\n  /**\n   * Retrieves messages for a given topic ID from the mirror node. Supports filtering by sequence number\n   * based on the OpenAPI specification.\n   * @param topicId The ID of the topic to retrieve messages for.\n   * @param options Optional filtering parameters.\n   * @returns A promise that resolves to the messages for the given topic.\n   */\n  async getTopicMessages(\n    topicId: string,\n    options?: {\n      sequenceNumber?: string | number;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<HCSMessage[]> {\n    this.logger.trace(\n      `Querying messages for topic ${topicId}${options ? ' with filters' : ''}`\n    );\n\n    let endpoint = `/api/v1/topics/${topicId}/messages`;\n    const params = new URLSearchParams();\n\n    if (options) {\n      if (options.sequenceNumber !== undefined) {\n        const seqNum =\n          typeof options.sequenceNumber === 'number'\n            ? options.sequenceNumber.toString()\n            : options.sequenceNumber;\n\n        if (!seqNum.match(/^(gt|gte|lt|lte|eq|ne):/)) {\n          params.append('sequencenumber', `gt:${seqNum}`);\n        } else {\n          params.append('sequencenumber', seqNum);\n        }\n      }\n\n      if (options.limit) {\n        params.append('limit', options.limit.toString());\n      }\n\n      if (options.order) {\n        params.append('order', options.order);\n      }\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    const messages: HCSMessage[] = [];\n    let nextEndpoint = endpoint;\n\n    while (nextEndpoint) {\n      try {\n        const data = await this._requestWithRetry<TopicMessagesResponse>(\n          nextEndpoint\n        );\n\n        if (data.messages && data.messages.length > 0) {\n          for (const message of data.messages) {\n            try {\n              if (!message.message) {\n                continue;\n              }\n\n              let messageContent: string;\n              try {\n                if (this.isServerEnvironment) {\n                  messageContent = Buffer.from(\n                    message.message,\n                    'base64'\n                  ).toString('utf-8');\n                } else {\n                  messageContent = new TextDecoder().decode(\n                    Uint8Array.from(atob(message.message), (c) =>\n                      c.charCodeAt(0)\n                    )\n                  );\n                }\n              } catch (error) {\n                const logMessage = `Error decoding message: ${error}`;\n                this.logger.error(logMessage);\n                continue;\n              }\n\n              let messageJson;\n              try {\n                messageJson = JSON.parse(messageContent);\n              } catch {\n                const logMessage = `Invalid JSON message content: ${messageContent}`;\n                this.logger.error(logMessage);\n                continue;\n              }\n\n              messageJson.sequence_number = message.sequence_number;\n              messages.push({\n                ...messageJson,\n                consensus_timestamp: message.consensus_timestamp,\n                sequence_number: message.sequence_number,\n                created: new Date(Number(message.consensus_timestamp) * 1000),\n              });\n            } catch (error: any) {\n              const logMessage = `Error processing message: ${error.message}`;\n              this.logger.error(logMessage);\n            }\n          }\n        }\n\n        nextEndpoint = data.links?.next || '';\n      } catch (e: any) {\n        const error = e as Error;\n        const logMessage = `Error querying topic messages for topic ${topicId} (endpoint: ${nextEndpoint}) after retries: ${error.message}`;\n        this.logger.error(logMessage);\n        throw new Error(logMessage);\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Requests account information for a given account ID from the mirror node.\n   * @param accountId The ID of the account to retrieve information for.\n   * @returns A promise that resolves to the account information.\n   * @throws An error if the account ID is invalid or the information cannot be retrieved.\n   */\n  async requestAccount(accountId: string): Promise<AccountResponse> {\n    try {\n      this.logger.debug(`Requesting account info for ${accountId}`);\n      const data = await this._requestWithRetry<AccountResponse>(\n        `/api/v1/accounts/${accountId}`\n      );\n      if (!data) {\n        throw new Error(\n          `No data received from mirror node for account: ${accountId}`\n        );\n      }\n      return data;\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Failed to fetch account ${accountId} after retries: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Checks if a user has access to a given key list.\n   * @param keyBytes The key list to check access for.\n   * @param userPublicKey The public key of the user to check access for.\n   * @returns A promise that resolves to true if the user has access, false otherwise.\n   */\n  async checkKeyListAccess(\n    keyBytes: Buffer,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    try {\n      const key = proto.Key.decode(keyBytes);\n      return this.evaluateKeyAccess(key, userPublicKey);\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error decoding protobuf key: ${error.message}`;\n      this.logger.error(logMessage);\n      throw new Error(logMessage);\n    }\n  }\n\n  /**\n   * Evaluates the access of a given key to a user's public key.\n   * @param key The key to evaluate access for.\n   * @param userPublicKey The public key of the user to evaluate access for.\n   * @returns A promise that resolves to true if the key has access, false otherwise.\n   */\n  private async evaluateKeyAccess(\n    key: proto.IKey,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    if (key.ed25519) {\n      return this.compareEd25519Key(key.ed25519, userPublicKey);\n    }\n\n    if (key.keyList) {\n      return this.evaluateKeyList(key.keyList, userPublicKey);\n    }\n\n    if (key.thresholdKey && key.thresholdKey.keys) {\n      return this.evaluateKeyList(key.thresholdKey.keys, userPublicKey);\n    }\n\n    return false;\n  }\n\n  /**\n   * Evaluates the access of a given key list to a user's public key.\n   * @param keyList The key list to evaluate access for.\n   * @param userPublicKey The public key of the user to evaluate access for.\n   * @returns A promise that resolves to true if the key list has access, false otherwise.\n   */\n  private async evaluateKeyList(\n    keyList: proto.IKeyList,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    const keys = keyList.keys || [];\n\n    for (const listKey of keys) {\n      if (!listKey) continue;\n\n      if (listKey.ed25519) {\n        if (this.compareEd25519Key(listKey.ed25519, userPublicKey)) {\n          return true;\n        }\n      } else if (listKey.keyList || listKey.thresholdKey) {\n        try {\n          const nestedKeyBytes = proto.Key.encode({\n            ...(listKey.keyList ? { keyList: listKey.keyList } : {}),\n            ...(listKey.thresholdKey\n              ? { thresholdKey: listKey.thresholdKey }\n              : {}),\n          }).finish();\n\n          const hasNestedAccess = await this.checkKeyListAccess(\n            Buffer.from(nestedKeyBytes),\n            userPublicKey\n          );\n\n          if (hasNestedAccess) {\n            return true;\n          }\n        } catch (e: any) {\n          const error = e as Error;\n          const logMessage = `Error in nested key: ${error.message}`;\n          this.logger.debug(logMessage);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Compares an Ed25519 key with a user's public key.\n   * @param keyData The Ed25519 key data to compare.\n   * @param userPublicKey The public key of the user to compare with.\n   * @returns A boolean indicating whether the key matches the user's public key.\n   */\n  private compareEd25519Key(\n    keyData: Uint8Array,\n    userPublicKey: PublicKey\n  ): boolean {\n    try {\n      const decodedKey = PublicKey.fromBytes(Buffer.from(keyData));\n      return decodedKey.toString() === userPublicKey.toString();\n    } catch (e: any) {\n      const error = e as Error;\n      const logMessage = `Error comparing Ed25519 key: ${error.message}`;\n      this.logger.debug(logMessage);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves information about a scheduled transaction\n   * @param scheduleId The ID of the scheduled transaction\n   * @returns A promise that resolves to the scheduled transaction information\n   */\n  async getScheduleInfo(scheduleId: string): Promise<ScheduleInfo | null> {\n    try {\n      this.logger.info(\n        `Getting information for scheduled transaction ${scheduleId}`\n      );\n\n      const data = await this._requestWithRetry<ScheduleInfo>(\n        `/api/v1/schedules/${scheduleId}`\n      );\n\n      if (data) {\n        return data;\n      }\n\n      this.logger.warn(\n        `No schedule info found for ${scheduleId} after retries.`\n      );\n      return null;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching schedule info for ${scheduleId} after retries: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Checks the status of a scheduled transaction\n   * @param scheduleId The schedule ID to check\n   * @returns Status of the scheduled transaction\n   */\n  public async getScheduledTransactionStatus(scheduleId: string): Promise<{\n    executed: boolean;\n    executedDate: Date | undefined;\n    deleted: boolean;\n  }> {\n    try {\n      this.logger.info(\n        `Checking status of scheduled transaction ${scheduleId}`\n      );\n\n      const scheduleInfo = await this.getScheduleInfo(scheduleId);\n\n      if (!scheduleInfo) {\n        throw new Error(`Schedule ${scheduleId} not found`);\n      }\n\n      return {\n        executed: Boolean(scheduleInfo.executed_timestamp),\n        executedDate: scheduleInfo.executed_timestamp\n          ? new Date(Number(scheduleInfo.executed_timestamp) * 1000)\n          : undefined,\n        deleted: scheduleInfo.deleted || false,\n      };\n    } catch (error) {\n      this.logger.error(\n        `Error checking scheduled transaction status: ${error}`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves details for a given transaction ID or hash from the mirror node.\n   * @param transactionIdOrHash The ID or hash of the transaction.\n   * @returns A promise that resolves to the transaction details.\n   * @throws An error if the transaction ID/hash is invalid or details cannot be retrieved.\n   */\n  async getTransaction(\n    transactionIdOrHash: string\n  ): Promise<HederaTransaction | null> {\n    this.logger.info(\n      `Getting transaction details for ID/hash: ${transactionIdOrHash}`\n    );\n\n    try {\n      const response = await this._requestWithRetry<{\n        transactions: HederaTransaction[];\n      }>(`/api/v1/transactions/${transactionIdOrHash}`);\n\n      if (response?.transactions?.length > 0) {\n        this.logger.trace(\n          `Transaction details found for ${transactionIdOrHash}:`,\n          response.transactions[0]\n        );\n        return response.transactions[0];\n      }\n\n      this.logger.warn(\n        `No transaction details found for ${transactionIdOrHash} or unexpected response structure.`\n      );\n      return null;\n    } catch (e: any) {\n      const error = e as Error;\n      this.logger.error(\n        `Failed to get transaction details for ${transactionIdOrHash} after retries: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Private helper to make GET requests with retry logic using Axios.\n   */\n  private async _requestWithRetry<T>(\n    endpoint: string,\n    axiosConfig?: AxiosRequestConfig\n  ): Promise<T> {\n    let attempt = 0;\n    let delay = this.initialDelayMs;\n    const url = this.constructUrl(endpoint);\n\n    const config: AxiosRequestConfig = {\n      ...axiosConfig,\n      headers: {\n        ...this.customHeaders,\n        ...axiosConfig?.headers,\n      },\n    };\n\n    if (this.apiKey) {\n      config.headers = {\n        ...config.headers,\n        Authorization: `Bearer ${this.apiKey}`,\n        'X-API-Key': this.apiKey,\n      };\n    }\n\n    while (attempt < this.maxRetries) {\n      try {\n        const response = await axios.get<T>(url, config);\n        return response.data;\n      } catch (error: any) {\n        attempt++;\n        const isLastAttempt = attempt >= this.maxRetries;\n        const statusCode = error.response?.status;\n\n        if (\n          statusCode &&\n          statusCode > 404 &&\n          statusCode < 500 &&\n          statusCode !== 429\n        ) {\n          this.logger.error(\n            `Client error for ${url} (status ${statusCode}): ${error.message}. Not retrying.`\n          );\n          throw error;\n        }\n\n        if (isLastAttempt) {\n          this.logger.error(\n            `Max retries (${this.maxRetries}) reached for ${url}. Last error: ${error.message}`\n          );\n          throw error;\n        }\n\n        this.logger.warn(\n          `Attempt ${attempt}/${this.maxRetries} failed for ${url}: ${error.message}. Retrying in ${delay}ms...`\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        delay = Math.min(delay * this.backoffFactor, this.maxDelayMs);\n      }\n    }\n\n    throw new Error(\n      `Failed to fetch data from ${url} after ${this.maxRetries} attempts.`\n    );\n  }\n\n  /**\n   * Private helper to make fetch requests with retry logic.\n   */\n  private async _fetchWithRetry<T>(\n    url: string,\n    fetchOptions?: RequestInit\n  ): Promise<T> {\n    let attempt = 0;\n    let delay = this.initialDelayMs;\n\n    const headers: Record<string, string> = {\n      ...this.customHeaders,\n    };\n\n    if (fetchOptions?.headers) {\n      if (fetchOptions.headers instanceof Headers) {\n        fetchOptions.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (Array.isArray(fetchOptions.headers)) {\n        fetchOptions.headers.forEach(([key, value]) => {\n          headers[key] = value;\n        });\n      } else {\n        Object.assign(headers, fetchOptions.headers);\n      }\n    }\n\n    if (this.apiKey) {\n      headers['Authorization'] = `Bearer ${this.apiKey}`;\n      headers['X-API-Key'] = this.apiKey;\n    }\n\n    const options: RequestInit = {\n      ...fetchOptions,\n      headers,\n    };\n\n    while (attempt < this.maxRetries) {\n      try {\n        const request = await fetch(url, options);\n        if (!request.ok) {\n          if (\n            request.status >= 400 &&\n            request.status < 500 &&\n            request.status !== 429\n          ) {\n            this.logger.error(\n              `Client error for ${url} (status ${request.status}): ${request.statusText}. Not retrying.`\n            );\n            throw new Error(\n              `Fetch failed with status ${request.status}: ${request.statusText} for URL: ${url}`\n            );\n          }\n          throw new Error(\n            `Fetch failed with status ${request.status}: ${request.statusText} for URL: ${url}`\n          );\n        }\n        const response = (await request.json()) as T;\n        return response;\n      } catch (error: any) {\n        attempt++;\n        if (attempt >= this.maxRetries) {\n          this.logger.error(\n            `Max retries (${this.maxRetries}) reached for ${url}. Last error: ${error.message}`\n          );\n          throw error;\n        }\n        this.logger.warn(\n          `Attempt ${attempt}/${this.maxRetries} failed for ${url}: ${error.message}. Retrying in ${delay}ms...`\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        delay = Math.min(delay * this.backoffFactor, this.maxDelayMs);\n      }\n    }\n    throw new Error(\n      `Failed to fetch data from ${url} after ${this.maxRetries} attempts.`\n    );\n  }\n\n  /**\n   * Retrieves the numerical balance (in HBAR) for a given account ID.\n   * @param accountId The ID of the account.\n   * @returns A promise that resolves to the HBAR balance or null if an error occurs.\n   */\n  async getAccountBalance(accountId: string): Promise<number | null> {\n    this.logger.info(`Getting balance for account ${accountId}`);\n    try {\n      const accountInfo = await this.requestAccount(accountId);\n      if (accountInfo && accountInfo.balance) {\n        const hbarBalance = accountInfo.balance.balance / 100_000_000;\n        return hbarBalance;\n      }\n      this.logger.warn(\n        `Could not retrieve balance for account ${accountId} from account info.`\n      );\n      return null;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching numerical balance for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves messages for a given topic ID with optional filters.\n   * @param topicId The ID of the topic.\n   * @param sequenceNumber Filter by sequence number (e.g., \"gt:10\", \"lte:20\").\n   * @param startTime Filter by consensus timestamp (e.g., \"gt:1629400000.000000000\").\n   * @param endTime Filter by consensus timestamp (e.g., \"lt:1629500000.000000000\").\n   * @param limit The maximum number of messages to return.\n   * @returns A promise that resolves to an array of HCSMessages or null.\n   */\n  async getTopicMessagesByFilter(\n    topicId: string,\n    options?: {\n      sequenceNumber?: string;\n      startTime?: string;\n      endTime?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<HCSMessage[] | null> {\n    this.logger.trace(\n      `Querying messages for topic ${topicId} with filters: ${JSON.stringify(\n        options\n      )}`\n    );\n\n    let nextUrl = `/api/v1/topics/${topicId}/messages`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.sequenceNumber) {\n      params.append('sequencenumber', options.sequenceNumber);\n    }\n    if (options?.startTime) {\n      params.append('timestamp', `gte:${options.startTime}`);\n    }\n    if (options?.endTime) {\n      params.append('timestamp', `lt:${options.endTime}`);\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      nextUrl += `?${queryString}`;\n    }\n\n    const messages: HCSMessage[] = [];\n    let pagesFetched = 0;\n    const maxPages = 10;\n\n    try {\n      while (nextUrl && pagesFetched < maxPages) {\n        pagesFetched++;\n        const data = await this._requestWithRetry<TopicMessagesResponse>(\n          nextUrl\n        );\n\n        if (data.messages && data.messages.length > 0) {\n          for (const message of data.messages) {\n            try {\n              if (!message.message) {\n                continue;\n              }\n              let messageContent: string;\n              if (this.isServerEnvironment) {\n                messageContent = Buffer.from(\n                  message.message,\n                  'base64'\n                ).toString('utf-8');\n              } else {\n                messageContent = new TextDecoder().decode(\n                  Uint8Array.from(atob(message.message), (c) => c.charCodeAt(0))\n                );\n              }\n              let messageJson = {};\n              try {\n                messageJson = JSON.parse(messageContent);\n              } catch {\n                this.logger.debug(\n                  `Message content is not valid JSON, using raw: ${messageContent}`\n                );\n                messageJson = { raw_content: messageContent };\n              }\n\n              const parsedContent = messageJson as HCSMessage;\n\n              const hcsMsg: HCSMessage = {\n                ...parsedContent,\n                consensus_timestamp: message.consensus_timestamp,\n                sequence_number: message.sequence_number,\n                payer_account_id: message.payer_account_id,\n                topic_id: message.topic_id,\n                running_hash: message.running_hash,\n                running_hash_version: message.running_hash_version,\n                chunk_info: message.chunk_info ?? {},\n                created: new Date(\n                  Number(message.consensus_timestamp.split('.')[0]) * 1000 +\n                    Number(message.consensus_timestamp.split('.')[1] || 0) /\n                      1_000_000\n                ),\n\n                payer: message.payer_account_id,\n              };\n\n              messages.push(hcsMsg);\n            } catch (error: unknown) {\n              const e = error as Error;\n              this.logger.error(\n                `Error processing individual message: ${e.message}`\n              );\n            }\n          }\n        }\n        if (options?.limit && messages.length >= options.limit) break;\n        nextUrl = data.links?.next ? `${data.links.next}` : '';\n      }\n      return messages;\n    } catch (error: unknown) {\n      const e = error as Error;\n      this.logger.error(\n        `Error querying filtered topic messages for ${topicId}: ${e.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves token balances for a given account ID.\n   * @param accountId The ID of the account.\n   * @param limit The maximum number of tokens to return.\n   * @returns A promise that resolves to an array of AccountTokenBalance or null.\n   */\n  async getAccountTokens(\n    accountId: string,\n    limit: number = 100\n  ): Promise<AccountTokenBalance[] | null> {\n    this.logger.info(`Getting tokens for account ${accountId}`);\n    let allTokens: AccountTokenBalance[] = [];\n    let endpoint = `/api/v1/accounts/${accountId}/tokens?limit=${limit}`;\n\n    try {\n      for (let i = 0; i < 10 && endpoint; i++) {\n        const response = await this._requestWithRetry<AccountTokensResponse>(\n          endpoint\n        );\n        if (response && response.tokens) {\n          allTokens = allTokens.concat(response.tokens);\n        }\n        endpoint = response.links?.next || '';\n        if (!endpoint || (limit && allTokens.length >= limit)) {\n          if (limit && allTokens.length > limit) {\n            allTokens = allTokens.slice(0, limit);\n          }\n          break;\n        }\n      }\n      return allTokens;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching tokens for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves transaction details by consensus timestamp.\n   * @param timestamp The consensus timestamp of the transaction (e.g., \"1629400000.000000000\").\n   * @returns A promise that resolves to the transaction details or null.\n   */\n  async getTransactionByTimestamp(\n    timestamp: string\n  ): Promise<HederaTransaction[]> {\n    this.logger.info(`Getting transaction by timestamp: ${timestamp}`);\n\n    try {\n      const response = await this._requestWithRetry<{\n        transactions: HederaTransaction[];\n      }>(`/api/v1/transactions?timestamp=${timestamp}&limit=1`);\n\n      return response.transactions;\n    } catch (error: unknown) {\n      this.logger.error(\n        `Error fetching transaction by timestamp ${timestamp}: ${error}`\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Retrieves NFTs for a given account ID, optionally filtered by token ID.\n   * @param accountId The ID of the account.\n   * @param tokenId Optional ID of the token to filter NFTs by.\n   * @param limit The maximum number of NFTs to return per page (API has its own max).\n   * @returns A promise that resolves to an array of NftDetail or null.\n   */\n  async getAccountNfts(\n    accountId: string,\n    tokenId?: string,\n    limit: number = 100\n  ): Promise<NftDetail[] | null> {\n    this.logger.info(\n      `Getting NFTs for account ${accountId}${\n        tokenId ? ` for token ${tokenId}` : ''\n      }`\n    );\n    let allNfts: NftDetail[] = [];\n    let endpoint = `/api/v1/accounts/${accountId}/nfts?limit=${limit}`;\n    if (tokenId) {\n      endpoint += `&token.id=${tokenId}`;\n    }\n\n    try {\n      for (let i = 0; i < 10 && endpoint; i++) {\n        const response = await this._requestWithRetry<AccountNftsResponse>(\n          endpoint\n        );\n        if (response && response.nfts) {\n          const nftsWithUri = response.nfts.map((nft: NftDetail) => {\n            let tokenUri: string | undefined = undefined;\n            if (nft.metadata) {\n              try {\n                if (this.isServerEnvironment) {\n                  tokenUri = Buffer.from(nft.metadata, 'base64').toString(\n                    'utf-8'\n                  );\n                } else {\n                  tokenUri = new TextDecoder().decode(\n                    Uint8Array.from(atob(nft.metadata), (c) => c.charCodeAt(0))\n                  );\n                }\n              } catch (e) {\n                this.logger.warn(\n                  `Failed to decode metadata for NFT ${nft.token_id} SN ${\n                    nft.serial_number\n                  }: ${(e as Error).message}`\n                );\n              }\n            }\n            return { ...nft, token_uri: tokenUri };\n          });\n          allNfts = allNfts.concat(nftsWithUri as NftDetail[]);\n        }\n        endpoint = response.links?.next || '';\n        if (!endpoint) break;\n      }\n      return allNfts;\n    } catch (error: unknown) {\n      this.logger.error(\n        `Error fetching NFTs for account ${accountId}: ${error}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Validates NFT ownership by checking if a specific serial number of a token ID exists for an account.\n   * @param accountId The ID of the account.\n   * @param tokenId The ID of the NFT's token.\n   * @param serialNumber The serial number of the NFT.\n   * @returns A promise that resolves to the NftDetail if owned, or null otherwise.\n   */\n  async validateNFTOwnership(\n    accountId: string,\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftDetail | null> {\n    this.logger.info(\n      `Validating ownership of NFT ${tokenId} SN ${serialNumber} for account ${accountId}`\n    );\n    try {\n      const nfts = await this.getAccountNfts(accountId, tokenId);\n      if (nfts) {\n        const foundNft = nfts.find(\n          (nft) =>\n            nft.token_id === tokenId && nft.serial_number === serialNumber\n        );\n        return foundNft || null;\n      }\n      return null;\n    } catch (error: any) {\n      this.logger.error(`Error validating NFT ownership: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Performs a read-only query against a smart contract (eth_call like).\n   * @param contractIdOrAddress The contract ID (e.g., \"0.0.123\") or EVM address (e.g., \"0x...\").\n   * @param functionSelector The function selector and encoded parameters (e.g., \"0xabcdef12...\").\n   * @param payerAccountId The account ID of the payer (not strictly payer for read-only, but often required as 'from').\n   * @param estimate Whether this is an estimate call. Mirror node might not support this directly in /contracts/call for true estimation.\n   * @param block Block parameter, e.g., \"latest\", \"pending\", or block number.\n   * @param value The value in tinybars to send with the call (for payable view/pure functions, usually 0).\n   * @returns A promise that resolves to the contract call query response or null.\n   */\n  async readSmartContractQuery(\n    contractIdOrAddress: string,\n    functionSelector: string,\n    payerAccountId: string,\n    options?: {\n      estimate?: boolean;\n      block?: string;\n      value?: number;\n      gas?: number;\n      gasPrice?: number;\n    }\n  ): Promise<ContractCallQueryResponse | null> {\n    this.logger.info(\n      `Reading smart contract ${contractIdOrAddress} with selector ${functionSelector}`\n    );\n\n    const toAddress = contractIdOrAddress.startsWith('0x')\n      ? contractIdOrAddress\n      : `0x${AccountId.fromString(contractIdOrAddress).toSolidityAddress()}`;\n    const fromAddress = payerAccountId.startsWith('0x')\n      ? payerAccountId\n      : `0x${AccountId.fromString(payerAccountId).toSolidityAddress()}`;\n\n    const body: any = {\n      block: options?.block || 'latest',\n      data: functionSelector,\n      estimate: options?.estimate || false,\n      from: fromAddress,\n      to: toAddress,\n      gas: options?.gas,\n      gasPrice: options?.gasPrice,\n      value: options?.value || 0,\n    };\n\n    Object.keys(body).forEach((key) => {\n      const K = key as keyof typeof body;\n      if (body[K] === undefined) {\n        delete body[K];\n      }\n    });\n\n    try {\n      const url = this.constructUrl('/api/v1/contracts/call');\n      const response = await this._fetchWithRetry<ContractCallQueryResponse>(\n        url,\n        {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        }\n      );\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error reading smart contract ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves outstanding token airdrops sent by an account.\n   * @param accountId The ID of the account that sent the airdrops.\n   * @param options Optional parameters for filtering airdrops.\n   * @returns A promise that resolves to an array of TokenAirdrop or null.\n   */\n  async getOutstandingTokenAirdrops(\n    accountId: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      receiverId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    this.logger.info(\n      `Getting outstanding token airdrops sent by account ${accountId}`\n    );\n    let endpoint = `/api/v1/accounts/${accountId}/airdrops/outstanding`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.receiverId) {\n      params.append('receiver.id', options.receiverId);\n    }\n    if (options?.serialNumber) {\n      params.append('serialnumber', options.serialNumber);\n    }\n    if (options?.tokenId) {\n      params.append('token.id', options.tokenId);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<TokenAirdropsResponse>(\n        endpoint\n      );\n      return response.airdrops || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching outstanding token airdrops for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves pending token airdrops received by an account.\n   * @param accountId The ID of the account that received the airdrops.\n   * @param options Optional parameters for filtering airdrops.\n   * @returns A promise that resolves to an array of TokenAirdrop or null.\n   */\n  async getPendingTokenAirdrops(\n    accountId: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      senderId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    this.logger.info(\n      `Getting pending token airdrops received by account ${accountId}`\n    );\n    let endpoint = `/api/v1/accounts/${accountId}/airdrops/pending`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.senderId) {\n      params.append('sender.id', options.senderId);\n    }\n    if (options?.serialNumber) {\n      params.append('serialnumber', options.serialNumber);\n    }\n    if (options?.tokenId) {\n      params.append('token.id', options.tokenId);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<TokenAirdropsResponse>(\n        endpoint\n      );\n      return response.airdrops || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching pending token airdrops for account ${accountId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves blocks from the network.\n   * @param options Optional parameters for filtering blocks.\n   * @returns A promise that resolves to an array of Block or null.\n   */\n  async getBlocks(options?: {\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    blockNumber?: string;\n  }): Promise<Block[] | null> {\n    this.logger.info('Getting blocks from the network');\n    let endpoint = `/api/v1/blocks`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.blockNumber) {\n      params.append('block.number', options.blockNumber);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      endpoint += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<BlocksResponse>(endpoint);\n      return response.blocks || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching blocks: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a specific block by number or hash.\n   * @param blockNumberOrHash The block number or hash.\n   * @returns A promise that resolves to a Block or null.\n   */\n  async getBlock(blockNumberOrHash: string): Promise<Block | null> {\n    this.logger.info(`Getting block ${blockNumberOrHash}`);\n    try {\n      const response = await this._requestWithRetry<Block>(\n        `/api/v1/blocks/${blockNumberOrHash}`\n      );\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching block ${blockNumberOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract entities from the network.\n   * @param options Optional parameters for filtering contracts.\n   * @returns A promise that resolves to an array of ContractEntity or null.\n   */\n  async getContracts(options?: {\n    contractId?: string;\n    limit?: number;\n    order?: 'asc' | 'desc';\n  }): Promise<ContractEntity[] | null> {\n    this.logger.info('Getting contracts from the network');\n    let url = `/api/v1/contracts`;\n    const params = new URLSearchParams();\n\n    if (options?.contractId) {\n      params.append('contract.id', options.contractId);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractsResponse>(url);\n      return response.contracts || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching contracts: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a specific contract by ID or address.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param timestamp Optional timestamp for historical data.\n   * @returns A promise that resolves to a ContractEntity or null.\n   */\n  async getContract(\n    contractIdOrAddress: string,\n    timestamp?: string\n  ): Promise<ContractEntity | null> {\n    this.logger.info(`Getting contract ${contractIdOrAddress}`);\n    let url = `/api/v1/contracts/${contractIdOrAddress}`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractEntity>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract results from the network.\n   * @param options Optional parameters for filtering contract results.\n   * @returns A promise that resolves to an array of ContractResult or null.\n   */\n  async getContractResults(options?: {\n    from?: string;\n    blockHash?: string;\n    blockNumber?: string;\n    internal?: boolean;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    transactionIndex?: number;\n  }): Promise<ContractResult[] | null> {\n    this.logger.info('Getting contract results from the network');\n    let url = `/api/v1/contracts/results`;\n    const params = new URLSearchParams();\n\n    if (options?.from) {\n      params.append('from', options.from);\n    }\n    if (options?.blockHash) {\n      params.append('block.hash', options.blockHash);\n    }\n    if (options?.blockNumber) {\n      params.append('block.number', options.blockNumber);\n    }\n    if (options?.internal !== undefined) {\n      params.append('internal', options.internal.toString());\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.transactionIndex) {\n      params.append('transaction.index', options.transactionIndex.toString());\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractResultsResponse>(\n        url\n      );\n      return response.results || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching contract results: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a specific contract result by transaction ID or hash.\n   * @param transactionIdOrHash The transaction ID or hash.\n   * @param nonce Optional nonce filter.\n   * @returns A promise that resolves to a ContractResult or null.\n   */\n  async getContractResult(\n    transactionIdOrHash: string,\n    nonce?: number\n  ): Promise<ContractResult | null> {\n    this.logger.info(`Getting contract result for ${transactionIdOrHash}`);\n    let url = `/api/v1/contracts/results/${transactionIdOrHash}`;\n\n    if (nonce !== undefined) {\n      url += `?nonce=${nonce}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractResult>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract result for ${transactionIdOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract results for a specific contract.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param options Optional parameters for filtering.\n   * @returns A promise that resolves to an array of ContractResult or null.\n   */\n  async getContractResultsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      blockHash?: string;\n      blockNumber?: string;\n      from?: string;\n      internal?: boolean;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      transactionIndex?: number;\n    }\n  ): Promise<ContractResult[] | null> {\n    this.logger.info(\n      `Getting contract results for contract ${contractIdOrAddress}`\n    );\n    let url = `/api/v1/contracts/${contractIdOrAddress}/results`;\n    const params = new URLSearchParams();\n\n    if (options?.blockHash) {\n      params.append('block.hash', options.blockHash);\n    }\n    if (options?.blockNumber) {\n      params.append('block.number', options.blockNumber);\n    }\n    if (options?.from) {\n      params.append('from', options.from);\n    }\n    if (options?.internal !== undefined) {\n      params.append('internal', options.internal.toString());\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.transactionIndex) {\n      params.append('transaction.index', options.transactionIndex.toString());\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractResultsResponse>(\n        url\n      );\n      return response.results || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract results for ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract state for a specific contract.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param options Optional parameters for filtering.\n   * @returns A promise that resolves to an array of ContractState or null.\n   */\n  async getContractState(\n    contractIdOrAddress: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      slot?: string;\n      timestamp?: string;\n    }\n  ): Promise<ContractState[] | null> {\n    this.logger.info(`Getting contract state for ${contractIdOrAddress}`);\n    let url = `/api/v1/contracts/${contractIdOrAddress}/state`;\n    const params = new URLSearchParams();\n\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.slot) {\n      params.append('slot', options.slot);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractStateResponse>(url);\n      return response.state || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract state for ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract actions for a specific transaction.\n   * @param transactionIdOrHash The transaction ID or hash.\n   * @param options Optional parameters for filtering.\n   * @returns A promise that resolves to an array of ContractAction or null.\n   */\n  async getContractActions(\n    transactionIdOrHash: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<ContractAction[] | null> {\n    this.logger.info(`Getting contract actions for ${transactionIdOrHash}`);\n    let url = `/api/v1/contracts/results/${transactionIdOrHash}/actions`;\n    const params = new URLSearchParams();\n\n    if (options?.index) {\n      params.append('index', options.index);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractActionsResponse>(\n        url\n      );\n      return response.actions || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract actions for ${transactionIdOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract logs from the network.\n   * @param options Optional parameters for filtering logs.\n   * @returns A promise that resolves to an array of ContractLog or null.\n   */\n  async getContractLogs(options?: {\n    index?: string;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    topic0?: string;\n    topic1?: string;\n    topic2?: string;\n    topic3?: string;\n    transactionHash?: string;\n  }): Promise<ContractLog[] | null> {\n    this.logger.info('Getting contract logs from the network');\n    let url = `/api/v1/contracts/results/logs`;\n    const params = new URLSearchParams();\n\n    if (options?.index) {\n      params.append('index', options.index);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.topic0) {\n      params.append('topic0', options.topic0);\n    }\n    if (options?.topic1) {\n      params.append('topic1', options.topic1);\n    }\n    if (options?.topic2) {\n      params.append('topic2', options.topic2);\n    }\n    if (options?.topic3) {\n      params.append('topic3', options.topic3);\n    }\n    if (options?.transactionHash) {\n      params.append('transaction.hash', options.transactionHash);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractLogsResponse>(url);\n      return response.logs || [];\n    } catch (error: any) {\n      this.logger.error(`Error fetching contract logs: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves contract logs for a specific contract.\n   * @param contractIdOrAddress The contract ID or EVM address.\n   * @param options Optional parameters for filtering logs.\n   * @returns A promise that resolves to an array of ContractLog or null.\n   */\n  async getContractLogsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      topic0?: string;\n      topic1?: string;\n      topic2?: string;\n      topic3?: string;\n    }\n  ): Promise<ContractLog[] | null> {\n    this.logger.info(\n      `Getting contract logs for contract ${contractIdOrAddress}`\n    );\n    let url = `/api/v1/contracts/${contractIdOrAddress}/results/logs`;\n    const params = new URLSearchParams();\n\n    if (options?.index) {\n      params.append('index', options.index);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.timestamp) {\n      params.append('timestamp', options.timestamp);\n    }\n    if (options?.topic0) {\n      params.append('topic0', options.topic0);\n    }\n    if (options?.topic1) {\n      params.append('topic1', options.topic1);\n    }\n    if (options?.topic2) {\n      params.append('topic2', options.topic2);\n    }\n    if (options?.topic3) {\n      params.append('topic3', options.topic3);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<ContractLogsResponse>(url);\n      return response.logs || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching contract logs for ${contractIdOrAddress}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves NFT information by token ID and serial number.\n   * @param tokenId The token ID.\n   * @param serialNumber The serial number of the NFT.\n   * @returns A promise that resolves to an NftInfo or null.\n   */\n  async getNftInfo(\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftInfo | null> {\n    this.logger.info(`Getting NFT info for ${tokenId}/${serialNumber}`);\n    const url = `/api/v1/tokens/${tokenId}/nfts/${serialNumber}`;\n\n    try {\n      const response = await this._requestWithRetry<NftInfo>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching NFT info for ${tokenId}/${serialNumber}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves NFTs for a specific token.\n   * @param tokenId The token ID.\n   * @param options Optional parameters for filtering NFTs.\n   * @returns A promise that resolves to an array of NftInfo or null.\n   */\n  async getNftsByToken(\n    tokenId: string,\n    options?: {\n      accountId?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      serialNumber?: string;\n    }\n  ): Promise<NftInfo[] | null> {\n    this.logger.info(`Getting NFTs for token ${tokenId}`);\n    let url = `/api/v1/tokens/${tokenId}/nfts`;\n    const params = new URLSearchParams();\n\n    if (options?.accountId) {\n      params.append('account.id', options.accountId);\n    }\n    if (options?.limit) {\n      params.append('limit', options.limit.toString());\n    }\n    if (options?.order) {\n      params.append('order', options.order);\n    }\n    if (options?.serialNumber) {\n      params.append('serialnumber', options.serialNumber);\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NftsResponse>(url);\n      return response.nfts || [];\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching NFTs for token ${tokenId}: ${error.message}`\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network information.\n   * @returns A promise that resolves to NetworkInfo or null.\n   */\n  async getNetworkInfo(): Promise<NetworkInfo | null> {\n    this.logger.info('Getting network information');\n    const url = `/api/v1/network/nodes`;\n\n    try {\n      const response = await this._requestWithRetry<NetworkInfo>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network info: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network fees.\n   * @param timestamp Optional timestamp for historical fees.\n   * @returns A promise that resolves to NetworkFees or null.\n   */\n  async getNetworkFees(timestamp?: string): Promise<NetworkFees | null> {\n    this.logger.info('Getting network fees');\n    let url = `/api/v1/network/fees`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NetworkFees>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network fees: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network supply information.\n   * @param timestamp Optional timestamp for historical supply data.\n   * @returns A promise that resolves to NetworkSupply or null.\n   */\n  async getNetworkSupply(timestamp?: string): Promise<NetworkSupply | null> {\n    this.logger.info('Getting network supply');\n    let url = `/api/v1/network/supply`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NetworkSupply>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network supply: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves network stake information.\n   * @param timestamp Optional timestamp for historical stake data.\n   * @returns A promise that resolves to NetworkStake or null.\n   */\n  async getNetworkStake(timestamp?: string): Promise<NetworkStake | null> {\n    this.logger.info('Getting network stake');\n    let url = `/api/v1/network/stake`;\n\n    if (timestamp) {\n      url += `?timestamp=${timestamp}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<NetworkStake>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(`Error fetching network stake: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves opcode traces for a specific transaction.\n   * @param transactionIdOrHash The transaction ID or hash.\n   * @param options Optional parameters for trace details.\n   * @returns A promise that resolves to an OpcodesResponse or null.\n   */\n  async getOpcodeTraces(\n    transactionIdOrHash: string,\n    options?: {\n      stack?: boolean;\n      memory?: boolean;\n      storage?: boolean;\n    }\n  ): Promise<OpcodesResponse | null> {\n    this.logger.info(`Getting opcode traces for ${transactionIdOrHash}`);\n    let url = `/api/v1/contracts/results/${transactionIdOrHash}/opcodes`;\n    const params = new URLSearchParams();\n\n    if (options?.stack !== undefined) {\n      params.append('stack', options.stack.toString());\n    }\n    if (options?.memory !== undefined) {\n      params.append('memory', options.memory.toString());\n    }\n    if (options?.storage !== undefined) {\n      params.append('storage', options.storage.toString());\n    }\n\n    const queryString = params.toString();\n    if (queryString) {\n      url += `?${queryString}`;\n    }\n\n    try {\n      const response = await this._requestWithRetry<OpcodesResponse>(url);\n      return response;\n    } catch (error: any) {\n      this.logger.error(\n        `Error fetching opcode traces for ${transactionIdOrHash}: ${error.message}`\n      );\n      return null;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}