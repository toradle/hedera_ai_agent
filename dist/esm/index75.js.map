{"version":3,"file":"index75.js","sources":["../../src/builders/query/query-builder.ts"],"sourcesContent":["import {\n  HederaMirrorNode,\n  TopicResponse,\n  CustomFees,\n  TokenInfoResponse,\n  HCSMessage,\n  AccountResponse,\n  ScheduleInfo,\n  Transaction as HederaTransaction,\n  AccountTokenBalance,\n  NftDetail,\n  NftInfo,\n  ContractCallQueryResponse,\n  TokenAirdrop,\n  Block,\n  ContractResult,\n  ContractLog,\n  ContractAction,\n  NetworkStake,\n  NetworkSupply,\n  ContractEntity,\n  ContractState,\n  NetworkInfo,\n  NetworkFees,\n  OpcodesResponse,\n} from '../../services/mirror-node';\nimport { HederaAgentKit } from '../../agent';\nimport { TopicId, AccountId, PublicKey } from '@hashgraph/sdk';\n\n/**\n * Utility function to filter out undefined values from an object\n */\nfunction filterUndefined<T extends Record<string, unknown>>(\n  obj: T\n): Partial<T> {\n  const filtered: Partial<T> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== undefined) {\n      (filtered as Record<string, unknown>)[key] = value;\n    }\n  }\n  return filtered;\n}\n\n/**\n * Builder class for Hedera query operations.\n * Provides a fluent interface for querying the Hedera network via Mirror Node.\n */\nexport class QueryBuilder {\n  private hederaKit: HederaAgentKit;\n  private mirrorNode: HederaMirrorNode;\n\n  constructor(hederaKit: HederaAgentKit) {\n    this.hederaKit = hederaKit;\n    this.mirrorNode = hederaKit.mirrorNode;\n  }\n\n  /**\n   * Get topic information for a given topic ID\n   */\n  async getTopicInfo(topicId: string | TopicId): Promise<TopicResponse> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicInfo(topicIdString);\n  }\n\n  /**\n   * Get messages for a given topic ID\n   */\n  async getTopicMessages(topicId: string | TopicId): Promise<HCSMessage[]> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicMessages(topicIdString);\n  }\n\n  /**\n   * Get filtered topic messages with optional parameters\n   */\n  async getTopicMessagesByFilter(\n    topicId: string | TopicId,\n    options?: {\n      sequenceNumber?: string;\n      startTime?: string;\n      endTime?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<HCSMessage[] | null> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicMessagesByFilter(\n      topicIdString,\n      options\n    );\n  }\n\n  /**\n   * Get account information for a given account ID\n   */\n  async getAccountInfo(\n    accountId: string | AccountId\n  ): Promise<AccountResponse> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.requestAccount(accountIdString);\n  }\n\n  /**\n   * Get account balance in HBAR for a given account ID\n   */\n  async getAccountBalance(\n    accountId: string | AccountId\n  ): Promise<number | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountBalance(accountIdString);\n  }\n\n  /**\n   * Get account memo for a given account ID\n   */\n  async getAccountMemo(accountId: string | AccountId): Promise<string | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountMemo(accountIdString);\n  }\n\n  /**\n   * Get token information for a given token ID\n   */\n  async getTokenInfo(tokenId: string): Promise<TokenInfoResponse | null> {\n    return await this.mirrorNode.getTokenInfo(tokenId);\n  }\n\n  /**\n   * Get token balances for a given account ID\n   */\n  async getAccountTokens(\n    accountId: string | AccountId,\n    limit: number = 100\n  ): Promise<AccountTokenBalance[] | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountTokens(accountIdString, limit);\n  }\n\n  /**\n   * Get NFTs for a given account ID\n   */\n  async getAccountNfts(\n    accountId: string | AccountId,\n    tokenId?: string,\n    limit: number = 100\n  ): Promise<NftDetail[] | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getAccountNfts(\n      accountIdString,\n      tokenId,\n      limit\n    );\n  }\n\n  /**\n   * Validate NFT ownership\n   */\n  async validateNftOwnership(\n    accountId: string | AccountId,\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftDetail | null> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.validateNFTOwnership(\n      accountIdString,\n      tokenId,\n      serialNumber\n    );\n  }\n\n  /**\n   * Get transaction details by ID or hash\n   */\n  async getTransaction(\n    transactionIdOrHash: string\n  ): Promise<HederaTransaction | null> {\n    return await this.mirrorNode.getTransaction(transactionIdOrHash);\n  }\n\n  /**\n   * Get transaction details by consensus timestamp\n   */\n  async getTransactionByTimestamp(\n    timestamp: string\n  ): Promise<HederaTransaction[]> {\n    return await this.mirrorNode.getTransactionByTimestamp(timestamp);\n  }\n\n  /**\n   * Get schedule information for a given schedule ID\n   */\n  async getScheduleInfo(scheduleId: string): Promise<ScheduleInfo | null> {\n    return await this.mirrorNode.getScheduleInfo(scheduleId);\n  }\n\n  /**\n   * Get scheduled transaction status\n   */\n  async getScheduledTransactionStatus(scheduleId: string): Promise<{\n    executed: boolean;\n    executedDate?: Date | undefined;\n    deleted: boolean;\n  }> {\n    return await this.mirrorNode.getScheduledTransactionStatus(scheduleId);\n  }\n\n  /**\n   * Get HBAR price for a given date\n   */\n  async getHbarPrice(date: Date): Promise<number | null> {\n    return await this.mirrorNode.getHBARPrice(date);\n  }\n\n  /**\n   * Read smart contract query (view/pure functions)\n   */\n  async readSmartContract(\n    contractIdOrAddress: string,\n    functionSelector: string,\n    payerAccountId: string | AccountId,\n    options?: {\n      estimate?: boolean;\n      block?: string;\n      value?: number;\n      gas?: number;\n      gasPrice?: number;\n    }\n  ): Promise<ContractCallQueryResponse | null> {\n    const payerIdString =\n      typeof payerAccountId === 'string'\n        ? payerAccountId\n        : payerAccountId.toString();\n    return await this.mirrorNode.readSmartContractQuery(\n      contractIdOrAddress,\n      functionSelector,\n      payerIdString,\n      options\n    );\n  }\n\n  /**\n   * Get public key for a given account ID\n   */\n  async getPublicKey(accountId: string | AccountId): Promise<PublicKey> {\n    const accountIdString =\n      typeof accountId === 'string' ? accountId : accountId.toString();\n    return await this.mirrorNode.getPublicKey(accountIdString);\n  }\n\n  /**\n   * Get custom fees for a given topic ID\n   */\n  async getTopicFees(topicId: string | TopicId): Promise<CustomFees | null> {\n    const topicIdString =\n      typeof topicId === 'string' ? topicId : topicId.toString();\n    return await this.mirrorNode.getTopicFees(topicIdString);\n  }\n\n  /**\n   * Check if a user has access to a given key list\n   */\n  async checkKeyListAccess(\n    keyBytes: Buffer,\n    userPublicKey: PublicKey\n  ): Promise<boolean> {\n    return await this.mirrorNode.checkKeyListAccess(keyBytes, userPublicKey);\n  }\n\n  /**\n   * Get outstanding token airdrops sent by an account\n   */\n  async getOutstandingTokenAirdrops(\n    accountIdOrArgs:\n      | string\n      | AccountId\n      | {\n          accountId: string;\n          limit?: number | undefined;\n          order?: 'asc' | 'desc' | undefined;\n          receiverId?: string | undefined;\n          serialNumber?: string | undefined;\n          tokenId?: string | undefined;\n        },\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      receiverId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    let accountIdString: string;\n    let finalOptions: typeof options;\n\n    if (typeof accountIdOrArgs === 'object' && 'accountId' in accountIdOrArgs) {\n      accountIdString = accountIdOrArgs.accountId;\n      finalOptions = filterUndefined({\n        limit: accountIdOrArgs.limit,\n        order: accountIdOrArgs.order,\n        receiverId: accountIdOrArgs.receiverId,\n        serialNumber: accountIdOrArgs.serialNumber,\n        tokenId: accountIdOrArgs.tokenId,\n      }) as typeof options;\n    } else {\n      accountIdString =\n        typeof accountIdOrArgs === 'string'\n          ? accountIdOrArgs\n          : accountIdOrArgs.toString();\n      finalOptions = options;\n    }\n\n    if (!finalOptions) {\n      return await this.mirrorNode.getOutstandingTokenAirdrops(accountIdString);\n    }\n\n    const filteredOptions = filterUndefined(finalOptions);\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getOutstandingTokenAirdrops(\n      accountIdString,\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get pending token airdrops received by an account\n   */\n  async getPendingTokenAirdrops(\n    accountIdOrArgs:\n      | string\n      | AccountId\n      | {\n          accountId: string;\n          limit?: number | undefined;\n          order?: 'asc' | 'desc' | undefined;\n          senderId?: string | undefined;\n          serialNumber?: string | undefined;\n          tokenId?: string | undefined;\n        },\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      senderId?: string;\n      serialNumber?: string;\n      tokenId?: string;\n    }\n  ): Promise<TokenAirdrop[] | null> {\n    let accountIdString: string;\n    let finalOptions: typeof options;\n\n    if (typeof accountIdOrArgs === 'object' && 'accountId' in accountIdOrArgs) {\n      accountIdString = accountIdOrArgs.accountId;\n      finalOptions = filterUndefined({\n        limit: accountIdOrArgs.limit,\n        order: accountIdOrArgs.order,\n        senderId: accountIdOrArgs.senderId,\n        serialNumber: accountIdOrArgs.serialNumber,\n        tokenId: accountIdOrArgs.tokenId,\n      }) as typeof options;\n    } else {\n      accountIdString =\n        typeof accountIdOrArgs === 'string'\n          ? accountIdOrArgs\n          : accountIdOrArgs.toString();\n      finalOptions = options;\n    }\n\n    if (!finalOptions) {\n      return await this.mirrorNode.getPendingTokenAirdrops(accountIdString);\n    }\n\n    const filteredOptions = filterUndefined(finalOptions);\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getPendingTokenAirdrops(\n      accountIdString,\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get blocks with optional filtering\n   */\n  async getBlocks(options?: {\n    blockNumber?: string | undefined;\n    timestamp?: string | undefined;\n    limit?: number | undefined;\n    order?: 'asc' | 'desc' | undefined;\n  }): Promise<Block[] | null> {\n    if (!options) {\n      return await this.mirrorNode.getBlocks();\n    }\n\n    const filteredOptions = filterUndefined(options) as {\n      blockNumber?: string;\n      timestamp?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    };\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getBlocks(\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get a specific block by number or hash\n   */\n  async getBlock(blockNumberOrHash: string): Promise<Block | null> {\n    return await this.mirrorNode.getBlock(blockNumberOrHash);\n  }\n\n  /**\n   * Get contract results with optional filtering\n   */\n  async getContractResults(options?: {\n    from?: string;\n    blockHash?: string;\n    blockNumber?: string;\n    internal?: boolean;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    transactionIndex?: number;\n  }): Promise<ContractResult[] | null> {\n    return await this.mirrorNode.getContractResults(options);\n  }\n\n  /**\n   * Get contract result by transaction ID\n   */\n  async getContractResult(\n    transactionIdOrHash: string,\n    nonce?: number\n  ): Promise<ContractResult | null> {\n    return await this.mirrorNode.getContractResult(transactionIdOrHash, nonce);\n  }\n\n  /**\n   * Get contract logs with optional filtering\n   */\n  async getContractLogs(options?: {\n    index?: string;\n    limit?: number;\n    order?: 'asc' | 'desc';\n    timestamp?: string;\n    topic0?: string;\n    topic1?: string;\n    topic2?: string;\n    topic3?: string;\n    transactionHash?: string;\n  }): Promise<ContractLog[] | null> {\n    return await this.mirrorNode.getContractLogs(options);\n  }\n\n  /**\n   * Get contract actions for a transaction\n   */\n  async getContractActions(\n    transactionIdOrHash: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    }\n  ): Promise<ContractAction[] | null> {\n    return await this.mirrorNode.getContractActions(\n      transactionIdOrHash,\n      options\n    );\n  }\n\n  /**\n   * Get NFT information by token ID and serial number\n   */\n  async getNftInfo(\n    tokenId: string,\n    serialNumber: number\n  ): Promise<NftInfo | null> {\n    return await this.mirrorNode.getNftInfo(tokenId, serialNumber);\n  }\n\n  /**\n   * Get all NFTs for a token ID\n   */\n  async getNftsByToken(\n    tokenId: string,\n    options?: {\n      accountId?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      serialNumber?: string;\n    }\n  ): Promise<NftInfo[] | null> {\n    return await this.mirrorNode.getNftsByToken(tokenId, options);\n  }\n\n  /**\n   * Get network stake information\n   */\n  async getNetworkStake(timestamp?: string): Promise<NetworkStake | null> {\n    return await this.mirrorNode.getNetworkStake(timestamp);\n  }\n\n  /**\n   * Get network supply information\n   */\n  async getNetworkSupply(timestamp?: string): Promise<NetworkSupply | null> {\n    return await this.mirrorNode.getNetworkSupply(timestamp);\n  }\n\n  /**\n   * Get contract entities from the network\n   */\n  async getContracts(options?: {\n    contractId?: string | undefined;\n    limit?: number | undefined;\n    order?: 'asc' | 'desc' | undefined;\n  }): Promise<ContractEntity[] | null> {\n    if (!options) {\n      return await this.mirrorNode.getContracts();\n    }\n\n    const filteredOptions = filterUndefined(options) as {\n      contractId?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n    };\n    const hasFilters = Object.keys(filteredOptions).length > 0;\n    return await this.mirrorNode.getContracts(\n      hasFilters ? filteredOptions : undefined\n    );\n  }\n\n  /**\n   * Get a specific contract by ID or address\n   */\n  async getContract(\n    contractIdOrAddress: string,\n    timestamp?: string,\n    includeBytecode?: boolean\n  ): Promise<ContractEntity | null> {\n    const response = await this.mirrorNode.getContract(\n      contractIdOrAddress,\n      timestamp\n    );\n    if (!includeBytecode) {\n      delete response?.bytecode;\n    }\n    return response;\n  }\n\n  /**\n   * Get contract results by contract\n   */\n  async getContractResultsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      blockHash?: string;\n      blockNumber?: string;\n      from?: string;\n      internal?: boolean;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      transactionIndex?: number;\n    }\n  ): Promise<ContractResult[] | null> {\n    return await this.mirrorNode.getContractResultsByContract(\n      contractIdOrAddress,\n      options\n    );\n  }\n\n  /**\n   * Get contract state for a specific contract\n   */\n  async getContractState(\n    contractIdOrAddress: string,\n    options?: {\n      limit?: number;\n      order?: 'asc' | 'desc';\n      slot?: string;\n      timestamp?: string;\n    }\n  ): Promise<ContractState[] | null> {\n    return await this.mirrorNode.getContractState(contractIdOrAddress, options);\n  }\n\n  /**\n   * Get contract logs by contract\n   */\n  async getContractLogsByContract(\n    contractIdOrAddress: string,\n    options?: {\n      index?: string;\n      limit?: number;\n      order?: 'asc' | 'desc';\n      timestamp?: string;\n      topic0?: string;\n      topic1?: string;\n      topic2?: string;\n      topic3?: string;\n    }\n  ): Promise<ContractLog[] | null> {\n    return await this.mirrorNode.getContractLogsByContract(\n      contractIdOrAddress,\n      options\n    );\n  }\n\n  /**\n   * Get network information\n   */\n  async getNetworkInfo(): Promise<NetworkInfo | null> {\n    return await this.mirrorNode.getNetworkInfo();\n  }\n\n  /**\n   * Get network fees\n   */\n  async getNetworkFees(timestamp?: string): Promise<NetworkFees | null> {\n    return await this.mirrorNode.getNetworkFees(timestamp);\n  }\n\n  /**\n   * Get opcode traces for a specific transaction\n   */\n  async getOpcodeTraces(\n    transactionIdOrHash: string,\n    options?: {\n      stack?: boolean;\n      memory?: boolean;\n      storage?: boolean;\n    }\n  ): Promise<OpcodesResponse | null> {\n    return await this.mirrorNode.getOpcodeTraces(transactionIdOrHash, options);\n  }\n}\n"],"names":[],"mappings":"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"}