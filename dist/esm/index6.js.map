{"version":3,"file":"index6.js","sources":["../../src/types/index.ts"],"sourcesContent":["import BigNumber from 'bignumber.js';\nimport {\n  PublicKey,\n  AccountId,\n  TopicId,\n  PrivateKey,\n  CustomFee,\n  TokenType,\n  TokenSupplyType,\n  TokenId,\n  Long,\n  NftId,\n  CustomFixedFee,\n  Key,\n  FileId,\n  ContractFunctionParameters,\n  KeyList,\n  ContractId,\n  Hbar,\n  EvmAddress,\n  PendingAirdropId,\n  TransactionId,\n  ScheduleId,\n} from '@hashgraph/sdk';\n\nexport {\n  PublicKey,\n  AccountId,\n  TopicId,\n  PrivateKey,\n  CustomFee,\n  TokenType,\n  TokenSupplyType,\n  TokenId,\n  Long,\n  NftId,\n  CustomFixedFee,\n  Key,\n  FileId,\n  ContractFunctionParameters,\n  KeyList,\n  ContractId,\n  Hbar,\n  EvmAddress,\n  PendingAirdropId,\n  TransactionId,\n  ScheduleId,\n};\n\nexport type AgentOperationalMode = 'autonomous' | 'returnBytes';\nexport type HederaNetworkType = 'mainnet' | 'testnet' | 'previewnet';\n\n/**\n * Configuration for custom mirror node providers.\n *\n * @example\n * // Using HGraph with API key in URL\n * const config = {\n *   customUrl: 'https://mainnet.hedera.api.hgraph.dev/v1/<API-KEY>',\n *   apiKey: 'your-api-key-here'\n * };\n *\n * @example\n * // Using custom provider with API key in headers\n * const config = {\n *   customUrl: 'https://custom-mirror-node.com',\n *   apiKey: 'your-api-key',\n *   headers: {\n *     'X-Custom-Header': 'value'\n *   }\n * };\n */\nexport interface MirrorNodeConfig {\n  /** Custom mirror node URL. Can include <API-KEY> placeholder for URL-based API keys. */\n  customUrl?: string;\n  /** API key for authentication. Will be used in both Authorization header and URL replacement. */\n  apiKey?: string;\n  /** Additional custom headers to include with requests. */\n  headers?: Record<string, string>;\n}\n\nexport type TokenBalance = {\n  account: string;\n  balance: number;\n  decimals: number;\n};\n\nexport type TokenHoldersBalancesApiResponse = {\n  timestamp: string;\n  balances: TokenBalance[];\n  links: {\n    next: string;\n  };\n};\n\nexport type DetailedTokenBalance = {\n  tokenId: string;\n  tokenSymbol: string;\n  tokenName: string;\n  tokenDecimals: string;\n  balance: number;\n  balanceInDisplayUnit: BigNumber;\n  timestamp: string;\n  balances: {\n    account: string;\n    balance: number;\n    tokens: {\n      token_id: string;\n      balance: number;\n    }[];\n  }[];\n  links: {\n    next: string | null;\n  };\n};\n\nexport type HtsTokenBalanceApiReponse = {\n  timestamp: string;\n  balances: TokenBalance[];\n  links: {\n    next: string;\n  };\n};\n\ntype ProtobufEncodedKey = {\n  _type: 'ProtobufEncoded';\n  key: string;\n};\n\nexport type CustomFees = {\n  created_timestamp: string;\n  fixed_fees: unknown[];\n  fractional_fees: unknown[];\n};\n\nexport type HtsTokenDetails = {\n  admin_key: ProtobufEncodedKey;\n  auto_renew_account: string;\n  auto_renew_period: number;\n  created_timestamp: string;\n  custom_fees: CustomFees;\n  decimals: string;\n  deleted: boolean;\n  expiry_timestamp: number;\n  fee_schedule_key: ProtobufEncodedKey;\n  freeze_default: boolean;\n  freeze_key: ProtobufEncodedKey;\n  initial_supply: string;\n  kyc_key: ProtobufEncodedKey;\n  max_supply: string;\n  memo: string;\n  metadata: string;\n  metadata_key: ProtobufEncodedKey | null;\n  modified_timestamp: string;\n  name: string;\n  pause_key: ProtobufEncodedKey;\n  pause_status: 'PAUSED' | 'UNPAUSED';\n  supply_key: ProtobufEncodedKey;\n  supply_type: 'FINITE' | 'INFINITE';\n  symbol: string;\n  token_id: string;\n  total_supply: string;\n  treasury_account_id: string;\n  type: 'FUNGIBLE_COMMON' | 'NON_FUNGIBLE_UNIQUE';\n  wipe_key: ProtobufEncodedKey;\n  supplyType: TokenSupplyType;\n  maxSupply?: number | BigNumber;\n};\n\nexport type AllTokensBalancesApiResponse = {\n  timestamp: string;\n  balances: {\n    account: string; // Account ID in the format \"0.0.x\"\n    balance: number; // Total balance equivalent in HBAR\n    tokens: {\n      token_id: string; // Token ID in the format \"0.0.x\"\n      balance: number; // Balance of the specific token\n    }[];\n  }[];\n  links: {\n    next: string | null; // link to next page\n  };\n};\n\nexport type Airdrop = {\n  amount: number;\n  receiver_id: string;\n  sender_id: string;\n  token_id: string;\n};\n\nexport type PendingAirdropsApiResponse = {\n  airdrops: Airdrop[];\n  links: {\n    next: string | null;\n  };\n};\n\ntype TimestampRange = {\n  from: string;\n  to?: string | null;\n};\n\nexport type TopicInfoApiResponse = {\n  admin_key?: Key | null;\n  auto_renew_account?: string | null;\n  auto_renew_period?: number | null;\n  created_timestamp?: string | null;\n  deleted?: boolean | null;\n  memo?: string;\n  submit_key?: Key | null;\n  timestamp?: TimestampRange;\n  topic_id?: string | null;\n};\n\nexport type HCSMessage = {\n  chunk_info: unknown | null;\n  consensus_timestamp: string;\n  message: string;\n  payer_account_id: string;\n  running_hash: string;\n  running_hash_version: number;\n  sequence_number: number;\n  topic_id: string;\n  supplyType: TokenSupplyType;\n  maxSupply?: number | BigNumber;\n  raw_content?: string;\n};\n\nexport type HCSMessageApiResponse = {\n  messages: HCSMessage[];\n  links: {\n    next: string | null;\n  };\n};\n\nexport enum AgentKitActionName {\n  CREATE_TOPIC_CUSTODIAL = 'createTopicCustodial',\n  CREATE_TOPIC_NON_CUSTODIAL = 'createTopicNonCustodial',\n  DELETE_TOPIC_CUSTODIAL = 'deleteTopicCustodial',\n  DELETE_TOPIC_NON_CUSTODIAL = 'deleteTopicNonCustodial',\n  SUBMIT_TOPIC_MESSAGE_CUSTODIAL = 'submitTopicMessageCustodial',\n  SUBMIT_TOPIC_MESSAGE_NON_CUSTODIAL = 'submitTopicMessageCustodial',\n  CREATE_TOKEN_CUSTODIAL = 'createTokenCustodial',\n  CREATE_TOKEN_NON_CUSTODIAL = 'createTokenNonCustodial',\n  ASSOCIATE_TOKEN_CUSTODIAL = 'associateTokenCustodial',\n  ASSOCIATE_TOKEN_NON_CUSTODIAL = 'associateTokenNonCustodial',\n  DISSOCIATE_TOKEN_CUSTODIAL = 'dissociateTokenCustodial',\n  DISSOCIATE_TOKEN_NON_CUSTODIAL = 'dissociateTokenNonCustodial',\n  AIRDROP_TOKEN_CUSTODIAL = 'airdropTokenCustodial',\n  AIRDROP_TOKEN_NON_CUSTODIAL = 'airdropTokenNonCustodial',\n  REJECT_TOKEN_CUSTODIAL = 'rejectedTokenCustodial',\n  REJECT_TOKEN_NON_CUSTODIAL = 'rejectedTokenNonCustodial',\n  MINT_TOKEN_CUSTODIAL = 'mintTokenCustodial',\n  MINT_TOKEN_NON_CUSTODIAL = 'mintTokenNonCustodial',\n  MINT_NFT_TOKEN_CUSTODIAL = 'mintNFTTokenCustodial',\n  MINT_NFT_TOKEN_NON_CUSTODIAL = 'mintNFTTokenNonCustodial',\n  CLAIM_AIRDROP_CUSTODIAL = 'claimAirdropCustodial',\n  CLAIM_AIRDROP_NON_CUSTODIAL = 'claimAirdropNonCustodial',\n  TRANSFER_TOKEN_CUSTODIAL = 'transferTokenCustodial',\n  TRANSFER_TOKEN_NON_CUSTODIAL = 'transferTokenNonCustodial',\n  TRANSFER_HBAR_CUSTODIAL = 'transferHbarCustodial',\n  TRANSFER_HBAR_NON_CUSTODIAL = 'transferHbarNonCustodial',\n  ASSET_ALLOWANCE_CUSTODIAL = 'assetAllowedCustodial',\n  ASSET_ALLOWANCE_NON_CUSTODIAL = 'assetAllowedNonCustodial',\n}\n\n/**\n * Parameters for creating a new Hedera Consensus Service (HCS) topic.\n */\nexport interface CreateTopicParams {\n  /** Optional. The publicly visible memo for the topic. */\n  memo?: string;\n  /**\n   * Optional. The administrative key for the topic.\n   * Can be a PrivateKey string (for the builder to derive public key and potentially sign if different from operator)\n   * or a PublicKey object.\n   * If not provided, the topic might be immutable depending on Hedera defaults, or operator may become admin.\n   */\n  adminKey?: string | Key;\n  /**\n   * Optional. The key authorized to submit messages to the topic.\n   * Can be a PrivateKey string or a PublicKey object.\n   * If not provided, anyone can submit.\n   */\n  submitKey?: string | Key;\n  /**\n   * Optional. The auto-renewal period for the topic, in seconds.\n   * Defaults to 7776000 (approximately 90 days) if not specified by the user; the builder will apply this default.\n   */\n  autoRenewPeriod?: number;\n  /**\n   * Optional. The account ID to be used for auto-renewal payments.\n   * If not provided, and if an adminKey is the current signer, the signer's account may be used by default by Hedera.\n   * Can be an AccountId object or a string representation (e.g., \"0.0.xxxx\").\n   */\n  autoRenewAccountId?: string | AccountId;\n  /** Optional. The key which can change the token's custom fee schedule. If not set, the adminKey may control this. */\n  feeScheduleKey?: string | Key;\n  /** Optional. A list of account IDs that should be exempt from custom fees. */\n  exemptAccountIds?: string[];\n  /** Optional. A list of custom fees to be applied to the topic. */\n  customFees?: CustomFixedFee[];\n}\n\n/**\n * Parameters for submitting a message to an HCS topic.\n */\nexport interface SubmitMessageParams {\n  /** The ID of the topic to submit the message to. */\n  topicId: string | TopicId;\n  /** The message content. Can be a string or Uint8Array for binary data. */\n  message: string | Uint8Array;\n  /**\n   * Optional. The maximum number of chunks to divide the message into if it exceeds single transaction limits.\n   * The builder will handle chunking if necessary.\n   */\n  maxChunks?: number;\n  /**\n   * Optional. The size of each chunk in bytes if chunking is performed.\n   * Defaults to a reasonable value (e.g., 1024 bytes) if not specified and chunking is needed.\n   */\n  chunkSize?: number;\n  /**\n   * Optional. A specific private key to sign message submission if the topic requires it\n   * and it's different from the main operator/signer.\n   * Can be a PrivateKey object or its string representation.\n   */\n  submitKey?: string | PrivateKey;\n}\n\n/**\n * Parameters for deleting an HCS topic.\n */\nexport interface DeleteTopicParams {\n  /** The ID of the topic to be deleted. */\n  topicId: string | TopicId;\n}\n\n/**\n * Represents a single hbar transfer operation.\n * Amount is in hbars (positive for credit, negative for debit).\n */\nexport interface HbarTransfer {\n  accountId: string | AccountId;\n  amount: Hbar;\n}\n\n/**\n * Parameters for an HBAR transfer operation, potentially involving multiple accounts.\n * The sum of all transfer amounts must be zero.\n */\nexport interface HbarTransferParams {\n  transfers: HbarTransfer[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for creating a new Hedera Fungible Token.\n */\nexport interface FTCreateParams {\n  /** The publicly visible name of the token. Max 100 characters. */\n  tokenName: string;\n  /** The publicly visible symbol of the token. Max 100 characters. */\n  tokenSymbol: string;\n  /** The account which will act as a treasury for the token. This account will receive the initial supply. */\n  treasuryAccountId: string | AccountId;\n  /** The initial supply of tokens to be minted to the treasury account. In the smallest denomination. */\n  initialSupply: number | BigNumber;\n  /** The number of decimal places a token is divisible by. */\n  decimals: number;\n  /** The key which can perform update/delete operations on the token. */\n  adminKey?: string | Key;\n  /** The key which can grant or revoke KYC of an account for the token. */\n  kycKey?: string | Key;\n  /** The key which can sign to freeze or unfreeze an account for token transactions. */\n  freezeKey?: string | Key;\n  /** The key which can wipe the token balance of an account. */\n  wipeKey?: string | Key;\n  /** The key which can change the total supply of a token. */\n  supplyKey?: string | Key;\n  /** The key which can change the token's custom fee schedule. */\n  feeScheduleKey?: string | Key;\n  /** The key which can pause or unpause the token. */\n  pauseKey?: string | Key;\n  /** The account which will be automatically charged to renew the token's expiration. */\n  autoRenewAccountId?: string | AccountId;\n  /** The period that the auto-renew account will be charged to extend the token's expiry. In seconds. Defaults to 7776000 (90 days). */\n  autoRenewPeriod?: number;\n  /** The memo associated with the token. Max 100 characters. */\n  memo?: string;\n  /** The default freeze status (frozen or unfrozen) of accounts signed up for this token. Defaults to false (unfrozen). */\n  freezeDefault?: boolean;\n  /** The custom fees to be assessed during atomic swaps for this token. */\n  customFees?: CustomFee[] | undefined;\n  /** The supply type of the token (Finite or Infinite). */\n  supplyType: TokenSupplyType;\n  /** The maximum number of tokens that can be in circulation. Required if supplyType is Finite. */\n  maxSupply?: number | BigNumber;\n}\n\n/**\n * Parameters for creating a new Hedera Non-Fungible Token (NFT).\n */\nexport interface NFTCreateParams {\n  /** The publicly visible name of the token. Max 100 characters. */\n  tokenName: string;\n  /** The publicly visible symbol of the token. Max 100 characters. */\n  tokenSymbol: string;\n  /** The account which will act as a treasury for the token. */\n  treasuryAccountId: string | AccountId;\n  /** The key which can perform update/delete operations on the token. */\n  adminKey?: string | Key;\n  /** The key which can grant or revoke KYC of an account for the token. */\n  kycKey?: string | Key;\n  /** The key which can sign to freeze or unfreeze an account for token transactions. */\n  freezeKey?: string | Key;\n  /** The key which can wipe the token balance of an account. */\n  wipeKey?: string | Key;\n  /** The key which can change the total supply of a token (mint/burn). */\n  supplyKey?: string | Key;\n  /** The key which can change the token's custom fee schedule. */\n  feeScheduleKey?: string | Key;\n  /** The key which can pause or unpause the token. */\n  pauseKey?: string | Key;\n  /** The account which will be automatically charged to renew the token's expiration. */\n  autoRenewAccountId?: string | AccountId;\n  /** The period that the auto-renew account will be charged to extend the token's expiry. In seconds. Defaults to 7776000 (90 days). */\n  autoRenewPeriod?: number;\n  /** The memo associated with the token. Max 100 characters. */\n  memo?: string;\n  /** The default freeze status (frozen or unfrozen) of accounts signed up for this token. Defaults to false (unfrozen). */\n  freezeDefault?: boolean;\n  /** The custom fees to be assessed. Instances of FixedFee, FractionalFee, RoyaltyFee (all extend CustomFee). */\n  customFees?: CustomFee[];\n  /** The supply type, typically Finite for NFTs. Max supply also needed for Finite. */\n  supplyType: TokenSupplyType; // e.g., TokenSupplyType.Finite\n  /** The maximum number of NFTs that can be minted. Required if supplyType is Finite. */\n  maxSupply?: number | BigNumber; // BigNumber for consistency, though NFTs are u64\n}\n\n/**\n * Parameters for minting new NFTs for a given NFT token.\n */\nexport interface MintNFTParams {\n  /** The ID of the NFT token to mint for. */\n  tokenId: string | TokenId;\n  /**\n   * An array of human-readable strings representing metadata for each NFT to be minted.\n   * Each string will be encoded as UTF-8 and must result in 100 bytes or less.\n   */\n  metadata: string[];\n  /** Optional. The batch size for minting transactions if many NFTs are minted. Defaults to 10. */\n  batchSize?: number | undefined;\n  nftId?: NftId | undefined;\n  senderAccountId?: string | AccountId | undefined;\n  receiverAccountId?: string | AccountId | undefined;\n  isApproved?: boolean | undefined;\n  memo?: string | undefined;\n}\n\n/**\n * Parameters for updating an existing HCS topic.\n * All fields are optional except topicId. Providing `null` to a key field typically clears it.\n * Using an empty string for memo clears it.\n */\nexport interface UpdateTopicParams {\n  /** The ID of the topic to update. */\n  topicId: string | TopicId;\n  /** New memo for the topic. An empty string effectively clears the memo. `null` can also be used to signal clearing. */\n  memo?: string | null;\n  /** New admin key for the topic. `null` to clear the admin key (if permissible). */\n  adminKey?: string | Key | null;\n  /** New submit key for the topic. `null` to clear the submit key. */\n  submitKey?: string | Key | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New account ID for auto-renewal. `null` to clear the auto-renew account. */\n  autoRenewAccountId?: string | AccountId | null;\n  /** New fee schedule key for the topic. `null` to clear. */\n  feeScheduleKey?: string | Key | null;\n  /** Optional. A list of account IDs that should be exempt from custom fees. This will overwrite any existing exemptions. To clear all exemptions, provide an empty array. */\n  exemptAccountIds?: string[];\n}\n\n/**\n * Parameters for minting more fungible tokens.\n */\nexport interface MintFTParams {\n  /** The ID of the fungible token to mint for. */\n  tokenId: string | TokenId;\n  /** The amount of tokens to mint, in the smallest unit of the token. */\n  amount: number | BigNumber;\n}\n\n/**\n * Parameters for burning fungible tokens.\n */\nexport interface BurnFTParams {\n  /** The ID of the fungible token to burn. */\n  tokenId: string | TokenId;\n  /** The amount of tokens to burn, in the smallest unit of the token. */\n  amount: number | BigNumber;\n}\n\n/**\n * Parameters for burning Non-Fungible Tokens.\n */\nexport interface BurnNFTParams {\n  /** The ID of the NFT token whose serials are to be burned. */\n  tokenId: string | TokenId;\n  /** An array of serial numbers to burn. Values can be number, Long, or BigNumber for large serials. */\n  serials: Array<number | Long | BigNumber>;\n}\n\n/**\n * Parameters for transferring a single Non-Fungible Token (NFT).\n */\nexport interface TransferNFTParams {\n  /** The token ID of the NFT (e.g., \"0.0.12345\"). */\n  tokenId: string;\n  /** The serial number of the NFT within the token. Can be a number or a string representing a positive integer.*/\n  serial: string | number;\n  /** The account ID of the sender. */\n  senderAccountId: string | AccountId;\n  /** The account ID of the receiver. */\n  receiverAccountId: string | AccountId;\n  /**\n   * Optional. Set to true if the sender is not the owner of the NFT but is an approved operator for it (or for all of owner's NFTs).\n   * Defaults to false, indicating the sender is the owner.\n   */\n  isApproved?: boolean;\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for associating tokens with an account.\n */\nexport interface AssociateTokensParams {\n  /** The account ID to associate tokens with. */\n  accountId: string | AccountId;\n  /** An array of token IDs to associate. */\n  tokenIds: Array<string | TokenId>;\n  initialBalance?: number | BigNumber | undefined;\n  key: string | PublicKey;\n  memo?: string;\n  autoRenewAccountId?: string | AccountId;\n  autoRenewPeriod?: number;\n  receiverSignatureRequired?: boolean;\n  maxAutomaticTokenAssociations?: number;\n  stakedAccountId?: string | AccountId;\n  stakedNodeId?: number | Long;\n  declineStakingReward?: boolean;\n  alias?: EvmAddress | string;\n}\n\n/**\n * Parameters for dissociating tokens from an account.\n */\nexport interface DissociateTokensParams {\n  /** The account ID to dissociate tokens from. */\n  accountId: string | AccountId;\n  /** An array of token IDs to dissociate. */\n  tokenIds: Array<string | TokenId>;\n}\n\n/**\n * Represents a single fungible token transfer operation.\n * Amount is in the smallest unit (positive for credit, negative for debit).\n */\nexport interface FungibleTokenTransferSpec {\n  type: 'fungible';\n  tokenId: string | TokenId;\n  accountId: string | AccountId;\n  amount: number | BigNumber;\n}\n\n/**\n * Represents a single non-fungible token (NFT) transfer operation.\n */\nexport interface NonFungibleTokenTransferSpec {\n  type: 'nft';\n  nftId: NftId;\n  senderAccountId: string | AccountId;\n  receiverAccountId: string | AccountId;\n  isApproved?: boolean;\n}\n\n/**\n * Union type for different kinds of token transfers.\n */\nexport type TokenTransferSpec =\n  | FungibleTokenTransferSpec\n  | NonFungibleTokenTransferSpec;\n\n/**\n * Parameters for a generic token transfer operation, potentially involving multiple tokens and NFTs.\n */\nexport interface TransferTokensParams {\n  /** An array of token transfer specifications (fungible or NFT). */\n  tokenTransfers: TokenTransferSpec[];\n  /** Optional. An array of HBAR transfer specifications. */\n  hbarTransfers?: HbarTransfer[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for wiping tokens (fungible or non-fungible) from an account.\n */\nexport interface WipeTokenAccountParams {\n  /** The ID of the token to wipe. */\n  tokenId: string | TokenId;\n  /** The account ID from which tokens will be wiped. */\n  accountId: string | AccountId;\n  /** For Fungible Tokens: the amount to wipe. In the smallest unit. */\n  amount?: number | BigNumber;\n  /** For Non-Fungible Tokens: an array of serial numbers to wipe. */\n  serials?: Array<number | Long | BigNumber>;\n}\n\n/**\n * Parameters for freezing an account for a specific token.\n */\nexport interface FreezeTokenAccountParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to be frozen for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for unfreezing an account for a specific token.\n */\nexport interface UnfreezeTokenAccountParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to be unfrozen for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for granting KYC to an account for a specific token.\n */\nexport interface GrantKycTokenParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to be granted KYC for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for revoking KYC from an account for a specific token.\n */\nexport interface RevokeKycTokenParams {\n  /** The ID of the token. */\n  tokenId: string | TokenId;\n  /** The account ID to have KYC revoked for the token. */\n  accountId: string | AccountId;\n}\n\n/**\n * Parameters for pausing a token.\n */\nexport interface PauseTokenParams {\n  /** The ID of the token to pause. */\n  tokenId: string | TokenId;\n}\n\n/**\n * Parameters for unpausing a token.\n */\nexport interface UnpauseTokenParams {\n  /** The ID of the token to unpause. */\n  tokenId: string | TokenId;\n}\n\n/**\n * Parameters for updating an existing Hedera token (fungible or non-fungible).\n * All fields are optional except `tokenId`. Providing `null` to a key field clears it.\n * Using an empty string for memo/name/symbol clears them if applicable by SDK.\n */\nexport interface UpdateTokenParams {\n  /** The ID of the token to update. */\n  tokenId: string | TokenId;\n  /** New name for the token. */\n  tokenName?: string | null; // null or empty to clear/reset if SDK allows\n  /** New symbol for the token. */\n  tokenSymbol?: string | null; // null or empty to clear/reset if SDK allows\n  /** New treasury account for the token. */\n  treasuryAccountId?: string | AccountId;\n  /** New admin key for the token. `null` to clear. */\n  adminKey?: string | Key | null;\n  /** New KYC key for the token. `null` to clear. */\n  kycKey?: string | Key | null;\n  /** New freeze key for the token. `null` to clear. */\n  freezeKey?: string | Key | null;\n  /** New wipe key for the token. `null` to clear. */\n  wipeKey?: string | Key | null;\n  /** New supply key for the token. `null` to clear. */\n  supplyKey?: string | Key | null;\n  /** New fee schedule key for the token. `null` to clear. */\n  feeScheduleKey?: string | Key | null;\n  /** New pause key for the token. `null` to clear. */\n  pauseKey?: string | Key | null;\n  /** New auto-renew account for the token. `null` to clear. */\n  autoRenewAccountId?: string | AccountId | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New memo for the token. An empty string or `null` to clear. */\n  memo?: string | null;\n  // Note: Custom fees are not updated via TokenUpdateTransaction. Use TokenFeeScheduleUpdateTransaction.\n}\n\n/**\n * Parameters for deleting a token.\n */\nexport interface DeleteTokenParams {\n  /** The ID of the token to delete. */\n  tokenId: string | TokenId;\n}\n\n/**\n * Parameters for updating the fee schedule of a token.\n */\nexport interface TokenFeeScheduleUpdateParams {\n  /** The ID of the token whose fee schedule is to be updated. */\n  tokenId: string | TokenId;\n  /** An array of new custom fees for the token. This will replace the existing fee schedule. */\n  customFees: CustomFee[];\n}\n\n/**\n * Parameters for creating a new Hedera account.\n */\nexport interface CreateAccountParams {\n  /** The initial balance of the new account in HBAR. Defaults to 0 if not specified. */\n  initialBalance?: number | BigNumber | undefined;\n  /**\n   * The public key for the new account.\n   * Can be a PublicKey object or a string representation of a PrivateKey\n   * from which the PublicKey will be derived by the builder.\n   * If a PrivateKey string is provided, it is used ONLY to derive the public key for account creation\n   * and is NOT stored or used for signing by the builder itself.\n   */\n  key: string | PublicKey;\n  /** Optional. The memo for the account. */\n  memo?: string;\n  /** Optional. The account to be used for auto-renewal payments. */\n  autoRenewAccountId?: string | AccountId;\n  /** Optional. The auto-renewal period for the account, in seconds. Defaults to ~90 days. */\n  autoRenewPeriod?: number;\n  /** Optional. If true, the account must sign any transaction transferring hbar out of this account. Defaults to false. */\n  receiverSignatureRequired?: boolean;\n  /** Optional. The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0. */\n  maxAutomaticTokenAssociations?: number;\n  /** Optional. The account to which this account is staked. */\n  stakedAccountId?: string | AccountId;\n  /** Optional. The node ID to which this account is staked. */\n  stakedNodeId?: number | Long;\n  /** Optional. If true, the account declines receiving a staking reward. Defaults to false. */\n  declineStakingReward?: boolean;\n  /** Optional. The alias for the account. If an alias is set, the key property is not used. */\n  alias?: EvmAddress | string; // string could be an EVM address string\n}\n\n/**\n * Parameters for querying a smart contract function (local call).\n */\nexport interface ContractCallQueryParams {\n  /** The ID of the contract to call. */\n  contractId: string | ContractId;\n  /** The gas to use for the query. Often less critical for local queries but can be set. */\n  gas?: number | Long; // Optional, as SDK might default or it might not be needed for all local queries\n  /** The function name and optionally its parameter types, e.g., \"getBalance(address)\". */\n  functionName: string;\n  /** The parameters to pass to the function. */\n  functionParameters?: ContractFunctionParameters;\n  /** Optional: The maximum payment allowed for this query. If not set, defaults to a value set by the SDK or node. */\n  maxQueryPayment?: Hbar;\n  /** Optional: Payment transaction ID for this query. */\n  paymentTransactionId?: string | TransactionId;\n}\n\n/**\n * Parameters for creating a new smart contract.\n */\nexport interface CreateContractParams {\n  /** The ID of the file containing the contract bytecode. Use this OR `bytecode`. */\n  bytecodeFileId?: string | FileId;\n  /** The contract bytecode as a hex-encoded string or Uint8Array. Use this OR `bytecodeFileId`. */\n  bytecode?: string | Uint8Array;\n  /** The admin key for the contract. */\n  adminKey?: string | Key;\n  /** The gas to deploy the contract. */\n  gas: number | Long;\n  /** Initial balance to send to the contract (payable constructor). In HBAR. */\n  initialBalance?: number | BigNumber;\n  /** The parameters to pass to the constructor. */\n  constructorParameters?: Uint8Array | ContractFunctionParameters;\n  /** Memo for the contract creation transaction. */\n  memo?: string;\n  /** Auto-renewal period for the contract. In seconds. */\n  autoRenewPeriod?: number;\n  /** Account to which this contract is staked. */\n  stakedAccountId?: string | AccountId;\n  /** Node ID to which this contract is staked. */\n  stakedNodeId?: number | Long;\n  /** If true, the contract declines receiving a staking reward. */\n  declineStakingReward?: boolean;\n  /** Max automatic token associations for the contract. */\n  maxAutomaticTokenAssociations?: number;\n  contractId: string | ContractId;\n  functionName: string;\n  functionParameters?: ContractFunctionParameters;\n  payableAmount?: number | BigNumber | Hbar;\n}\n\n/**\n * Parameters for executing a function of a smart contract.\n */\nexport interface ExecuteContractParams {\n  /** The ID of the contract to call. */\n  contractId: string | ContractId; // ContractId from SDK\n  /** The gas to use for the call. */\n  gas: number | Long;\n  /** The function to call. Can be just the name or name with parameters like \"functionName(uint32,string)\". */\n  functionName: string;\n  /** The parameters to pass to the function. */\n  functionParameters?: ContractFunctionParameters;\n  /** Amount of HBAR to send with the call (for payable functions). */\n  payableAmount?: number | BigNumber | Hbar;\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for creating a new file on Hedera File Service.\n */\nexport interface CreateFileParams {\n  /** The contents of the file. */\n  contents: string | Uint8Array;\n  /**\n   * The keys that must sign any transaction to modify or delete the file.\n   * If not set, the file is immutable (except for append if no keys are set at all).\n   * Each element can be a PrivateKey string (to derive PublicKey), a PublicKey object, or a KeyList object.\n   */\n  keys?: Array<string | Key | KeyList>;\n  /** A memo associated with the file. Max 100 characters. */\n  adminKey?: string | Key | null;\n  autoRenewPeriod?: number;\n  memo?: string | null;\n  stakedAccountId?: string | AccountId | '0.0.0' | null;\n  stakedNodeId?: number | Long | null;\n  declineStakingReward?: boolean;\n  maxAutomaticTokenAssociations?: number;\n  proxyAccountId?: string | AccountId | '0.0.0' | null;\n}\n\n/**\n * Parameters for appending content to an existing file on Hedera File Service.\n */\nexport interface AppendFileParams {\n  /** The ID of the file to append to. */\n  fileId: string | FileId;\n  /** The content to append. */\n  contents: string | Uint8Array;\n  /** Optional. The number of chunks to break the content into if it exceeds the transaction size limit. */\n  maxChunks?: number;\n  /** Optional. The size of each chunk in bytes. Defaults to a value like 4KB or 6KB minus overhead. */\n  chunkSize?: number;\n}\n\n/**\n * Parameters for updating the attributes of an existing file on Hedera File Service.\n * Note: This does not replace file contents; use FileAppend or recreate for that.\n */\nexport interface UpdateFileParams {\n  /** The ID of the file to update. */\n  fileId: string | FileId;\n  /** New keys for the file. An empty array can be used to remove all keys, making the file immutable. */\n  keys?: Array<string | Key | KeyList> | null; // null or empty array to clear keys\n  /** New memo for the file. An empty string or `null` to clear. */\n  memo?: string | null;\n  /** New contents for the file. */\n  contents?: string | Uint8Array;\n}\n\n/**\n * Parameters for deleting a file from Hedera File Service.\n */\nexport interface DeleteFileParams {\n  /** The ID of the file to delete. */\n  fileId: string | FileId;\n}\n\n/**\n * Parameters for updating an existing smart contract.\n * All fields are optional except `contractId`.\n */\nexport interface UpdateContractParams {\n  /** The ID of the contract to update. */\n  contractId: string | ContractId;\n  /** New admin key for the contract. `null` to clear. */\n  adminKey?: string | Key | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New memo for the contract. An empty string or `null` to clear. */\n  memo?: string | null;\n  /** New account to which this contract is staked. `null` to unstake. */\n  stakedAccountId?: string | AccountId | '0.0.0' | null; // \"0.0.0\" to remove staking\n  /** New node ID to which this contract is staked. `-1` to remove staking. */\n  stakedNodeId?: number | Long | null;\n  /** If true, the contract declines receiving a staking reward. */\n  declineStakingReward?: boolean;\n  /** New max automatic token associations for the contract. */\n  maxAutomaticTokenAssociations?: number;\n  /** New proxy account ID for the contract. `null` or `\"0.0.0\"` to clear. */\n  proxyAccountId?: string | AccountId | '0.0.0' | null;\n  // Updating bytecode (bytecodeFileId) is not part of ContractUpdateTransaction.\n}\n\n/**\n * Parameters for deleting a smart contract.\n */\nexport interface DeleteContractParams {\n  /** The ID of the contract to delete. */\n  contractId: string | ContractId;\n  /**\n   * Optional. The account ID to transfer the contract's remaining HBAR balance to.\n   * Required if the contract has a non-zero balance. Use this OR `transferContractId`.\n   */\n  transferAccountId?: string | AccountId;\n  /**\n   * Optional. The contract ID to transfer the contract's remaining HBAR balance to.\n   * Required if the contract has a non-zero balance. Use this OR `transferAccountId`.\n   */\n  transferContractId?: string | ContractId;\n  // Note: If contract has balance, one of transferAccountId or transferContractId must be set.\n  // The builder method will need to enforce this or document it clearly.\n}\n\n/**\n * Parameters for updating an existing Hedera account.\n * All fields are optional except `accountIdToUpdate`.\n */\nexport interface UpdateAccountParams {\n  /** The ID of the account to update. */\n  accountIdToUpdate: string | AccountId;\n  /** New key for the account. `null` to clear (not typically allowed unless other conditions met). */\n  key?: string | Key | null;\n  /** New auto-renewal period in seconds. */\n  autoRenewPeriod?: number;\n  /** New memo for the account. An empty string or `null` to clear. */\n  memo?: string | null;\n  /** New max automatic token associations for the account. */\n  maxAutomaticTokenAssociations?: number;\n  /** New account to which this account is staked. \"0.0.0\" or `null` to remove staking. */\n  stakedAccountId?: string | AccountId | '0.0.0' | null;\n  /** New node ID to which this account is staked. `-1` or `null` to remove staking. */\n  stakedNodeId?: number | Long | null;\n  /** If true, the account declines receiving a staking reward. */\n  declineStakingReward?: boolean;\n  /** If true, the account must sign any transaction transferring hbar out of this account. */\n  receiverSignatureRequired?: boolean;\n  amount: number | Long;\n}\n\n/**\n * Parameters for deleting an account.\n */\nexport interface DeleteAccountParams {\n  /** The ID of the account to be deleted. This account must sign the transaction. */\n  deleteAccountId: string | AccountId;\n  /** The ID of the account to transfer the remaining HBAR balance to. */\n  transferAccountId: string | AccountId;\n}\n\n/**\n * Parameters for approving an HBAR allowance.\n */\nexport interface ApproveHbarAllowanceParams {\n  /** The account ID of the HBAR owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender who is being granted the allowance. */\n  spenderAccountId: string | AccountId;\n  /** The maximum HBAR amount that the spender can use from the owner's account. */\n  amount: Hbar;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for approving an NFT allowance.\n */\nexport interface ApproveTokenNftAllowanceParams {\n  /** The account ID of the NFT owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender who is being granted the allowance. */\n  spenderAccountId: string | AccountId;\n  /** The ID of the NFT collection. */\n  tokenId: string | TokenId;\n  /** Optional. Specific serial numbers to approve. Use this OR `allSerials`. */\n  serials?: Array<number | Long | BigNumber>;\n  /** Optional. If true, approves the spender for all serials of the given NFT ID owned by the owner. Use this OR `serials`. */\n  allSerials?: boolean;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for approving a fungible token allowance.\n */\nexport interface ApproveFungibleTokenAllowanceParams {\n  /** The account ID of the token owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender who is being granted the allowance. */\n  spenderAccountId: string | AccountId;\n  /** The ID of the fungible token. */\n  tokenId: string | TokenId;\n  /** The maximum amount of the token that the spender can use from the owner's account. In smallest unit. */\n  amount: number | BigNumber;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for deleting all NFT allowances for a specific token collection granted by an owner.\n * This removes allowances for all spenders for all serials of the specified token type from this owner.\n */\nexport interface DeleteNftAllowanceAllSerialsParams {\n  /** The account ID of the NFT owner whose allowances are being deleted. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The ID of the NFT collection (token ID) for which all serial allowances will be deleted. */\n  tokenId: string | TokenId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for revoking/clearing an HBAR allowance for a specific spender.\n */\nexport interface RevokeHbarAllowanceParams {\n  /** The account ID of the HBAR owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender whose HBAR allowance is to be revoked (set to zero). */\n  spenderAccountId: string | AccountId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for revoking/clearing a fungible token allowance for a specific spender.\n */\nexport interface RevokeFungibleTokenAllowanceParams {\n  /** The account ID of the token owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The account ID of the spender whose token allowance is to be revoked (set to zero). */\n  spenderAccountId: string | AccountId;\n  /** The ID of the fungible token. */\n  tokenId: string | TokenId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Represents a recipient for a token airdrop.\n */\nexport interface AirdropRecipient {\n  /** The account ID of the recipient. */\n  accountId: string | AccountId;\n  /** The amount of tokens to send (in smallest denomination). */\n  amount: number | Long; // Consistent with other token amounts\n}\n\n/**\n * Parameters for airdropping fungible tokens from the operator's account.\n * The operator (signer) is implicitly the sender of all amounts.\n */\nexport interface AirdropTokenParams {\n  /** The ID of the fungible token to airdrop. */\n  tokenId: string | TokenId;\n  /** An array of recipient objects, each specifying an account and an amount. */\n  recipients: AirdropRecipient[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n  pendingAirdropIds: PendingAirdropId[];\n}\n\n/**\n * Parameters for rejecting a pending airdrop or future tokens.\n */\nexport interface RejectAirdropParams {\n  /** The ID of the token that was airdropped. */\n  tokenId: string | TokenId;\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for claiming pending airdrops.\n */\nexport interface ClaimAirdropParams {\n  /** An array of SDK PendingAirdropId objects to claim. The operator (signer) is the recipient. */\n  pendingAirdropIds: PendingAirdropId[]; // Assuming PendingAirdropId is imported from @hashgraph/sdk\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for cancelling previously sent (but still pending) airdrops.\n */\nexport interface CancelAirdropParams {\n  /** An array of SDK PendingAirdropId objects to cancel. The operator (signer) must be the original sender. */\n  pendingAirdropIds: PendingAirdropId[]; // Assuming PendingAirdropId is imported from @hashgraph/sdk\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for rejecting future auto-associations with specified token types.\n */\nexport interface RejectFutureAssociationsParams {\n  // Implementation of this parameter is not provided in the original file or the code block\n  // This parameter is mentioned in the RejectAirdropParams, but its implementation is not clear\n  // It's assumed to exist as it's called in the RejectAirdropParams\n}\n\n/**\n * Parameters for signing a scheduled transaction.\n */\nexport interface SignScheduledTransactionParams {\n  /** The ID of the schedule to add a signature to. */\n  scheduleId: string | ScheduleId;\n  /** Optional memo for the ScheduleSign transaction itself. */\n  memo?: string;\n}\n\n/**\n * Parameters for querying topic information.\n */\nexport interface GetTopicInfoParams {\n  /** The ID of the topic to query. */\n  topicId: string | TopicId;\n  /** Optional. Maximum number of retries for the query. */\n  maxRetries?: number;\n}\n\n/**\n * Result of querying topic information.\n */\nexport interface TopicInfoResult {\n  topicId: string;\n  topicMemo: string;\n  runningHash: string; // hex encoded\n  sequenceNumber: string; // string representation of u64\n  expirationTime?: string; // ISO string format\n  adminKey?: string; // string representation of the key\n  autoRenewAccount?: string;\n  autoRenewPeriod?: string; // string representation of seconds\n  ledgerId?: string;\n}\n\n/**\n * Parameters for deleting/revoking NFT allowances for a *specific spender* for a token collection.\n * This uses AccountAllowanceDeleteTransaction.deleteAllTokenNftAllowances(tokenId, owner, spender).\n */\nexport interface DeleteNftSpenderAllowanceParams {\n  /** The account ID of the NFT owner. Defaults to the operator/signer account ID if not provided. */\n  ownerAccountId?: string | AccountId;\n  /** The ID of the NFT collection (token ID). */\n  nftId: string | NftId;\n  /** Optional. A memo for the transaction. */\n  memo?: string;\n}\n\n/**\n * Parameters for deleting/revoking NFT allowances for specific serials for a specific spender.\n */\nexport interface DeleteNftSpenderAllowanceToolParams {\n  ownerAccountId?: string | AccountId;\n  spenderAccountId: string | AccountId;\n  tokenId: string | TokenId;\n  serials: Array<number | string | Long>;\n  memo?: string;\n}\n\n/**\n * Parameters for deleting all spender allowances for a specific NFT serial, granted by an owner.\n */\nexport interface DeleteNftSerialAllowancesParams {\n  ownerAccountId?: string | AccountId;\n  nftIdString: string; // e.g., \"0.0.tokenid.serial\"\n  memo?: string;\n  pendingAirdropIds: PendingAirdropId[];\n}\n\n// Added for ClaimAirdropTool\n/**\n * Parameters for claiming pending airdrops.\n * The SDK's PendingAirdropId is an object. For the tool's input,\n * we'll expect the structure that the SDK uses or a string that can be parsed into it.\n * The current HederaClaimAirdropTool Zod schema expects an array of strings.\n */\nexport interface ClaimAirdropParams {\n  /**\n   * An array of pending airdrop IDs to claim.\n   * These are expected to be strings that can be parsed into SDK PendingAirdropId objects if needed,\n   * or directly match the structure if SDK PendingAirdropId is serializable/deserializable simply.\n   * The @hashgraph/sdk PendingAirdropId is constructed with (accountId, tokenId, serialNumber).\n   * For simplicity in the tool input, we might expect an array of objects or structured strings.\n   * The tool placeholder Zod schema uses `z.array(z.string())` - this will need careful implementation\n   * in the actual tool to parse these strings into proper SDK PendingAirdropId objects.\n   * Let's align the type with the SDK's actual PendingAirdropId for now for builder methods.\n   */\n  pendingAirdropIds: PendingAirdropId[];\n  /** Optional memo for the transaction. */\n  memo?: string;\n}\n\n// Added for GetFileContentsTool\n/**\n * Parameters for querying file contents.\n */\nexport interface GetFileContentsParams {\n  fileId: string | FileId;\n  // maxRetries, payment, etc. could be added if BaseHederaQueryTool supports them\n}\n\n/**\n * Result of querying file contents.\n */\nexport interface FileContentsResult {\n  fileId: string;\n  contents: string; // Assuming string representation for simplicity, could be Uint8Array\n  // Could also include other file info if the query returns more\n}\n\n// Added for CallContractQueryTool\n/**\n * Parameters for calling a smart contract query function.\n * This aligns with SDK's ContractExecuteTransaction but for queries (ContractCallQuery).\n */\nexport interface CallContractQueryParams {\n  contractId: string | ContractId;\n  gas?: number | Long; // SDK: Long\n  functionName: string; // For query, this is often just the function selector or name\n  functionParameters?: ContractFunctionParameters;\n  maxQueryPayment?: Hbar; // For queries\n  paymentTransactionId?: TransactionId; // For queries\n  // senderAccountId?: string | AccountId; // For queries, client usually pays\n}\n\n/**\n * Result of a smart contract query call.\n */\nexport interface ContractQueryResult {\n  // Based on ContractFunctionResult from SDK\n  contractId?: string;\n  errorMessage?: string;\n  gasUsed?: string; // u64\n  // Various ways to get results based on type, e.getString, getInt32, etc.\n  // For a generic tool, might return raw bytes or a common representation.\n  resultAsBytes?: Uint8Array; // Raw result\n  resultDecoded?: unknown; // If ABI is available and decoding is attempted by the tool\n}\n"],"names":["AgentKitActionName"],"mappings":";AA4OO,IAAK,uCAAAA,wBAAL;AACLA,sBAAA,wBAAA,IAAyB;AACzBA,sBAAA,4BAAA,IAA6B;AAC7BA,sBAAA,wBAAA,IAAyB;AACzBA,sBAAA,4BAAA,IAA6B;AAC7BA,sBAAA,gCAAA,IAAiC;AACjCA,sBAAA,oCAAA,IAAqC;AACrCA,sBAAA,wBAAA,IAAyB;AACzBA,sBAAA,4BAAA,IAA6B;AAC7BA,sBAAA,2BAAA,IAA4B;AAC5BA,sBAAA,+BAAA,IAAgC;AAChCA,sBAAA,4BAAA,IAA6B;AAC7BA,sBAAA,gCAAA,IAAiC;AACjCA,sBAAA,yBAAA,IAA0B;AAC1BA,sBAAA,6BAAA,IAA8B;AAC9BA,sBAAA,wBAAA,IAAyB;AACzBA,sBAAA,4BAAA,IAA6B;AAC7BA,sBAAA,sBAAA,IAAuB;AACvBA,sBAAA,0BAAA,IAA2B;AAC3BA,sBAAA,0BAAA,IAA2B;AAC3BA,sBAAA,8BAAA,IAA+B;AAC/BA,sBAAA,yBAAA,IAA0B;AAC1BA,sBAAA,6BAAA,IAA8B;AAC9BA,sBAAA,0BAAA,IAA2B;AAC3BA,sBAAA,8BAAA,IAA+B;AAC/BA,sBAAA,yBAAA,IAA0B;AAC1BA,sBAAA,6BAAA,IAA8B;AAC9BA,sBAAA,2BAAA,IAA4B;AAC5BA,sBAAA,+BAAA,IAAgC;AA5BtB,SAAAA;AAAA,GAAA,sBAAA,CAAA,CAAA;"}